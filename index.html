<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Step 2b  - Metal Detecting Survey Log</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    
    <style>
        /* Custom colors using CSS variables for guaranteed consistency */
        :root {
            --color-primary: 29 78 216;      /* Blue (For contrast/borders) */
            --color-secondary: 34 197 94;    /* Vibrant Green (For action buttons) */
            --color-background: 243 244 246; /* Light Gray */
            --color-card: 255 255 255;       /* White */
        }

        /* Configure Tailwind to use the custom variables (kept for other classes like text-primary) */
        tailwind-config {
            theme: {
                extend: {
                    colors: {
                        primary: 'rgb(var(--color-primary) / <alpha-value>)',
                        secondary: 'rgb(var(--color-secondary) / <alpha-value>)',
                        background: 'rgb(var(--color-background) / <alpha-value>)',
                        card: 'rgb(var(--color-card) / <alpha-value>)',
                    }
                }
            }
        }

        /* Basic App Styling */
        body {
            font-family: 'Arial', sans-serif;
            background-color: rgb(var(--color-background));
        }

        /* Ensure the modal is hidden by default and handles clicks outside */
        .modal {
            display: none;
            position: fixed;
            z-index: 50;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }
        .modal-content {
            margin: 10vh auto;
            border-radius: 12px;
            max-width: 500px;
        }
    </style>
</head>
<body class="min-h-screen">

    <header class="bg-white shadow-md fixed top-0 left-0 right-0 z-40">
        <div class="container mx-auto max-w-lg">
            <div class="flex items-center justify-between p-4">
                <h1 class="text-xl font-extrabold text-primary">GeoFind Log</h1>
                <div class="flex space-x-2">
                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Home">
                        <i class="fas fa-home text-xl"></i>
                    </button>
                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Targets">
                        <i class="fas fa-bullseye text-xl"></i>
                    </button>
                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Compass">
                        <i class="fas fa-compass text-xl"></i>
                    </button>
                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150"
                    data-page="Finds">
                    <i class="fas fa-trophy text-xl"></i>
                    </button>

                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Settings">
                        <i class="fas fa-cog text-xl"></i>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <main id="app-content" class="container mx-auto max-w-lg pt-20 pb-4 min-h-screen"></main>

    <div id="message-toast" class="fixed bottom-4 right-4 z-50 p-4 rounded-lg text-white shadow-xl transition-opacity duration-300 opacity-0 pointer-events-none" style="min-width: 250px;"></div>

    <div id="confirmation-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 id="confirm-title" class="text-xl font-bold text-red-600 mb-4">Confirmation</h3>
            <p id="confirm-message" class="text-gray-700 mb-6"></p>
            <div class="flex justify-end space-x-3">
                <button id="confirm-no-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button id="confirm-yes-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-semibold">Yes, Proceed</button>
            </div>
        </div>
    </div>
    
    <div id="new-survey-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 class="text-xl font-bold text-primary mb-4">Create New Survey</h3>
            <form id="new-survey-form">
                <div class="mb-4">
                    <label for="survey-name" class="block text-sm font-medium text-gray-700">Survey Name *</label>
                    <input type="text" id="survey-name" name="surveyName" required 
                           class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                </div>
                <div class="mb-4">
                    <label for="survey-description" class="block text-sm font-medium text-gray-700">Description / Location</label>
                    <textarea id="survey-description" name="surveyDescription" rows="3" 
                              class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"></textarea>
                </div>
                <div class="flex justify-end space-x-3 mt-6">
                    <button type="button" onclick="closeNewSurveyModal()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                    <button type="submit" class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
                            style="background-color: rgb(var(--color-secondary));">
                        Create & Open
                    </button>
                </div>
            </form>
        </div>
    </div>

<!-- Edit Find Modal -->
<!-- Edit Find Modal (now matches Target modal structure) -->
<div id="edit-find-modal" class="modal">
  <div class="modal-content bg-white p-6 shadow-2xl">

    <!-- Header with close button -->
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-xl font-bold text-primary">Edit Find</h3>
      <button
        type="button"
        class="text-gray-400 hover:text-gray-600 text-xl leading-none"
        aria-label="Close"
        onclick="closeEditFindModal()">
        &times;
      </button>
    </div>

    <form id="edit-find-form" class="space-y-4">
      <!-- Hidden ID -->
      <input type="hidden" id="edit-find-id" name="findId">

      <!-- Description -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-description">
          Description / Find Name
        </label>
        <input
          type="text"
          id="edit-find-description"
          name="findDescription"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary"
          required>
      </div>

      <!-- Type -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-type">
          Type
        </label>
        <select
          id="edit-find-type"
          name="findType"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
          <option value="Coin">Coin</option>
          <option value="Relic">Relic</option>
          <option value="Jewellery">Jewellery</option>
          <option value="Modern">Modern</option>
          <option value="Trash">Trash</option>
          <option value="Unknown">Unknown</option>
        </select>
      </div>

      <!-- VDI + Depth -->
      <div class="grid grid-cols-2 gap-3">
        <div>
          <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-vdi">
            VDI
          </label>
          <input
            type="text"
            id="edit-find-vdi"
            name="findVDI"
            class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
        </div>
        <div>
          <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-depth">
            Depth
          </label>
          <input
            type="text"
            id="edit-find-depth"
            name="findDepth"
            class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
        </div>
      </div>

      <!-- Coordinates -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-coords">
          Coordinates
        </label>
        <input
          type="text"
          id="edit-find-coords"
          name="findCoords"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
      </div>

      <!-- Accuracy -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-accuracy">
          Accuracy
        </label>
        <input
          type="text"
          id="edit-find-accuracy"
          name="findAccuracy"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
      </div>

      <!-- NEW: Find photograph controls -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1">
          Find Photograph
        </label>

        <!-- Hidden file input (camera / gallery) -->
        <input
          type="file"
          id="edit-find-photo-input"
          accept="image/*;capture=camera"
          class="hidden"
          onchange="handleEditFindPhotoSelected(event)">

        <!-- Hidden field to store the Base64 photo data -->
        <input
          type="hidden"
          id="edit-find-photo-data"
          name="findPhotoData">

        <div class="flex items-center space-x-3 mt-1">
          <button
            type="button"
            class="px-3 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-sm font-semibold"
            onclick="triggerEditFindPhotoInput()">
            <i class="fas fa-camera mr-1"></i> Take / Choose Photo
          </button>
          <span id="edit-find-photo-status" class="text-xs text-gray-500">
            No photo captured yet.
          </span>
        </div>

        <div id="edit-find-photo-preview-wrapper" class="mt-2 hidden flex justify-center">
          <img
            id="edit-find-photo-preview"
            class="w-11/12 h-auto rounded-md border border-gray-300 object-cover"
            alt="Find photo preview">
        </div>
      </div>
      <!-- END NEW: Find photograph controls -->

      <!-- Footer buttons -->
      <div class="pt-2 flex justify-end gap-2">
        <button
          type="button"
          id="cancel-edit-find-btn"
          class="px-3 py-1 rounded-md border border-gray-300 text-gray-700 hover:bg-gray-100"
          onclick="closeEditFindModal()">
          Cancel
        </button>
        <button
          type="submit"
          class="px-4 py-2 rounded-md bg-green-600 text-white text-sm font-semibold hover:bg-green-700 transition">
          Save changes
        </button>
      </div>
    </form>
  </div>
</div>
    
    <div id="new-target-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 class="text-xl font-bold text-primary mb-4">Log New Target</h3>
            <form id="new-target-form">
                
                <div id="target-survey-display" class="bg-gray-100 p-2 rounded-md mb-4 text-sm font-semibold text-gray-700">
                    Logging for: <span id="current-target-survey-name" class="text-primary">Loading...</span>
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <div class="mb-4 col-span-2">
                        <label for="target-description" class="block text-sm font-medium text-gray-700">Description / Find Name *</label>
                        <input type="text" id="target-description" name="targetDescription" required 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                    <div class="mb-4">
                        <label for="target-vdi" class="block text-sm font-medium text-gray-700">Target ID</label>
                        <input type="text" id="target-vdi" name="targetVDI" placeholder="e.g., 28" 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                    <div class="mb-4">
                        <label for="target-depth" class="block text-sm font-medium text-gray-700">Depth</label>
                        <input type="text" id="target-depth" name="targetDepth" placeholder="e.g., 6 inches"
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
 <div class="mb-4 col-span-2">
    <label for="target-type" class="block text-sm font-medium text-gray-700">Type of Find *</label>
    <select id="target-type" name="targetType" required
            class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary bg-white">
        <option value="Unidentified">Unidentified</option>
        <option value="Iron Junk">Iron Junk</option>
        <option value="Modern Junk">Modern Junk</option>
         <option value="Coin">Coin</option>
        <option value="Ring">Ring</option>
        <option value="Jewelry">Jewelry</option>
        <option value="Relic">Relic</option>
        <option value="Something else.">Something else</option>

    </select>
</div>
<div class="mb-4 col-span-2">
    <label class="block text-sm font-medium text-gray-700 mb-1">Centre on map</label>
    <div class="flex space-x-4">
        <div class="flex items-center">
            <input id="target-center-yes" type="radio" name="targetCenterOnMap" value="Yes" checked
                   class="h-4 w-4 text-primary border-gray-300 focus:ring-primary">
            <label for="target-center-yes" class="ml-2 block text-sm text-gray-700">Yes</label>
        </div>
        <div class="flex items-center">
            <input id="target-center-no" type="radio" name="targetCenterOnMap" value="No"
                   class="h-4 w-4 text-primary border-gray-300 focus:ring-primary">
            <label for="target-center-no" class="ml-2 block text-sm text-gray-700">No</label>
        </div>
    </div>
</div>
<div class="mb-4 col-span-2">
    <label class="block text-sm font-medium text-gray-700 mb-1">
        Target Photograph
    </label>

    <input
        type="file"
        id="target-photo-input"
        accept="image/*;capture=camera"
        class="hidden"
        onchange="handleTargetPhotoSelected(event)"
    >

    <input
        type="hidden"
        id="target-photo-data"
        name="targetPhotoData"
    >

    <div class="flex items-center space-x-3">
        <button
            type="button"
            class="px-3 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-sm font-semibold"
            onclick="triggerTargetPhotoInput()"
        >
            <i class="fas fa-camera mr-1"></i> Take / Choose Photo
        </button>
        <span id="target-photo-status" class="text-xs text-gray-500">
            No photo captured yet.
        </span>
    </div>

    <div id="target-photo-preview-wrapper" class="mt-2 hidden flex justify-center">
        <img id="target-photo-preview" class="w-11/12 h-auto rounded-md border border-gray-300 object-cover" alt="Target photo preview">
    </div>
</div>
        <div class="mb-4 col-span-2">
                        <label for="target-coords" class="block text-sm font-medium text-gray-700 flex items-center">
                            GPS Coordinates
                            <span id="gps-loading-indicator" class="ml-2 text-primary text-xs hidden">
                                <i class="fas fa-spinner fa-spin mr-1"></i> Locating...
                            </span>
                        </label>
                        <input type="text" id="target-coords" name="targetCoords" placeholder="Requesting location..." 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                        <input type="hidden" id="target-accuracy" name="targetAccuracy">
                        <p id="gps-accuracy-display" class="text-xs text-gray-500 mt-1 hidden">Accuracy (Radius): <span class="font-semibold text-red-600">N/A</span></p>
                    </div>
                </div>

                <div class="flex justify-end space-x-3 mt-6">
                    <button type="button" onclick="closeNewTargetModal()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                    <button type="submit" class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
                            style="background-color: rgb(var(--color-secondary));">
                        Log Target
                    </button>
                </div>
            </form>
        </div>
    </div>
    
    <div id="edit-target-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 class="text-xl font-bold text-primary mb-4">Edit Target Details</h3>
            <form id="edit-target-form">
                <input type="hidden" id="edit-target-id" name="targetId">
                <input type="hidden" id="edit-survey-id" name="surveyId">

                <div id="edit-target-survey-display" class="bg-gray-100 p-2 rounded-md mb-4 text-sm font-semibold text-gray-700">
                    Editing target in: <span id="current-edit-survey-name" class="text-primary">Loading...</span>
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <div class="mb-4 col-span-2">
                        <label for="edit-target-description" class="block text-sm font-medium text-gray-700">Description / Find Name *</label>
                        <input type="text" id="edit-target-description" name="targetDescription" required 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                    <div class="mb-4">
                        <label for="edit-target-vdi" class="block text-sm font-medium text-gray-700">Target ID</label>
                        <input type="text" id="edit-target-vdi" name="targetVDI" placeholder="e.g., 28" 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                    <div class="mb-4">
                        <label for="edit-target-depth" class="block text-sm font-medium text-gray-700">Depth</label>
                        <input type="text" id="edit-target-depth" name="targetDepth" placeholder="e.g., 6 inches"
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
 <div class="mb-4 col-span-2">
    <label for="edit-target-type" class="block text-sm font-medium text-gray-700">Type of Find *</label>
    <select id="edit-target-type" name="targetType" required
            class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary bg-white">
        <option value="Unidentified">Unidentified</option>
        <option value="Iron Junk">Iron Junk</option>
        <option value="Modern Junk">Modern Junk</option>
         <option value="Coin">Coin</option>
        <option value="Ring">Ring</option>
        <option value="Jewelry">Jewelry</option>
        <option value="Relic">Relic</option>
        <option value="Something else.">Something else</option>
    </select>
     
</div>
<div class="mb-4 col-span-2">
    <label class="block text-sm font-medium text-gray-700 mb-1">Centre on map</label>
    <div class="flex space-x-4">
        <div class="flex items-center">
            <input id="edit-target-center-yes" type="radio" name="editTargetCenterOnMap" value="Yes"
                   class="h-4 w-4 text-primary border-gray-300 focus:ring-primary">
            <label for="edit-target-center-yes" class="ml-2 block text-sm text-gray-700">Yes</label>
        </div>
        <div class="flex items-center">
            <input id="edit-target-center-no" type="radio" name="editTargetCenterOnMap" value="No"
                   class="h-4 w-4 text-primary border-gray-300 focus:ring-primary">
            <label for="edit-target-center-no" class="ml-2 block text-sm text-gray-700">No</label>
        </div>
    </div>
</div>
<div class="mb-4 col-span-2">
    <label class="block text-sm font-medium text-gray-700 mb-1">
        Target Photograph
    </label>

    <input
        type="file"
        id="edit-target-photo-input"
        accept="image/*;capture=camera"
        class="hidden"
        onchange="handleEditTargetPhotoSelected(event)"
    >

    <input
        type="hidden"
        id="edit-target-photo-data"
        name="targetPhotoData"
    >

    <div class="flex items-center space-x-3">
        <button
            type="button"
            class="px-3 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-sm font-semibold"
            onclick="triggerEditTargetPhotoInput()"
        >
            <i class="fas fa-camera mr-1"></i> Take / Choose Photo
        </button>
        <span id="edit-target-photo-status" class="text-xs text-gray-500">
            No photo captured yet.
        </span>
    </div>

    <div id="edit-target-photo-preview-wrapper" class="mt-2 hidden flex justify-center">
        <img id="edit-target-photo-preview" class="w-11/12 h-auto rounded-md border border-gray-300 object-cover" alt="Target photo preview">
    </div>
</div>
                    
<div class="mb-4 col-span-2">
                        <label for="edit-target-coords" class="block text-sm font-medium text-gray-700">GPS Coordinates</label>
                        <input type="text" id="edit-target-coords" name="targetCoords" placeholder="e.g., 50.2568, -5.2345" 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                    <div class="mb-4 col-span-2">
                        <label for="edit-target-accuracy" class="block text-sm font-medium text-gray-700">GPS Accuracy (m)</label>
                        <input type="text" id="edit-target-accuracy" name="targetAccuracy" placeholder="e.g., 5.0" 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                </div>

                <div class="flex justify-end space-x-3 mt-6">
                    <button type="button" onclick="closeEditTargetModal()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                    <button type="submit" class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
                            style="background-color: rgb(var(--color-secondary));">
                        Save Target Changes
                    </button>
                </div>
            </form>
        </div>
    </div>
    
    <div id="edit-profile-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 class="text-xl font-bold text-primary mb-4">Edit Detectorist Profile</h3>
            <form id="edit-profile-form">
                <div class="mb-4">
                    <label for="profile-name" class="block text-sm font-medium text-gray-700">Detectorist Name *</label>
                    <input type="text" id="profile-name" name="profileName" required 
                           class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                </div>
                <div class="mb-4">
                    <label for="profile-detector" class="block text-sm font-medium text-gray-700">Detector Used</label>
                    <input type="text" id="profile-detector" name="profileDetector" required
                           class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                </div>
                <div class="flex justify-end space-x-3 mt-6">
                    <button type="button" onclick="closeEditProfileModal()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                    <button type="submit" class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
                            style="background-color: rgb(var(--color-secondary));">
                        Save Changes
                    </button>
                </div>
            </form>
        </div>
    </div>


    <script>
        // --- GLOBAL STATE & INITIALIZATION ---
        
// --- GLOBAL STATE & INITIALIZATION ---
    let surveys = [];
    let finds = [];  // <--- NEW: permanent library of Finds
    let currentPage = 'Home';
    let isMapFullscreen = false;
    let targetWatchId = null; // track the specific GPS process for the modal

// Simple filter state for the Finds page
    let findsFilter = {
        query: '',
        type: 'All',
        surveyId: 'All'
    };
        
        // Profile initialized with default data
        let userProfile = {
            name: "New User",
            detector: "Default Machine"
        };
        let userId;

      // --- NEW REAL-TIME LOCATION STATE ---
        let autoRefreshIntervalId = null; 
        let currentUserCoords = null;
        let currentUserAccuracy = null;
        let bestLiveAccuracy = Infinity;
        let liveMapWatchId = null;
        let navigationTargetId = null;

                // --- MOVEMENT HISTORY FOR DIRECTION-OF-TRAVEL GUIDANCE ---
        // Stores recent smoothed GPS positions so we can estimate which way
        // you're walking and give "left / right / ahead" style guidance.
        let movementHistory = [];
        const MOVEMENT_HISTORY_MAX_AGE_MS = 60000;     // keep ~60s of movement
        const MOVEMENT_HISTORY_MAX_LENGTH = 30;        // max number of points
        const MOVEMENT_MIN_DISTANCE_METERS = 2;        // need at least ~2m of motion


// NEW: smoothed position for the live map
        let smoothedUserCoords = null;
        const USER_SMOOTHING_ALPHA = 0.15; // 0 < alpha ≤ 1 (lower = smoother, slower)
//
        function updateSmoothedUserCoords(newLat, newLon) {
    // First reading: snap straight to the new value
    if (!smoothedUserCoords) {
        smoothedUserCoords = { lat: newLat, lon: newLon };
        return;
    }

    // Exponential moving average
    smoothedUserCoords.lat =
        smoothedUserCoords.lat + USER_SMOOTHING_ALPHA * (newLat - smoothedUserCoords.lat);
    smoothedUserCoords.lon =
        smoothedUserCoords.lon + USER_SMOOTHING_ALPHA * (newLon - smoothedUserCoords.lon);
}

        
// --- GEOGRAPHY HELPER FUNCTIONS ---

/** Converts degrees to radians. */
function toRad(degrees) {
    return degrees * (Math.PI / 180);
}

/** Converts radians to degrees. */
function toDeg(radians) {
    return radians * (180 / Math.PI);
}

/**
 * Normalises a longitude delta to the range [-180, 180] degrees.
 * This is what makes things behave correctly across the International Date Line.
 */
function normaliseDeltaLonDegrees(lon1Deg, lon2Deg) {
    let d = lon2Deg - lon1Deg; // in degrees
    if (d > 180) d -= 360;
    if (d < -180) d += 360;
    return d;
}

/**
 * Returns the great-circle distance between two WGS84 coordinates in metres.
 * Works globally (north/south of equator, across date line, any hemisphere).
 */
function distanceMeters(lat1Deg, lon1Deg, lat2Deg, lon2Deg) {
    const R = 6371000; // mean Earth radius in metres

    const φ1 = toRad(lat1Deg);
    const φ2 = toRad(lat2Deg);
    const Δφ = toRad(lat2Deg - lat1Deg);
    const Δλ = toRad(normaliseDeltaLonDegrees(lon1Deg, lon2Deg));

    const sinΔφ2 = Math.sin(Δφ / 2);
    const sinΔλ2 = Math.sin(Δλ / 2);

    const a =
        sinΔφ2 * sinΔφ2 +
        Math.cos(φ1) * Math.cos(φ2) * sinΔλ2 * sinΔλ2;

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
}

/**
 * Returns the initial bearing (forward azimuth) from point 1 to point 2
 * in degrees from true North, normalised to [0, 360).
 *
 * This also uses the normalised longitude delta so it behaves
 * correctly when crossing the date line.
 */
function initialBearingDegrees(lat1Deg, lon1Deg, lat2Deg, lon2Deg) {
    const φ1 = toRad(lat1Deg);
    const φ2 = toRad(lat2Deg);
    const Δλ = toRad(normaliseDeltaLonDegrees(lon1Deg, lon2Deg));

    const y = Math.sin(Δλ) * Math.cos(φ2);
    const x =
        Math.cos(φ1) * Math.sin(φ2) -
        Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

    let θ = Math.atan2(y, x); // in radians, -π..+π
    let bearing = (toDeg(θ) + 360) % 360; // into [0, 360)
    return bearing;
}

/**
 * Converts a bearing in degrees into a human-friendly compass label.
 * precision:
 *   4  -> N, E, S, W
 *   8  -> N, NE, E, SE, S, SW, W, NW
 *   16 -> N, NNE, NE, ENE, E, ... (default)
 */
function bearingToCompassPoint(bearingDeg, precision = 16) {
    const dirs =
        precision === 4
            ? ['N', 'E', 'S', 'W']
            : precision === 8
            ? ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']
            : [
                  'N', 'NNE', 'NE', 'ENE',
                  'E', 'ESE', 'SE', 'SSE',
                  'S', 'SSW', 'SW', 'WSW',
                  'W', 'WNW', 'NW', 'NNW'
              ];

    const step = 360 / dirs.length;
    const normalised = ((bearingDeg % 360) + 360) % 360; // 0..360
    const index = Math.round(normalised / step) % dirs.length;
    return dirs[index];
}

/** Clamps a number between a minimum and maximum value. */
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

/** Calculates the diameter (in meters) for the confidence circle: Accuracy * 2. */
function getCircleDiameter(accuracyInMeters) {
    if (typeof accuracyInMeters === 'number' && accuracyInMeters > 0) {
        return (accuracyInMeters * 2).toFixed(1); // Diameter = 2 * radius
    }
    return 'N/A';
}

// --- MOVEMENT & GUIDANCE HELPER FUNCTIONS ---

/**
 * Records a new smoothed movement sample.
 * Called from the live map GPS watch each time we get a new reading.
 */
function recordMovementSample(lat, lon) {
    const now = Date.now();
    movementHistory.push({ lat, lon, time: now });

    // Trim to recent history only
    if (movementHistory.length > MOVEMENT_HISTORY_MAX_LENGTH) {
        movementHistory.shift();
    }
}

/**
 * Computes the bearing of recent movement based on the movementHistory array.
 * Returns:
 *   - a bearing in degrees [0, 360) if we have enough motion
 *   - null if we don't have enough recent movement yet
 */
/**
 * Computes the bearing of recent movement based on the movementHistory array.
 * Returns:
 *   - a bearing in degrees [0, 360) if we have enough motion
 *   - null if we don't have enough recent movement yet
 */
function computeMovementBearingDegrees() {
    if (!movementHistory || movementHistory.length < 2) {
        return null;
    }

    const now = Date.now();

    // Keep only samples from the recent window
    movementHistory = movementHistory.filter(p => now - p.time <= MOVEMENT_HISTORY_MAX_AGE_MS);

    if (movementHistory.length < 2) {
        return null;
    }

    const first = movementHistory[0];
    const last = movementHistory[movementHistory.length - 1];

    // Distance moved in metres (use existing distanceMeters helper)
    const dist = distanceMeters(first.lat, first.lon, last.lat, last.lon);

    if (dist < MOVEMENT_MIN_DISTANCE_METERS) {
        // Too little movement to get a stable direction
        return null;
    }

    // Bearing of travel from first point in history to the most recent
    return initialBearingDegrees(first.lat, first.lon, last.lat, last.lon);
}
        
// --- END GEOGRAPHY HELPER FUNCTIONS ---


        // --- HELPER FUNCTIONS ---

// ======================================
// SHARED MODAL HELPERS
// ======================================
function openModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    modal.style.display = 'block';
}

function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    modal.style.display = 'none';
}

        
function openEditFindModal(findId) {
    const find = finds.find(f => f.id === findId);
    if (!find) {
        showMessage('Find not found.', 'error');
        return;
    }

    const modal = document.getElementById('edit-find-modal');
    const form  = document.getElementById('edit-find-form');
    if (!modal || !form) return;

    // Core fields
    form['findId'].value           = find.id;
    form['findDescription'].value  = find.description || '';
    form['findType'].value         = find.type || 'Unknown';
    form['findVDI'].value          = find.vdi || '';
    form['findDepth'].value        = find.depth || '';
    form['findCoords'].value       = find.coordinates || '';
    form['findAccuracy'].value     = find.accuracy || '';

    // Photo UI (mirroring Edit Target logic)
    const photoData      = find.targetPhotoData;
    const statusSpan     = document.getElementById('edit-find-photo-status');
    const previewWrapper = document.getElementById('edit-find-photo-preview-wrapper');
    const previewImg     = document.getElementById('edit-find-photo-preview');
    const hiddenField    = document.getElementById('edit-find-photo-data');

    if (photoData && typeof photoData === 'string' && photoData.length > 50) {
        if (hiddenField)    hiddenField.value = photoData;
        if (previewImg)     previewImg.src = photoData;
        if (previewWrapper) previewWrapper.classList.remove('hidden');
        if (statusSpan)     statusSpan.textContent =
            'Existing photo loaded. Tap "Take / Choose Photo" to replace.';
    } else {
        if (hiddenField)    hiddenField.value = '';
        if (previewImg)     previewImg.src = '';
        if (previewWrapper) previewWrapper.classList.add('hidden');
        if (statusSpan)     statusSpan.textContent = 'No photo captured yet.';
    }

    // Attach the submit handler in the same pattern as Targets / Profile
    form.removeEventListener('submit', handleEditFindSubmit);
    form.addEventListener('submit', handleEditFindSubmit);

    // Show the modal (same as Edit Target)
    openModal('edit-find-modal');
}


function closeEditFindModal() {
    closeModal('edit-find-modal');
}

function handleEditFindSubmit(event) {
    event.preventDefault();
    const form = event.target;

    const id = form['findId'].value;
    const find = finds.find(f => f.id === id);
    if (!find) {
        showMessage('Find not found.', 'error');
        closeEditFindModal();
        return;
    }

    const desc = form['findDescription'].value.trim();
    if (!desc) {
        showMessage('Description is required.', 'error');
        return;
    }

    // Core fields
    find.description = desc;
    find.type        = form['findType'].value || 'Unknown';
    find.vdi         = form['findVDI'].value.trim();
    find.depth       = form['findDepth'].value.trim();
    find.coordinates = form['findCoords'].value.trim();
    find.accuracy    = form['findAccuracy'].value.trim();

    // Photo data
    if (form['findPhotoData']) {
        find.targetPhotoData = form['findPhotoData'].value || '';
    }

    find.updatedAt = Date.now();

    saveFindsToLocalStorage();
    closeEditFindModal();
    showMessage('Find updated.', 'success');
    render();
}
        function deleteFind(findId) {
    const find = finds.find(f => f.id === findId);
    if (!find) {
        showMessage('Find not found.', 'error');
        return;
    }

    const ok = window.confirm(
        `Delete find "${find.description || 'this find'}"? This cannot be undone.`
    );
    if (!ok) return;

    finds = finds.filter(f => f.id !== findId);
    saveFindsToLocalStorage();
    showMessage('Find deleted.', 'success');
    render();
}


        /** Generates a simple unique ID. */
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2, 5);
        }

        /** Formats a timestamp into a readable date string. */
        function formatDate(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleDateString();
        }
/**
 * Takes a target + its parent survey and snapshots it into the permanent Finds library.
 * The Find is independent: if the survey/target are later deleted, this record remains.
 */
function createFindFromTarget(target, survey) {
    const find = {
        id: generateId(),
        createdAt: Date.now(),

        // Links back to original context (not required to still exist)
        surveyId: survey.id,
        surveyName: survey.name || 'Untitled survey',
        surveyDescription: survey.description || '',
        targetId: target.id,

        // Core fields
        description: target.description || 'Unnamed Find',
        vdi: target.vdi || '',
        depth: target.depth || '',
        type: target.type || 'Unknown',
        coordinates: target.coordinates || '',
        accuracy: target.accuracy || '',
        centerOnMap: !!target.centerOnMap,

        // Media
        targetPhotoData: target.targetPhotoData || '',

        // Metadata
        statusAtSave: target.status || '',
        user: target.user || userProfile.name || '',
        detector: target.detector || userProfile.detector || ''
    };

    finds.push(find);

    // Save finds separately (no scary warnings)
    saveFindsToLocalStorage();

    // Optional small vibration for mobile feedback (safe no-op on desktop)
    if (navigator.vibrate) {
        navigator.vibrate(40);
    }

    // Slight delay helps ensure UI is settled before message appears
    setTimeout(() => {
        showMessage(`Find saved: "${find.description}"`, 'success');
    }, 120);
}
        
        /** Saves the current surveys and profile data to Local Storage. */
function saveFindsToLocalStorage() {
    try {
        localStorage.setItem('geoFindFinds', JSON.stringify(finds));
    } catch (e) {
        console.error("Error saving Finds to Local Storage:", e);
        // No toast here – we don't want to confuse the user
    }
}

        
function saveSurveysToLocalStorage() {
    try {
        localStorage.setItem('geoFindSurveys', JSON.stringify(surveys));
        localStorage.setItem('geoFindProfile', JSON.stringify(userProfile));
        localStorage.setItem('geoFindUserId', userId);
    } catch (e) {
        console.error("Error saving to Local Storage:", e);
        showMessage("Error saving data locally.", 'error');
    }
}


        /** Loads data from Local Storage. Initializes if no data found. */
    function loadDataFromLocalStorage() {
    try {
        const storedSurveys = localStorage.getItem('geoFindSurveys');
        const storedFinds   = localStorage.getItem('geoFindFinds');   // <--- NEW
        const storedProfile = localStorage.getItem('geoFindProfile');
        const storedUserId  = localStorage.getItem('geoFindUserId');

                if (storedSurveys) {
                    surveys = JSON.parse(storedSurveys);
                } else {
                    // Initialize with sample data if nothing is found
                    surveys = [
                        {
                            id: generateId(),
                            name: "Sample Grid Survey 2025",
                            description: "Testing a 10x10 metre grid near the old oak tree.",
                            status: 'Open',
                            creationDate: Date.now(),
                            dateLastChanged: Date.now(),
                            targets: [
                                // Sample targets with valid coordinates and accuracy for mapping
                                { id: generateId(), description: "Small Copper Coin", vdi: "28", depth: "4in", type: "Coin", status: "Signal Detected", time: Date.now(), coordinates: "50.256800, -5.234500", accuracy: "5.5", user: userProfile.name, detector: userProfile.detector },
                                { id: generateId(), description: "Lead Button", vdi: "30", depth: "6in", type: "Relic", status: "Signal Detected", time: Date.now() - 100000, coordinates: "50.257000, -5.234100", accuracy: "2.1", user: userProfile.name, detector: userProfile.detector },
                                { id: generateId(), description: "Iron Spike", vdi: "8", depth: "12in", type: "Iron Junk", status: "Signal Ignored", time: Date.now() - 3600000, coordinates: "50.256700, -5.234800", accuracy: "10.0", user: userProfile.name, detector: userProfile.detector }
                            ]
                        }
                    ];
                }
        // Load Finds (can be empty even if surveys exist)
        if (storedFinds) {
            finds = JSON.parse(storedFinds);
        } else {
            finds = [];
        }

                if (storedProfile) {
                    // Update userProfile only if storedProfile exists and is valid
                    const tempProfile = JSON.parse(storedProfile);
                    if (tempProfile && tempProfile.name && tempProfile.detector) {
                         userProfile = tempProfile;
                    }
                } else {
                    // Re-initialize sample profile if needed
                    userProfile = { name: "Sample Dectorist", detector: "Minelab Equinox" };
                }

                if (storedUserId) {
                    userId = storedUserId;
                } else {
                    userId = generateId();
                }

                saveSurveysToLocalStorage(); // Ensure initial data and ID are saved
            } catch (e) {
                console.error("Error loading from Local Storage:", e);
                showMessage("Error loading data. Data may be reset.", 'error');
            }
        }

        /** Renders the current page content into the main container. */
        function render() {
            const appContent = document.getElementById('app-content');
            let contentHtml = '';

            // Update navigation button styles
            document.querySelectorAll('.nav-btn').forEach(btn => {
                if (btn.dataset.page === currentPage) {
                    btn.classList.add('text-primary', 'bg-gray-100');
                    btn.classList.remove('text-gray-500', 'hover:text-primary');
                } else {
                    btn.classList.remove('text-primary', 'bg-gray-100');
                    btn.classList.add('text-gray-500', 'hover:text-primary');
                }
            });

// In the render function...
        
        // Cleanup: Always clear the interval and GPS watch when rendering a new page content,
        // the Compass page will restart it if needed.
        if (autoRefreshIntervalId) {
            clearInterval(autoRefreshIntervalId);
            autoRefreshIntervalId = null;
            console.log("Auto-refresh stopped.");
        }
        // ADDED: Clear the live map GPS watch
        if (liveMapWatchId) {
            navigator.geolocation.clearWatch(liveMapWatchId);
            liveMapWatchId = null;
            bestLiveAccuracy = Infinity;
            smoothedUserCoords = null;
            console.log("Live Map GPS Watch stopped.");
        }

switch (currentPage) {
    case 'Home':
        contentHtml = renderHomePage();
        break;
    case 'Targets':
        contentHtml = renderTargetsPage();
        break;
    case 'Finds':                           // <--- NEW
        contentHtml = renderFindsPage();
        break;
    case 'Compass':
        contentHtml = renderCompassPage(false);
        break;
    case 'Settings':
        contentHtml = renderSettingsPage();
        break;
    default:
        contentHtml = `<div class="p-4 text-center">Page Not Found</div>`;
}
            appContent.innerHTML = contentHtml;
            // Re-attach event listeners specific to the rendered page
            attachPageEventListeners();
        }

        /** Attaches event listeners for dynamically rendered elements */
/** Attaches event listeners for dynamically rendered elements */
function attachPageEventListeners() {
    // Home Page (New Survey Button)
    const newSurveyBtn = document.getElementById('new-survey-btn');
    if (newSurveyBtn) {
        newSurveyBtn.addEventListener('click', showNewSurveyModal);
    }

    // Targets Page (Log New Target Button)
    const addTargetBtn = document.getElementById('add-target-btn');
    if (addTargetBtn) {
        addTargetBtn.addEventListener('click', showNewTargetModal);
    }

    // Settings Page (Export/Import Buttons)
    const exportBtn = document.getElementById('export-data-btn');
    if (exportBtn) {
        exportBtn.addEventListener('click', exportData);
    }
    const importBtn = document.getElementById('import-data-btn');
    if (importBtn) {
        importBtn.addEventListener('click', importData);
    }

    // Finds Page (search + filters)
    const findsSearchInput  = document.getElementById('finds-search-input');
    const findsTypeSelect   = document.getElementById('finds-type-select');
    const findsSurveySelect = document.getElementById('finds-survey-select');
    const clearFindsBtn     = document.getElementById('clear-finds-filters-btn');

    if (findsSearchInput || findsTypeSelect || findsSurveySelect || clearFindsBtn) {
        if (findsSearchInput) {
            findsSearchInput.addEventListener('input', (e) => {
                findsFilter.query = e.target.value || '';
                render();
            });
        }
        if (findsTypeSelect) {
            findsTypeSelect.addEventListener('change', (e) => {
                findsFilter.type = e.target.value || 'All';
                render();
            });
        }
        if (findsSurveySelect) {
            findsSurveySelect.addEventListener('change', (e) => {
                findsFilter.surveyId = e.target.value || 'All';
                render();
            });
        }
        if (clearFindsBtn) {
            clearFindsBtn.addEventListener('click', () => {
                findsFilter = { query: '', type: 'All', surveyId: 'All' };
                render();
            });
        }
    }

 
}
        // --- GPS GEOLOCATION FUNCTIONS ---
        
   /** Starts a high-accuracy GPS stream that updates the inputs live. */
/** * Starts a high-accuracy GPS stream that updates the target logging modal's
 * inputs only when a reading is more accurate than the current best.
 */
/** * Starts a high-accuracy GPS stream that updates the target logging modal's
 * inputs only when a reading is more accurate than the current best.
 */
function startTargetLocationWatch() {
    // 1. Get references to the HTML elements
    const coordsInput = document.getElementById('target-coords');
    const accuracyInput = document.getElementById('target-accuracy');
    
    // NOTE: The visible text span is now inside the p tag with the ID 'gps-accuracy-display'
    const accuracyDisplayP = document.getElementById('gps-accuracy-display');
    const accuracyValueSpan = accuracyDisplayP.querySelector('.font-semibold');
    
    const loadingIndicator = document.getElementById('gps-loading-indicator');
    
    // Local variable to track the best accuracy received so far
    let bestAccuracy = Infinity; 

    // 2. Reset UI state for a new acquisition process
    coordsInput.value = '';
    coordsInput.placeholder = 'Waiting for GPS lock...';
    coordsInput.disabled = true;
    accuracyInput.value = '';
    
    // Ensure only the loading indicator is visible initially, hide the accuracy display
    accuracyValueSpan.textContent = 'N/A';
    accuracyDisplayP.classList.add('hidden'); // Hide the visible P tag
    loadingIndicator.classList.remove('hidden'); // Show the loading indicator SPAN

    if (navigator.geolocation) {
        // 3. Start Watching (Stream)
        targetWatchId = navigator.geolocation.watchPosition(
            // Success Callback: Processes incoming positions
            (position) => {
                const accuracy = position.coords.accuracy;
                
                // --- CORE LOGIC: ONLY UPDATE IF THIS READING IS MORE ACCURATE ---
                if (accuracy < bestAccuracy) {
                    bestAccuracy = accuracy; // Update the best accuracy found
                    
                    const lat = position.coords.latitude.toFixed(6);
                    const lon = position.coords.longitude.toFixed(6);

                    // Update visible and hidden inputs with the better reading
                    coordsInput.value = `${lat}, ${lon}`;
                    coordsInput.placeholder = 'GPS Locked';
                    coordsInput.disabled = false; // Enable fields

                    accuracyInput.value = accuracy.toFixed(2);
                    accuracyValueSpan.textContent = `${accuracy.toFixed(1)} meters`;

                    // Update UI color based on the BEST accuracy
                    if(accuracy < 5) {
                        accuracyValueSpan.className = "font-semibold text-green-600"; // Good!
                    } else if (accuracy < 15) {
                        accuracyValueSpan.className = "font-semibold text-yellow-600"; // Okay
                    } else {
                        accuracyValueSpan.className = "font-semibold text-red-600"; // Poor
                    }
                    
                    console.log(`New Best Accuracy: ${accuracy.toFixed(1)}m`);
                } 
                // --- END CORE LOGIC ---
                
                // FINAL STEP: Hide loading and SHOW accuracy display
                loadingIndicator.classList.add('hidden');
                accuracyDisplayP.classList.remove('hidden'); 

            }, // Success callback ends here
            
            // Error Callback: Handles GPS failure
            (error) => {
                console.error('GPS Watch Error:', error);
                loadingIndicator.classList.add('hidden');
                accuracyDisplayP.classList.remove('hidden');
                accuracyValueSpan.textContent = 'Error';
                accuracyValueSpan.className = "font-semibold text-red-600";
                coordsInput.placeholder = 'GPS Error (Type Manually)';
                coordsInput.disabled = false;
                showMessage(`GPS Error: ${error.message}. Please input coordinates manually.`, 'error');
            },
            
            // Options Object
            {
                enableHighAccuracy: true, 
                timeout: 30000,           
                maximumAge: 0             
            }
        );
    } else {
        showMessage('Geolocation is not supported on this device.', 'error');
    }
}
        
        function stopTargetLocationWatch() {
    if (targetWatchId !== null) {
        navigator.geolocation.clearWatch(targetWatchId);
        targetWatchId = null;
        console.log("Target GPS Watch stopped.");
    }
}
        
// --- LIVE MAP GPS WATCH FUNCTIONS (New/Modified Logic) ---

        /** Starts a continuous, high-accuracy GPS stream that only updates the state when a reading is more accurate. 
         * Also starts the 5-second rendering interval.
         */
/** Starts a continuous, high-accuracy GPS stream that only updates the state when a reading is more accurate. 
 * Also starts the 5-second rendering interval.
 */
/** Starts a continuous, high-accuracy GPS stream for the live map. */
// --- LIVE MAP GPS WATCH FUNCTIONS (New/Modified Logic) ---

/** Starts a continuous, high-accuracy GPS stream for the live map
 *  and starts the auto-refresh interval to redraw the map.
 */
function startLiveMapLocationWatch() {
    if (!navigator.geolocation) {
        currentUserCoords = null;
        currentUserAccuracy = null;
        smoothedUserCoords = null;
        showMessage('Geolocation is not supported on this device.', 'error');
        return;
    }

    // Fresh run each time we arrive on the Compass page
    bestLiveAccuracy = Infinity;
    smoothedUserCoords = null;
    movementHistory = [];

    // Start / restart the GPS watch
    if (liveMapWatchId !== null) {
        navigator.geolocation.clearWatch(liveMapWatchId);
        liveMapWatchId = null;
    }

liveMapWatchId = navigator.geolocation.watchPosition(
        (position) => {
            const accuracy = position.coords.accuracy;

            // Raw latest reading
            currentUserCoords = {
                lat: position.coords.latitude,
                lon: position.coords.longitude
            };
            currentUserAccuracy = accuracy;

            // Update smoothed position used by the map
            updateSmoothedUserCoords(currentUserCoords.lat, currentUserCoords.lon);

            // Record this smoothed point into the movement history
            if (smoothedUserCoords) {
                recordMovementSample(smoothedUserCoords.lat, smoothedUserCoords.lon);
            }

            // Track best accuracy (for logging/info)
            if (accuracy < bestLiveAccuracy) {
                bestLiveAccuracy = accuracy;
            }

            // ... rest of your logging code stays the same ...

            console.log(
                `Live Map position (raw): ${currentUserCoords.lat.toFixed(6)}, ` +
                `${currentUserCoords.lon.toFixed(6)} (acc: ${accuracy.toFixed(1)}m, best: ${bestLiveAccuracy.toFixed(1)}m)`
            );

            if (smoothedUserCoords) {
                console.log(
                    `Live Map position (smoothed): ${smoothedUserCoords.lat.toFixed(6)}, ` +
                    `${smoothedUserCoords.lon.toFixed(6)}`
                );
            }
        },
        (error) => {
            currentUserCoords = null;
            currentUserAccuracy = null;
            smoothedUserCoords = null;
            console.error('Live Map GPS Watch Error:', error);
        },
        {
            enableHighAccuracy: true,
            maximumAge: 0
        }
    );

    // Start the auto-refresh interval (if not already running)
    if (autoRefreshIntervalId === null) {
        autoRefreshIntervalId = setInterval(() => {
            updateMapWithUserLocationAndRender();
        }, 3000); // 3 seconds
        console.log('Live Map GPS Watch and auto-refresh interval started.');
    }
}

/** Wrapper function to re-render Compass page for auto-refresh using the latest watched GPS data. */
function updateMapWithUserLocationAndRender() {
    // The GPS data is updated asynchronously by startLiveMapLocationWatch().
    // We just trigger the re-render here.
    const appContent = document.getElementById('app-content');

    // Only re-render if we are still on the Compass page
    if (currentPage === 'Compass') {
        appContent.innerHTML = renderCompassPage(true);
        attachPageEventListeners();
    }
}
        // --- MODAL & TOAST FUNCTIONS ---

        /** Shows a temporary notification toast. */
        function showMessage(message, type = 'info') {
            const toast = document.getElementById('message-toast');
            toast.textContent = message;

            let bgColor = 'bg-gray-700'; // Default info
            if (type === 'success') {
                bgColor = 'bg-secondary';
            } else if (type === 'error') {
                bgColor = 'bg-red-600';
            } else if (type === 'warning') {
                bgColor = 'bg-yellow-500';
            }

            toast.className = `fixed bottom-4 right-4 z-50 p-4 rounded-lg text-white shadow-xl transition-opacity duration-300 opacity-100 ${bgColor}`;

            setTimeout(() => {
                toast.classList.remove('opacity-100');
                toast.classList.add('opacity-0');
            }, 3000);
        }

        /** Shows the generic confirmation modal. */
        function showConfirmationModal(title, message, onConfirmCallback) {
            const modal = document.getElementById('confirmation-modal');
            document.getElementById('confirm-title').innerHTML = title;
            document.getElementById('confirm-message').innerHTML = message;
            
            const yesBtn = document.getElementById('confirm-yes-btn');
            const noBtn = document.getElementById('confirm-no-btn');

            const handleYes = () => {
                onConfirmCallback();
                closeConfirmationModal();
                yesBtn.removeEventListener('click', handleYes);
            };

            yesBtn.onclick = handleYes;
            noBtn.onclick = closeConfirmationModal;
            
            modal.style.display = 'block';
        }

        /** Closes the generic confirmation modal. */
        function closeConfirmationModal() {
            document.getElementById('confirmation-modal').style.display = 'none';
        }

        /** Shows the New Survey Modal and attaches the submit listener. */
        function showNewSurveyModal() {
            // Reset the form whenever the modal is opened
            document.getElementById('new-survey-form').reset();
            document.getElementById('new-survey-modal').style.display = 'block';

            // Ensure the submit listener is attached only once
            const form = document.getElementById('new-survey-form');
            // Remove previous listener to prevent multiple submissions
            form.removeEventListener('submit', handleNewSurveySubmit); 
            form.addEventListener('submit', handleNewSurveySubmit); 
        }

        /** Closes the New Survey Modal. */
        function closeNewSurveyModal() {
            document.getElementById('new-survey-modal').style.display = 'none';
        }

        /** Handles the submission of the New Survey form. */
        function handleNewSurveySubmit(event) {
            event.preventDefault();

            const form = event.target;
            const name = form['surveyName'].value.trim();
            const description = form['surveyDescription'].value.trim() || 'No description provided.';
            const now = Date.now();

            if (!name) {
                showMessage('Survey Name is required.', 'error');
                return;
            }

            // 1. Close any currently open survey
            surveys.forEach(s => {
                if (s.status === 'Open') {
                    s.status = 'Active';
                    s.dateLastChanged = now;
                }
            });

            // 2. Create the new survey object
            const newSurvey = {
                id: generateId(),
                name: name,
                description: description,
                status: 'Open', // Automatically opens the new survey
                creationDate: now,
                dateLastChanged: now,
                targets: []
            };

            // 3. Add the new survey to the start of the list
            surveys.unshift(newSurvey);

            // 4. Save and re-render
            saveSurveysToLocalStorage();
            closeNewSurveyModal();
            showMessage(`New Survey '${name}' created and is now OPEN!`, 'success');
            render();
        }

        /** Shows the New Target Modal. */
        function showNewTargetModal() {
            const openSurvey = surveys.find(s => s.status === 'Open');
            if (!openSurvey) {
                return showMessage('Cannot log target. Please open a survey first on the Home page.', 'warning');
            }

            // 1. Set survey name in the modal header
            document.getElementById('current-target-survey-name').textContent = openSurvey.name;
            
            // 2. Reset the form
            document.getElementById('new-target-form').reset();
            
            // 3. Request GPS location
            startTargetLocationWatch();
            
            // 4. Display modal
            document.getElementById('new-target-modal').style.display = 'block';

            // 5. Attach the submit listener
            const form = document.getElementById('new-target-form');
            form.removeEventListener('submit', handleNewTargetSubmit); 
            form.addEventListener('submit', handleNewTargetSubmit); 
        }

        /** Closes the New Target Modal. */
        function closeNewTargetModal() {
            stopTargetLocationWatch();
            document.getElementById('new-target-modal').style.display = 'none';
        }

        /** Handles the submission of the New Target form. */

  // --- TARGET PHOTO HELPERS ---

// --- SHARED PHOTO HELPERS ---

/**
 * Generic helper to trigger a hidden file input by ID.
 * Clears any previous selection before opening.
 */
function triggerPhotoInput(inputId) {
    const fileInput = document.getElementById(inputId);
    if (!fileInput) return;

    fileInput.value = '';   // clear previous selection
    fileInput.click();      // open camera / gallery
}

/**
 * Generic helper to handle a selected photo and update:
 * - status text
 * - preview wrapper + image
 * - hidden data field
 */
function handlePhotoSelected(event, {
    statusId,
    wrapperId,
    imgId,
    hiddenId
}) {
    const fileInput = event.target;
    const file = fileInput.files && fileInput.files[0];

    const statusSpan     = statusId   ? document.getElementById(statusId)   : null;
    const previewWrapper = wrapperId  ? document.getElementById(wrapperId)  : null;
    const previewImg     = imgId      ? document.getElementById(imgId)      : null;
    const hiddenField    = hiddenId   ? document.getElementById(hiddenId)   : null;

    if (!file) {
        if (statusSpan)     statusSpan.textContent = 'No photo captured yet.';
        if (previewWrapper) previewWrapper.classList.add('hidden');
        if (hiddenField)    hiddenField.value = '';
        return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
        const dataUrl = e.target.result;
        if (hiddenField)    hiddenField.value = dataUrl;
        if (statusSpan)     statusSpan.textContent = 'Photo captured.';
        if (previewImg)     previewImg.src = dataUrl;
        if (previewWrapper) previewWrapper.classList.remove('hidden');
    };
    reader.onerror = () => {
        console.error('Error reading photo file:', reader.error);
        showMessage('Could not read the photo file.', 'error');
        if (statusSpan)     statusSpan.textContent = 'Error capturing photo.';
        if (previewWrapper) previewWrapper.classList.add('hidden');
        if (hiddenField)    hiddenField.value = '';
    };
    reader.readAsDataURL(file);
}

// --- TARGET PHOTO HELPERS (new target form) ---

function triggerTargetPhotoInput() {
    triggerPhotoInput('target-photo-input');
}

function handleTargetPhotoSelected(event) {
    handlePhotoSelected(event, {
        statusId:  'target-photo-status',
        wrapperId: 'target-photo-preview-wrapper',
        imgId:     'target-photo-preview',
        hiddenId:  'target-photo-data'
    });
}

// --- EDIT TARGET PHOTO HELPERS ---

function triggerEditTargetPhotoInput() {
    triggerPhotoInput('edit-target-photo-input');
}

function handleEditTargetPhotoSelected(event) {
    handlePhotoSelected(event, {
        statusId:  'edit-target-photo-status',
        wrapperId: 'edit-target-photo-preview-wrapper',
        imgId:     'edit-target-photo-preview',
        hiddenId:  'edit-target-photo-data'
    });
}

// --- EDIT FIND PHOTO HELPERS ---

function triggerEditFindPhotoInput() {
    triggerPhotoInput('edit-find-photo-input');
}

function handleEditFindPhotoSelected(event) {
    handlePhotoSelected(event, {
        statusId:  'edit-find-photo-status',
        wrapperId: 'edit-find-photo-preview-wrapper',
        imgId:     'edit-find-photo-preview',
        hiddenId:  'edit-find-photo-data'
    });
}
        
function showEditTargetModal(targetId, surveyId) {
    const survey = surveys.find(s => s.id === surveyId);
    if (!survey) return showMessage('Error: Survey not found.', 'error');
    
    const target = survey.targets.find(t => t.id === targetId);
    if (!target) return showMessage('Error: Target not found.', 'error');

    // 1. Populate the form
    document.getElementById('edit-target-id').value = target.id;
    document.getElementById('edit-survey-id').value = survey.id;
    document.getElementById('current-edit-survey-name').textContent = survey.name;
    
    document.getElementById('edit-target-description').value = target.description;
    document.getElementById('edit-target-vdi').value = target.vdi === 'N/A' ? '' : target.vdi;
    document.getElementById('edit-target-depth').value = target.depth === 'Unknown' ? '' : target.depth;
    document.getElementById('edit-target-type').value = target.type;
    document.getElementById('edit-target-coords').value = target.coordinates === 'No GPS logged' ? '' : target.coordinates;
    
    // NEW: Populate accuracy field
    document.getElementById('edit-target-accuracy').value = target.accuracy === 'N/A' ? '' : target.accuracy;

    // NEW: Populate Centre on Map radio buttons (Robust Check)
    const shouldCenterOnMap = target.centerOnMap === true;  
    
    const yesRadio = document.getElementById('edit-target-center-yes');
    const noRadio = document.getElementById('edit-target-center-no');
    
    // Check if the elements exist before trying to set properties
    if (yesRadio && noRadio) {
        yesRadio.checked = shouldCenterOnMap;
        noRadio.checked = !shouldCenterOnMap;
    }

    // --- REVISED PHOTO LOGIC ADDITION ---
    const photoData = target.targetPhotoData;
    const statusSpan = document.getElementById('edit-target-photo-status');
    const previewWrapper = document.getElementById('edit-target-photo-preview-wrapper');
    const previewImg = document.getElementById('edit-target-photo-preview');
    const hiddenField = document.getElementById('edit-target-photo-data');

    // Load existing photo data if it's a valid, non-empty string (Base64 data is usually > 50 chars)
    if (photoData && typeof photoData === 'string' && photoData.length > 50) {
        if (hiddenField) hiddenField.value = photoData;
        if (previewImg) previewImg.src = photoData;
        if (previewWrapper) previewWrapper.classList.remove('hidden');
        if (statusSpan) statusSpan.textContent = 'Existing photo loaded. Click "Take / Choose Photo" to replace.';
    } else {
        // Explicitly hide preview and clear fields if no valid photo data exists
        if (hiddenField) hiddenField.value = '';
        if (previewImg) previewImg.src = ''; 
        if (previewWrapper) previewWrapper.classList.add('hidden');
        if (statusSpan) statusSpan.textContent = 'No photo captured yet.';
    }
    // --- END REVISED PHOTO LOGIC ADDITION ---

   // 2. Display the modal
    const modal = document.getElementById('edit-target-modal');
    modal.style.display = 'block';

    // 3. Attach the submit listener
    const form = document.getElementById('edit-target-form');
    // REMOVE any previous listener to prevent multiple submissions
    // Attach submit handler
    form.removeEventListener('submit', handleEditTargetSubmit);
    form.addEventListener('submit', handleEditTargetSubmit);

    // Show the modal
    openModal('edit-target-modal');
}

        
    // Use FileReader to convert the file to a Base64 data URL
    const reader = new FileReader();
    reader.onload = (e) => {
        const dataUrl = e.target.result;
        if (hiddenField) hiddenField.value = dataUrl;
        if (statusSpan) statusSpan.textContent = 'Photo captured.';
        if (previewImg) previewImg.src = dataUrl;
        if (previewWrapper) previewWrapper.classList.remove('hidden');
    };
    reader.onerror = () => {
        console.error('Error reading photo file:', reader.error);
        showMessage('Could not read the photo file.', 'error');
        if (statusSpan) statusSpan.textContent = 'Error capturing photo.';
        if (previewWrapper) previewWrapper.classList.add('hidden');
        if (hiddenField) hiddenField.value = '';
    };
    reader.readAsDataURL(file);
}

function closeEditTargetModal() {
    closeModal('edit-target-modal');
}
        /** Handles the submission of the Edit Target form. */
/** Handles the submission of the Edit Target form. */
/** Handles the submission of the Edit Target form. */
function handleEditTargetSubmit(event) {
    event.preventDefault();

    const form = event.target;

    // 🔹 Use the actual form field *names* from the HTML
    const targetId = form['targetId']?.value;
    const surveyId = form['surveyId']?.value;

    if (!targetId || !surveyId) {
        showMessage('Error: Target or Survey not found (missing IDs).', 'error');
        return;
    }

    const newDescription = form['targetDescription'].value.trim();
    if (!newDescription) {
        showMessage('Description / Find Name is required.', 'error');
        return;
    }

    const newVDI      = form['targetVDI'].value.trim() || 'N/A';
    const newDepth    = form['targetDepth'].value.trim() || 'Unknown';
    const newType     = form['targetType'].value;
    const newCoords   = form['targetCoords'].value.trim() || 'No GPS logged';
    const newAccuracy = form['targetAccuracy'].value.trim() || 'N/A';

    // Radio group is already called editTargetCenterOnMap in the HTML
    const centerOnMapValue = form['editTargetCenterOnMap'].value;
    const centerOnMap      = centerOnMapValue === 'Yes';

    // Hidden photo field is called targetPhotoData
    const newPhotoData = form['targetPhotoData']?.value || '';

    // Look up survey + target
    const survey = surveys.find(s => s.id === surveyId);
    if (!survey) {
        showMessage('Error: Survey not found.', 'error');
        return;
    }

    const target = survey.targets.find(t => t.id === targetId);
    if (!target) {
        showMessage('Error: Target not found.', 'error');
        return;
    }

    // Update core fields
    target.description = newDescription;
    target.vdi         = newVDI;
    target.depth       = newDepth;
    target.type        = newType;
    target.coordinates = newCoords;
    target.accuracy    = newAccuracy;

    // Update photo data (can be empty string if user cleared it)
    target.targetPhotoData = newPhotoData;

    // Enforce single "Centre on map" within this survey
    if (centerOnMap) {
        survey.targets.forEach(t => {
            if (t.id !== targetId) {
                t.centerOnMap = false;
            }
        });
    }
    target.centerOnMap = centerOnMap;

    survey.dateLastChanged = Date.now();
    saveSurveysToLocalStorage();
    closeEditTargetModal();
    showMessage(`Target ${target.description} updated successfully.`, 'success');
    render();
}

/** Handles the submission (save) of the New Target form. */
function handleNewTargetSubmit(event) {
    event.preventDefault();
    const form = document.getElementById('new-target-form');
    
    const newDescription = form['targetDescription'].value.trim();
    const newVDI = form['targetVDI'].value.trim() || 'N/A';
    const newDepth = form['targetDepth'].value.trim() || 'Unknown';
    const newType = form['targetType'].value;
    const newCoords = form['targetCoords'].value.trim() || 'No GPS logged';
    const newAccuracy = form['targetAccuracy'].value.trim() || 'N/A';
    const centerOnMapValue = form['targetCenterOnMap'].value;
    const centerOnMap = centerOnMapValue === 'Yes';

    // *** CRITICAL ADDITION 1: GET PHOTO DATA FROM HIDDEN INPUT ***
    const newPhotoData = form['targetPhotoData'].value || '';
    // *************************************************************
    
    if (!newDescription) {
        showMessage('Description / Find Name is required.', 'error');
        return;
    }

    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        return showMessage('Error: Open survey not found.', 'error');
    }

    const newTarget = {
        id: generateId(),
        description: newDescription,
        vdi: newVDI,
        depth: newDepth,
        type: newType,
        status: "Hole Dug", // Default initial status
        time: Date.now(),
        coordinates: newCoords,
        accuracy: newAccuracy,
        user: userProfile.name,
        detector: userProfile.detector,
        centerOnMap: centerOnMap,
        
        // *** CRITICAL ADDITION 2: SAVE PHOTO DATA TO THE NEW TARGET ***
        targetPhotoData: newPhotoData 
        // *************************************************************
    };

    openSurvey.targets.unshift(newTarget);
    openSurvey.dateLastChanged = Date.now();

    saveSurveysToLocalStorage();
    closeNewTargetModal();
    showMessage(`New Target (${newDescription}) logged successfully!`, 'success');
    render();
}            
        /** Shows the Edit Profile Modal and loads current data. */
        function showEditProfileModal() {
            const modal = document.getElementById('edit-profile-modal');
            // Pre-fill the form with current profile data
            document.getElementById('profile-name').value = userProfile.name;
            document.getElementById('profile-detector').value = userProfile.detector;
            modal.style.display = 'block';

            // Attach the submit listener
            const form = document.getElementById('edit-profile-form');
            form.removeEventListener('submit', handleEditProfileSubmit); 
            form.addEventListener('submit', handleEditProfileSubmit); 
            showMessage("Edit Profile modal opened. Please enter your name and detector and click 'Save Changes'.", 'info');
        }

        /** Closes the Edit Profile Modal. */
        function closeEditProfileModal() {
            document.getElementById('edit-profile-modal').style.display = 'none';
        }

        /** Handles the submission of the Edit Profile form. */
        function handleEditProfileSubmit(event) {
            event.preventDefault();

            const form = event.target;
            const newName = form['profileName'].value.trim();
            const newDetector = form['profileDetector'].value.trim();

            if (!newName || !newDetector) {
                showMessage('Both Name and Detector are required.', 'error');
                return;
            }

            // Update global state
            userProfile.name = newName;
            userProfile.detector = newDetector;

            // Update user/detector in existing targets 
            surveys.forEach(survey => {
                survey.targets.forEach(target => {
                    if (target.user === userProfile.name) {
                        target.user = newName;
                    }
                    if (target.detector === userProfile.detector) {
                        target.detector = newDetector;
                    }
                });
            });


            // Save and re-render
            saveSurveysToLocalStorage();
            closeEditProfileModal();
            showMessage(`Profile updated to "${newName}" using "${newDetector}" successfully!`, 'success');
            // Re-render the current page (Settings) to reflect the new profile data
            render();
        }

        // --- SURVEY & TARGET LOGIC (Action Handlers) ---

        /** Handles actions like 'open', 'close', 'archive', 'restore', 'delete'. */
        function handleSurveyAction(button) {
            const id = button.dataset.id;
            const action = button.dataset.action;
            const name = button.dataset.name;
            const survey = surveys.find(s => s.id === id);
            if (!survey) return;

            const executeAction = () => {
                const now = Date.now();
                switch (action) {
                    case 'open':
                        // Close any currently open survey first
                        surveys.forEach(s => {
                            if (s.status === 'Open') {
                                s.status = 'Active';
                                s.dateLastChanged = now;
                            }
                        });
                        survey.status = 'Open';
                        showMessage(`Survey '${name}' is now OPEN.`, 'success');
                        break;
                    case 'close':
                        survey.status = 'Active';
                        showMessage(`Survey '${name}' is now CLOSED (Active).`, 'info');
                        break;
                    case 'archive':
                        survey.status = 'Archived';
                        showMessage(`Survey '${name}' has been Archived.`, 'info');
                        break;
                    case 'restore':
                        survey.status = 'Active';
                        showMessage(`Survey '${name}' Restored to Active.`, 'success');
                        break;
                   case 'delete':
                        surveys = surveys.filter(s => s.id !== id);
                        showMessage(`Survey '${name}' permanently deleted.`, 'error');
                        break;

                }
                survey.dateLastChanged = now;
                saveSurveysToLocalStorage();
                render();
            };

            // Use confirmation modal for irreversible or significant actions
            if (action === 'delete') {
                showConfirmationModal(
                    `Confirm Delete: ${name}`,
                    `Are you sure you want to permanently delete the survey **${name}** and all its targets? This action cannot be undone.`,
                    executeAction
                );
            } else if (action === 'archive') {
                showConfirmationModal(
                    `Confirm Archive: ${name}`,
                    `Are you sure you want to Archive the survey **${name}**? You can restore it later.`,
                    executeAction
                );
            } else {
                executeAction();
            }
        }

        /** Handles actions on individual targets. */
function handleMapTargetClick(event, targetId) {
    // Don’t let this click bubble up to the map container,
    // so it does NOT trigger toggleMapFullscreen().
    event.stopPropagation();

    if (!targetId) {
        console.warn('Map target click without a valid targetId');
        return;
    }

    // Save the selected target ID for navigation
    navigationTargetId = targetId;
    console.log('Navigation target selected from map:', navigationTargetId);

    // Give the user some feedback
    showMessage('Navigation target selected on map.', 'info');

    // If we're on the Compass page, re-render it so the panel updates
    if (currentPage === 'Compass') {
        const appContent = document.getElementById('app-content');
        appContent.innerHTML = renderCompassPage(true);
        attachPageEventListeners();

    }
}

            function clearNavigationTarget() {
    navigationTargetId = null;
    showMessage('Navigation target cleared.', 'info');

    // If we are on the Compass page, re-render so the panel updates
    if (currentPage === 'Compass') {
        const appContent = document.getElementById('app-content');
        appContent.innerHTML = renderCompassPage(true);
        attachPageEventListeners();
    }
}


        function handleTargetAction(element) {
            const action = element.dataset.action;
            const targetId = element.dataset.id;
            const surveyId = element.dataset.surveyId;
            const survey = surveys.find(s => s.id === surveyId);
            if (!survey) return;
            const target = survey.targets.find(t => t.id === targetId);
            if (!target) return;

            if (action === 'edit') {
                // Special case: open the edit modal
                showEditTargetModal(targetId, surveyId);
                return;
            }

            const executeAction = () => {
                        switch (action) {
            case 'setStatus':
                const newStatus = element.dataset.status;
                target.status = newStatus;
                showMessage(`Target status updated to: ${newStatus}`, 'success');
                break;

            case 'saveFind':   // <--- NEW
                createFindFromTarget(target, survey);
                // We DO NOT change the target or survey status here
                break;

            case 'delete':
                survey.targets = survey.targets.filter(t => t.id !== targetId);
                showMessage(`Target deleted.`, 'error');
                break;
        }
                survey.dateLastChanged = Date.now();
                saveSurveysToLocalStorage();
                render();
            };

            if (action === 'delete') {
                showConfirmationModal(
                    `Confirm Delete Target: ${target.description}`,
                    `Are you sure you want to permanently delete this target?`,
                    executeAction
                );
            } else {
                executeAction();
            }
        }

        // --- PAGE RENDER FUNCTIONS ---

function renderHomePage() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    const activeSurveys = surveys.filter(s => s.status === 'Active');
    const archivedSurveys = surveys.filter(s => s.status === 'Archived');

    const renderSurveyList = (list) => {
        if (list.length === 0) {
            return `<p class="text-gray-500 italic p-4">No surveys in this section.</p>`;
        }
        // Pass the openSurvey ID to highlight the currently open survey card in the list
        return list.map(s => renderSurveyCard(s, s.id === (openSurvey ? openSurvey.id : null))).join('');
    };

    // CRITICAL FIX: The template literal must start on the same line as 'return'
    return `<div class="p-4">
        <h2 class="text-3xl font-bold text-primary mb-6">Survey Dashboard</h2>

        <div class="bg-white p-4 rounded-xl shadow-lg mb-6 border-l-4 border-yellow-500">
            <h3 class="text-xl font-bold text-yellow-700 mb-2">
                ${openSurvey ? openSurvey.name : 'No Open Survey'}
            </h3>
            ${openSurvey ? 
                `<p class="text-gray-700">Open since: ${formatDate(openSurvey.creationDate)} (${openSurvey.targets.length} targets logged)</p>
                 ${renderSurveyCard(openSurvey, true)}` 
                : 
                '<p class="text-gray-600">You must open or create a survey to log new targets.</p>'
            }
        </div>

        <button id="new-survey-btn" class="w-full text-center text-white font-bold py-3 px-4 rounded-lg shadow-md hover:opacity-90 transition duration-150 mb-6" style="background-color: rgb(var(--color-secondary));">
            <i class="fas fa-plus-circle mr-2"></i> Create New Survey
        </button>

        <h3 class="text-2xl font-bold text-gray-700 mb-3">Active/Closed Surveys (${activeSurveys.length})</h3>
        <div id="active-surveys-list" class="space-y-4 mb-8">
            ${renderSurveyList(activeSurveys)}
        </div>

        <h3 class="text-2xl font-bold text-gray-700 mb-3">Archived Surveys (${archivedSurveys.length})</h3>
        <div id="archived-surveys-list" class="space-y-4">
            ${renderSurveyList(archivedSurveys)}
        </div>
    </div>`; // Note the closing backtick here
}        /** Renders a single survey card with action buttons based on status. */
        function renderSurveyCard(survey, isOpen = false) {
            let actions = '';
            let statusBadge = '';
            // Get the secondary color variable for inline styles
            const secondaryColor = 'rgb(var(--color-secondary))';

            switch (survey.status) {
                case 'Open':
                    statusBadge = `<span class="bg-green-100 text-green-800 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full">OPEN</span>`;
                    // 'Close' button is yellow
                    actions = `
                        <button class="survey-action-btn bg-yellow-500 hover:bg-yellow-600 p-2 text-black text-sm font-semibold rounded-md shadow-sm" onclick="handleSurveyAction(this)" data-id="${survey.id}" data-action="close" data-name="${survey.name}">Close</button>
                        <button class="survey-action-btn bg-red-500 hover:bg-red-600 p-2 text-white text-sm font-semibold rounded-md shadow-sm" onclick="handleSurveyAction(this)" data-id="${survey.id}" data-action="archive" data-name="${survey.name}">Archive</button>
                    `;
                    break;
                case 'Active': // Active but Closed
                    statusBadge = `<span class="bg-blue-100 text-blue-800 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full">ACTIVE</span>`;
                    // 'Open' button uses the secondary (green) color via inline style
                    actions = `
                        <button class="survey-action-btn p-2 text-white text-sm font-semibold rounded-md shadow-sm hover:opacity-90" onclick="handleSurveyAction(this)" data-id="${survey.id}" data-action="open" data-name="${survey.name}" style="background-color: ${secondaryColor};">Open</button>
                        <button class="survey-action-btn bg-gray-500 hover:bg-gray-600 p-2 text-white text-sm font-semibold rounded-md shadow-sm" onclick="handleSurveyAction(this)" data-id="${survey.id}" data-action="archive" data-name="${survey.name}">Archive</button>
                        <button class="survey-action-btn bg-red-500 hover:bg-red-600 p-2 text-white text-sm font-semibold rounded-md shadow-sm" onclick="handleSurveyAction(this)" data-id="${survey.id}" data-action="delete" data-name="${survey.name}">Delete</button>
                    `;
                    break;
                case 'Archived':
                    statusBadge = `<span class="bg-gray-100 text-gray-800 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full">ARCHIVED</span>`;
                    actions = `
                        <button class="survey-action-btn bg-blue-500 hover:bg-blue-600 p-2 text-white text-sm font-semibold rounded-md shadow-sm" onclick="handleSurveyAction(this)" data-id="${survey.id}" data-action="restore" data-name="${survey.name}">Restore</button>
                        <button class="survey-action-btn bg-red-500 hover:bg-red-600 p-2 text-white text-sm font-semibold rounded-md shadow-sm" onclick="handleSurveyAction(this)" data-id="${survey.id}" data-action="delete" data-name="${survey.name}">Delete</button>
                    `;
                    break;
            }

            return `
                <div class="bg-white p-4 rounded-xl shadow-lg border-l-4 ${isOpen ? 'border-yellow-500' : 'border-primary'}">
                    <div class="flex justify-between items-start mb-2">
                        <h4 class="text-lg font-bold text-gray-800">${statusBadge}${survey.name}</h4>
                        <div class="flex space-x-2">
                            ${actions}
                        </div>
                    </div>
                    <p class="text-sm text-gray-600 mb-2">${survey.description}</p>
                    <div class="flex justify-between text-xs text-gray-400 border-t border-gray-100 pt-2 mt-2">
                        <span>Created: ${formatDate(survey.creationDate)}</span>
                        <span>Targets: ${survey.targets.length}</span>
                        <span>Last Change: ${formatDate(survey.dateLastChanged)}</span>
                    </div>
                </div>
            `;
        }

        /** Renders the content for the Targets page. */
        function renderTargetsPage() {
            const openSurvey = surveys.find(s => s.status === 'Open');

            if (!openSurvey) {
                return `
                    <div class="p-4">
                        <h2 class="text-3xl font-bold text-primary mb-6">Survey Targets</h2>
                        <div class="bg-white p-6 rounded-xl shadow-lg border-l-4 border-red-500">
                            <h3 class="text-xl font-bold text-red-600 mb-3">No Open Survey</h3>
                            <p class="text-gray-700">Please open a survey on the **Home** page to view or log targets.</p>
                        </div>
                    </div>
                `;
            }

            const targets = openSurvey.targets;

            return `
                <div class="p-4">
                    <h2 class="text-3xl font-bold text-primary mb-6">Targets: ${openSurvey.name}</h2>
                    
                    <button id="add-target-btn" class="w-full text-center text-white font-bold py-3 px-4 rounded-lg shadow-md hover:opacity-90 transition duration-150 mb-6" style="background-color: rgb(var(--color-secondary));">
                        <i class="fas fa-crosshairs mr-2"></i> Log New Target
                    </button>

                    <h3 class="text-2xl font-bold text-gray-700 mb-3">Target Log (${targets.length})</h3>
                    <div id="targets-list" class="space-y-4">
                        ${targets.length === 0 ? 
                            '<p class="text-gray-500 italic p-4 bg-white rounded-xl shadow-lg">No targets logged in this survey yet.</p>' : 
                            targets.map(t => renderTargetCard(t, openSurvey.id)).join('')}
                    </div>
                </div>
            `;
        }

function renderFindsPage() {
    const hasFinds = finds && finds.length > 0;

    // Build distinct Type options
    const typeSet = new Set();
    finds.forEach(f => {
        if (f.type) typeSet.add(f.type);
    });
    const typeOptions = Array.from(typeSet).sort();

    // Build distinct Survey options (by ID)
    const surveyMap = new Map();
    finds.forEach(f => {
        const id = f.surveyId || 'unknown';
        const name = f.surveyName || 'Unknown survey';
        if (!surveyMap.has(id)) {
            surveyMap.set(id, name);
        }
    });
    const surveyOptions = Array.from(surveyMap.entries())
        .map(([id, name]) => ({ id, name }))
        .sort((a, b) => a.name.localeCompare(b.name));

    // Apply filters
    const filteredFinds = finds.filter(f => {
        // Text search
        if (findsFilter.query) {
            const q = findsFilter.query.toLowerCase();
            const haystack = [
                f.description,
                f.vdi,
                f.depth,
                f.type,
                f.surveyName,
                f.surveyDescription
            ].join(' ').toLowerCase();
            if (!haystack.includes(q)) return false;
        }

        // Type filter
        if (findsFilter.type !== 'All') {
            const t = f.type || 'Unknown';
            if (t !== findsFilter.type) return false;
        }

        // Survey filter
        if (findsFilter.surveyId !== 'All') {
            if ((f.surveyId || 'unknown') !== findsFilter.surveyId) return false;
        }

        return true;
    });

const cardsHtml = filteredFinds.map(find => {
    const dateText = find.createdAt ? formatDate(find.createdAt) : '';
    const typeLabel = find.type || 'Unknown';

    // Use whichever photo field is present on the Find
    const photoSrc = find.targetPhotoData || find.photoData || '';

    const photoHtml = photoSrc
        ? `
            <div class="mt-3">
                <img
                    src="${photoSrc}"
                    alt="Find photo"
                    class="w-full max-h-48 object-cover rounded-lg border border-gray-200"
                />
            </div>
          `
        : '';

           return `
            <div class="bg-white rounded-xl shadow-md p-4 mb-4 border border-gray-100">
                <div class="flex items-start justify-between">
                    <div>
                        <h3 class="text-lg font-bold text-primary">
                            ${find.description || 'Unnamed Find'}
                        </h3>
                        <p class="text-xs text-gray-500 mt-1">
                            ${find.surveyName || 'Unknown survey'}
                        </p>
                    </div>
                    <span class="inline-flex items-center px-2 py-1 text-xs font-semibold rounded-full bg-gray-100 text-gray-800">
                        ${typeLabel}
                    </span>
                </div>

                <div class="mt-3 grid grid-cols-2 gap-2 text-xs text-gray-700">
                    <div><span class="font-semibold">VDI:</span> ${find.vdi || '—'}</div>
                    <div><span class="font-semibold">Depth:</span> ${find.depth || '—'}</div>
                    <div><span class="font-semibold">Date:</span> ${dateText || '—'}</div>
                    <div><span class="font-semibold">Detector:</span> ${find.detector || '—'}</div>
                    <div class="col-span-2">
                        <span class="font-semibold">Coords:</span>
                        <span class="break-all">${find.coordinates || '—'}</span>
                    </div>
                </div>
                 ${photoHtml}
                <div class="mt-3 flex justify-end gap-2 text-xs">
                    <button
                        type="button"
                        class="px-3 py-1 rounded-md border border-gray-300 text-gray-700 hover:bg-gray-100"
                        onclick="openEditFindModal('${find.id}')">
                        Edit
                    </button>
                    <button
                        type="button"
                        class="px-3 py-1 rounded-md border border-red-500 text-red-600 hover:bg-red-50"
                        onclick="deleteFind('${find.id}')">
                        Delete
                    </button>
                </div>

               
            </div>
        `;

    }).join('');

    return `
        <div class="p-4">
            <h2 class="text-3xl font-bold text-primary mb-4">Finds Library</h2>
            <p class="text-gray-600 mb-4 text-sm">
                Every time you promote a target to a <strong>Find</strong>, it appears here and
                stays safe even if you delete the original survey or target.
            </p>

            <form id="finds-search-form"
                  class="bg-white rounded-xl shadow-md p-3 mb-4 grid grid-cols-1 gap-3">
                <div>
                    <label class="block text-xs font-semibold text-gray-600 mb-1">Search</label>
                    <input
                        type="text"
                        id="finds-search-input"
                        class="w-full border border-gray-300 rounded-md px-2 py-1 text-sm focus:ring-primary focus:border-primary"
                        placeholder="Find name, survey, VDI, depth…"
                        value="${findsFilter.query || ''}"
                    />
                </div>
                <div class="grid grid-cols-2 gap-3">
                    <div>
                        <label class="block text-xs font-semibold text-gray-600 mb-1">Type</label>
                        <select id="finds-type-select"
                                class="w-full border border-gray-300 rounded-md px-2 py-1 text-sm">
                            <option value="All"${findsFilter.type === 'All' ? ' selected' : ''}>All types</option>
                            ${typeOptions.map(t => `
                                <option value="${t}"${findsFilter.type === t ? ' selected' : ''}>${t}</option>
                            `).join('')}
                        </select>
                    </div>
                    <div>
                        <label class="block text-xs font-semibold text-gray-600 mb-1">Survey</label>
                        <select id="finds-survey-select"
                                class="w-full border border-gray-300 rounded-md px-2 py-1 text-sm">
                            <option value="All"${findsFilter.surveyId === 'All' ? ' selected' : ''}>All surveys</option>
                            ${surveyOptions.map(s => `
                                <option value="${s.id}"${findsFilter.surveyId === s.id ? ' selected' : ''}>
                                    ${s.name}
                                </option>
                            `).join('')}
                        </select>
                    </div>
                </div>
                <div class="flex justify-end">
                    <button
                        type="button"
                        id="clear-finds-filters-btn"
                        class="text-xs px-3 py-1 rounded-md border border-gray-300 text-gray-700 hover:bg-gray-100">
                        Clear filters
                    </button>
                </div>
            </form>

            ${hasFinds && filteredFinds.length === 0
                ? `<p class="text-sm text-gray-500 italic">No finds match your current filters.</p>`
                : ''
            }

            ${hasFinds ? cardsHtml : `
                <div class="bg-white rounded-xl shadow-md p-4 text-sm text-gray-600">
                    You don't have any finds yet. When you dig a target and it's worth keeping,
                    use <span class="font-semibold">“Save as Find”</span> from the target actions menu.
                </div>
            `}
        </div>
    `;
}

        
        /** Renders a single target card. */
 function renderTargetCard(target, surveyId) {
    let typeColor = 'bg-primary';
    let typeIcon = 'fas fa-gem';

    switch (target.type) {
        case 'Coin':
            typeColor = 'bg-yellow-500';
            typeIcon = 'fas fa-coins';
            break;
        case 'Relic':
            typeColor = 'bg-red-500';
            typeIcon = 'fas fa-shield-alt';
            break;
        case 'Jewelry':
            typeColor = 'bg-pink-500';
            typeIcon = 'fas fa-ring';
            break;
        case 'Modern Junk':
            typeColor = 'bg-gray-500';
            typeIcon = 'fas fa-trash';
            break;
        case 'Iron Junk':
            typeColor = 'bg-gray-700';
            typeIcon = 'fas fa-magnet';
            break;
        case 'Unidentified':
            typeColor = 'bg-purple-500';
            typeIcon = 'fas fa-question';
            break;
    }

    let statusClass = 'bg-green-100 text-green-800';
    let statusIcon = `<svg class="w-4 h-4 mr-1 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path></svg>`;
    let actionDropdown = '';

    switch (target.status) {
        case 'Signal Detected':
            statusClass = 'bg-green-100 text-green-800';
            actionDropdown = `
                <a href="#" onclick="handleTargetAction(this)" data-action="setStatus" data-status="Hole Dug" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-yellow-700 hover:bg-gray-100"> Mark: Hole Dug </a>
                <a href="#" onclick="handleTargetAction(this)" data-action="setStatus" data-status="Hole Refilled" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-primary hover:bg-gray-100"> Mark: Hole Refilled </a>
                <a href="#" onclick="handleTargetAction(this)" data-action="setStatus" data-status="Signal Ignored" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"> Mark: Signal Ignored </a>
                                <a href="#"
                   onclick="handleTargetAction(this)"
                   data-action="saveFind"
                   data-id="${target.id}"
                   data-survey-id="${surveyId}"
                   class="block px-4 py-2 text-sm text-indigo-700 hover:bg-gray-100">
                    Save as Find
                </a>

            `;
            break;
        case 'Hole Dug':
            statusClass = 'bg-yellow-100 text-yellow-800';
            statusIcon = `<svg class="w-4 h-4 mr-1 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 11H5m14 0a2 2 0 012 2v6a2 2 0 01-2 2H5a2 2 0 01-2-2v-6a2 2 0 012-2m14 0V9a2 2 0 00-2-2M5 11V9a2 2 0 012-2m0 0V5a2 2 0 012-2h6a2 2 0 012 2v2M7 7h10"></path></svg>`;
            actionDropdown = `
                <a href="#" onclick="handleTargetAction(this)" data-action="setStatus" data-status="Signal Detected" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-green-700 hover:bg-gray-100"> Mark: Signal Detected </a>
                <a href="#" onclick="handleTargetAction(this)" data-action="setStatus" data-status="Hole Refilled" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-primary hover:bg-gray-100"> Mark: Hole Refilled </a>
                <a href="#" onclick="handleTargetAction(this)" data-action="setStatus" data-status="Signal Ignored" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"> Mark: Signal Ignored </a>
                            <a href="#"
                   onclick="handleTargetAction(this)"
                   data-action="saveFind"
                   data-id="${target.id}"
                   data-survey-id="${surveyId}"
                   class="block px-4 py-2 text-sm text-indigo-700 hover:bg-gray-100">
                    Save as Find
                </a>

            `;
            break;
        case 'Hole Refilled':
            statusClass = 'bg-secondary/10 text-secondary';
            statusIcon = `<svg class="w-4 h-4 mr-1 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M5 3v4M3 5h4M6 17v4M18 5h2M17 19h4m-7-6l-3-3 6-6m-3 9l3-3 6-6"></path></svg>`;
            actionDropdown = `
                <a href="#" onclick="handleTargetAction(this)" data-action="setStatus" data-status="Signal Detected" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-green-700 hover:bg-gray-100"> Mark: Signal Detected </a>
                <a href="#" onclick="handleTargetAction(this)" data-action="setStatus" data-status="Hole Dug" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-yellow-700 hover:bg-gray-100"> Mark: Hole Dug </a>
                <a href="#" onclick="handleTargetAction(this)" data-action="setStatus" data-status="Signal Ignored" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"> Mark: Signal Ignored </a>
                <a href="#"
                   onclick="handleTargetAction(this)"
                   data-action="saveFind"
                   data-id="${target.id}"
                   data-survey-id="${surveyId}"
                   class="block px-4 py-2 text-sm text-indigo-700 hover:bg-gray-100">
                    Save as Find
                </a>

            `;
            break;
        case 'Signal Ignored':
            statusClass = 'bg-gray-100 text-gray-800';
            statusIcon = `<svg class="w-4 h-4 mr-1 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>`;
            actionDropdown = `
                <a href="#" onclick="handleTargetAction(this)" data-action="setStatus" data-status="Signal Detected" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-green-700 hover:bg-gray-100"> Mark: Signal Detected </a>
                <a href="#" onclick="handleTargetAction(this)" data-action="setStatus" data-status="Hole Dug" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-yellow-700 hover:bg-gray-100"> Mark: Hole Dug </a>
                <a href="#" onclick="handleTargetAction(this)" data-action="setStatus" data-status="Hole Refilled" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-primary hover:bg-gray-100"> Mark: Hole Refilled </a>
            `;
            break;
    }

    // NEW: photo thumbnail HTML (if a photo exists)
    const photoHtml = target.photoDataUrl
        ? `
            <div class="mt-3">
                <img
                    src="${target.photoDataUrl}"
                    alt="Target photo"
                    class="h-24 w-auto rounded-md border border-gray-200 object-cover"
                >
            </div>
        `
        : '';

    return `
        <div class="bg-white p-4 rounded-xl shadow-lg border-l-4" style="border-left-color: ${typeColor};">
            <div class="flex justify-between items-start mb-2">
                <h4 class="text-xl font-bold text-gray-800 flex items-center">
                    <i class="${typeIcon} mr-2 text-lg" style="color: ${typeColor};"></i>
                    ${target.description}
                    <span class="ml-3 text-sm text-white font-semibold px-2 py-0.5 rounded-full" style="background-color: ${typeColor};">${target.type}</span>
                </h4>
                
                <div class="relative inline-block text-left target-dropdown-container">
                    <button type="button" class="inline-flex justify-center w-full rounded-md border border-gray-300 shadow-sm px-2 py-1 bg-white text-sm font-medium text-gray-700 hover:bg-gray-50 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-offset-gray-100 focus:ring-primary" id="dropdownMenuButton-${target.id}" aria-expanded="true" aria-haspopup="true" onclick="this.nextElementSibling.classList.toggle('hidden')">
                        <i class="fas fa-ellipsis-v"></i>
                    </button>
                    
                    <div class="origin-top-right absolute right-0 mt-2 w-56 rounded-md shadow-lg bg-white ring-1 ring-black ring-opacity-5 hidden z-10">
                        <div class="py-1" role="menu" aria-orientation="vertical" aria-labelledby="dropdownMenuButton-${target.id}">
                            ${actionDropdown}
                            <div class="border-t border-gray-100"></div>
                            <a href="#" onclick="handleTargetAction(this)" data-action="edit" data-id="${target.id}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-gray-700 hover:bg-gray-100"> Edit Details </a>
                            <a href="#" onclick="handleTargetAction(this)" data-action="delete" data-id="${target.id}" data-name="${target.description}" data-survey-id="${surveyId}" class="block px-4 py-2 text-sm text-red-600 hover:bg-red-50"> Delete Target </a>
                        </div>
                    </div>
                </div>
            </div>
            
            <p class="text-xs font-semibold px-2.5 py-0.5 rounded-full inline-flex items-center ${statusClass}">
                ${statusIcon} ${target.status}
            </p>

            ${photoHtml}

            <div class="grid grid-cols-2 sm:grid-cols-4 gap-4 text-sm mt-3 pt-3 border-t border-gray-100">
                <div>
                    <strong class="text-gray-500">Target ID:</strong>
                    <span class="text-gray-800">${target.vdi}</span>
                </div>
                <div>
                    <strong class="text-gray-500">Depth:</strong>
                    <span class="text-gray-800">${target.depth}</span>
                </div>
                <div>
                    <strong class="text-gray-500">Accuracy:</strong>
                    <span class="text-gray-800">${target.accuracy && target.accuracy !== 'N/A' ? target.accuracy + 'm' : 'N/A'}</span>
                </div>
                
                <div>
                    <strong class="text-gray-500">Coords:</strong>
                    <span class="text-gray-800 break-all">${target.coordinates.split(',')[0] || target.coordinates}...</span>
                </div>

                <div class="col-span-2 sm:col-span-4 text-xs text-gray-400">
                    Logged at ${new Date(target.time).toLocaleTimeString()} on ${formatDate(target.time)} by ${target.user} (${target.detector})
                </div>
            </div>
        </div>
    `;
}
// --- MAP ZOOM & PAN STATE ---

let mapZoom = 1;
let mapOffsetX = 0; // in %
let mapOffsetY = 0; // in %

const MAP_ZOOM_MIN = 0.5;
const MAP_ZOOM_MAX = 3;
const MAP_ZOOM_STEP = 0.25;

let isMapDragging = false;
let mapDragStartX = 0;
let mapDragStartY = 0;
let mapDragStartOffsetX = 0;
let mapDragStartOffsetY = 0;

/** Re-render the Compass page if it is the active page. */
function rerenderCompassIfActive() {
    if (typeof currentPage !== 'undefined' && currentPage === 'Compass') {
        const appContent = document.getElementById('app-content');
        if (appContent && typeof renderCompassPage === 'function') {
            appContent.innerHTML = renderCompassPage(true);
            if (typeof attachPageEventListeners === 'function') {
                attachPageEventListeners();
            }
        }
    }
}

function zoomMapIn(event) {
    if (event) event.stopPropagation();
    mapZoom = Math.min(MAP_ZOOM_MAX, mapZoom + MAP_ZOOM_STEP);
    rerenderCompassIfActive();
}

function zoomMapOut(event) {
    if (event) event.stopPropagation();
    mapZoom = Math.max(MAP_ZOOM_MIN, mapZoom - MAP_ZOOM_STEP);
    rerenderCompassIfActive();
}

function resetMapView(event) {
    if (event) event.stopPropagation();
    mapZoom = 1;
    mapOffsetX = 0;
    mapOffsetY = 0;
    rerenderCompassIfActive();
}

/** Start dragging the map to pan it. */
function startMapDrag(event) {
    // Don't start a drag when clicking on zoom controls or a pin
    if (
        event.target.closest &&
        (event.target.closest('.map-zoom-controls') ||
         event.target.closest('.map-pin'))
    ) {
        return;
    }

    const e = event.touches ? event.touches[0] : event;
    event.preventDefault();

    isMapDragging = true;
    mapDragStartX = e.clientX;
    mapDragStartY = e.clientY;
    mapDragStartOffsetX = mapOffsetX;
    mapDragStartOffsetY = mapOffsetY;

    document.addEventListener('mousemove', onMapDrag, { passive: false });
    document.addEventListener('mouseup', endMapDrag);
    document.addEventListener('touchmove', onMapDrag, { passive: false });
    document.addEventListener('touchend', endMapDrag);
}

function onMapDrag(event) {
    if (!isMapDragging) return;

    const e = event.touches ? event.touches[0] : event;
    event.preventDefault();

    const container = document.getElementById('target-map-container');
    if (!container) return;

    const rect = container.getBoundingClientRect();
    if (!rect.width || !rect.height) return;

    const dx = e.clientX - mapDragStartX;
    const dy = e.clientY - mapDragStartY;

    const dxPercent = (dx / rect.width) * 100;
    const dyPercent = (dy / rect.height) * 100;

    mapOffsetX = mapDragStartOffsetX + dxPercent;
    mapOffsetY = mapDragStartOffsetY + dyPercent;

    // Update transform live without a full re-render
    const inner = container.querySelector('.map-inner-layer');
    if (inner) {
        inner.style.transform =
            `translate(${mapOffsetX}%, ${mapOffsetY}%) scale(${mapZoom})`;
    }
}

function endMapDrag() {
    if (!isMapDragging) return;
    isMapDragging = false;

    document.removeEventListener('mousemove', onMapDrag);
    document.removeEventListener('mouseup', endMapDrag);
    document.removeEventListener('touchmove', onMapDrag);
    document.removeEventListener('touchend', endMapDrag);
}
        
/** Renders a static plot of targets based on relative coordinates, with optional centre target, grid, and nav line. */
function renderTargetPlot(targets) {
    // Haversine approximation constants
    const M_PER_DEG_LAT = 110574; // meters per degree latitude (relatively constant)
    const M_PER_DEG_LON_AT_EQUATOR = 111320; // meters per degree longitude (at equator)
    
    // Prefer smoothed coords if available, fall back to raw
    const effectiveUserCoords = smoothedUserCoords || currentUserCoords;
    const hasUserGPS = !!effectiveUserCoords && typeof currentUserAccuracy === 'number';
    const userAccuracy = hasUserGPS ? (currentUserAccuracy || 0) : 0;
    const diameterInMeters = userAccuracy * 2;
    const bufferPercentage = 0.05; // 5% buffer around the entire calculated area

    // 1. Parse targets and prepare for Bounding Box calculation
    const parsedCoords = targets.map(t => {
        const parts = t.coordinates.split(',').map(c => parseFloat(c.trim()));
        return {
            id: t.id,
            lat: parts[0],
            lon: parts[1],
            description: t.description,
            type: t.type,
            vdi: t.vdi,
            status: t.status,
            accuracy: parseFloat(t.accuracy) || 0,
            centerOnMap: !!t.centerOnMap,
            isUser: false
        };
    }).filter(c => !isNaN(c.lat) && !isNaN(c.lon));

    let allCoords = [...parsedCoords];
    let userCoord = null;

    // Add user's location if available (smoothed preferred)
    if (hasUserGPS && effectiveUserCoords) {
        userCoord = {
            lat: effectiveUserCoords.lat,
            lon: effectiveUserCoords.lon,
            description: 'Your Current Location',
            type: 'User',
            vdi: 'N/A',
            accuracy: userAccuracy,
            isUser: true
        };
        allCoords.push(userCoord);
    }

    if (allCoords.length === 0) {
        return `
            <div class="p-4 text-center bg-gray-100 rounded-lg">
                <p class="text-lg text-gray-500 italic">No valid GPS coordinates found to plot (targets or user location).</p>
            </div>
        `;
    }

    // --- Find the target (if any) that should be centered on the map ---
    let centerTargetLat = null;
    let centerTargetLon = null;

    const centreTarget = targets.find(t => 
        t.centerOnMap === true &&
        t.coordinates &&
        t.coordinates.includes(',')
    );

    if (centreTarget) {
        const parts = centreTarget.coordinates.split(',').map(c => parseFloat(c.trim()));
        if (!isNaN(parts[0]) && !isNaN(parts[1])) {
            centerTargetLat = parts[0];
            centerTargetLon = parts[1];
        }
    }

    // --- Build bounding box ---
    let minLat, maxLat, minLon, maxLon;
    let latRange, lonRange;
    let mapHeightMeters, mapWidthMeters;

    const toRad = deg => (deg * Math.PI) / 180;

    if (centerTargetLat !== null && centerTargetLon !== null) {
        // ============================================================
        // CASE 1: Use centre target as map centre
        // ============================================================
        minLat = maxLat = centerTargetLat;
        minLon = maxLon = centerTargetLon;

        let maxLatDelta = 0;
        let maxLonDelta = 0;

        allCoords.forEach(c => {
            const dLat = Math.abs(c.lat - centerTargetLat);
            const dLon = Math.abs(c.lon - centerTargetLon);
            if (dLat > maxLatDelta) maxLatDelta = dLat;
            if (dLon > maxLonDelta) maxLonDelta = dLon;
        });

        if (maxLatDelta < 0.00001) maxLatDelta = 0.00001;
        if (maxLonDelta < 0.00001) maxLonDelta = 0.00001;

        let targetLatRange = maxLatDelta * 2;
        let targetLonRange = maxLonDelta * 2;

        let circleLatRange = 0;
        let circleLonRange = 0;

        if (hasUserGPS && userAccuracy > 0) {
            const requiredMeters = diameterInMeters * 1.1; // 10% padding
            const meanLatForConversion = toRad(centerTargetLat);
            const metersPerDegreeLonForConversion = M_PER_DEG_LON_AT_EQUATOR * Math.cos(meanLatForConversion);

            circleLatRange = requiredMeters / M_PER_DEG_LAT;
            circleLonRange = requiredMeters / metersPerDegreeLonForConversion;
        }

        const finalLatRange = Math.max(targetLatRange, circleLatRange);
        const finalLonRange = Math.max(targetLonRange, circleLonRange);

        const latBuffer = finalLatRange * bufferPercentage;
        const lonBuffer = finalLonRange * bufferPercentage;

        minLat = centerTargetLat - (finalLatRange / 2) - latBuffer;
        maxLat = centerTargetLat + (finalLatRange / 2) + latBuffer;
        minLon = centerTargetLon - (finalLonRange / 2) - lonBuffer;
        maxLon = centerTargetLon + (finalLonRange / 2) + lonBuffer;

        latRange = maxLat - minLat;
        lonRange = maxLon - minLon;

        const finalMeanLat = toRad((minLat + maxLat) / 2);
        const metersPerDegreeLon = M_PER_DEG_LON_AT_EQUATOR * Math.cos(finalMeanLat);

        mapHeightMeters = latRange * M_PER_DEG_LAT;
        mapWidthMeters = lonRange * metersPerDegreeLon;
    } else {
        // ============================================================
        // CASE 2: Auto-fit all points + user circle
        // ============================================================
        minLat = maxLat = allCoords[0].lat; 
        minLon = maxLon = allCoords[0].lon;

        allCoords.forEach(c => {
            minLat = Math.min(minLat, c.lat);
            maxLat = Math.max(maxLat, c.lat);
            minLon = Math.min(minLon, c.lon);
            maxLon = Math.max(maxLon, c.lon);
        });

        let targetLatRange = maxLat - minLat;
        let targetLonRange = maxLon - minLon;

        if (targetLatRange < 0.00001) targetLatRange = 0.00002;
        if (targetLonRange < 0.00001) targetLonRange = 0.00002;

        let userLatRange = 0;
        let userLonRange = 0;

        if (hasUserGPS && userAccuracy > 0) {
            const requiredMeters = diameterInMeters * 1.1;
            const meanLatForConversion = toRad(effectiveUserCoords.lat);
            const metersPerDegreeLonForConversion = M_PER_DEG_LON_AT_EQUATOR * Math.cos(meanLatForConversion);

            userLatRange = requiredMeters / M_PER_DEG_LAT;
            userLonRange = requiredMeters / metersPerDegreeLonForConversion;
        }

        const finalLatRange = Math.max(targetLatRange, userLatRange);
        const finalLonRange = Math.max(targetLonRange, userLonRange);

        const centerLat = (minLat + maxLat) / 2;
        const centerLon = (minLon + maxLon) / 2;

        const latBuffer = finalLatRange * bufferPercentage;
        const lonBuffer = finalLonRange * bufferPercentage;

        minLat = centerLat - (finalLatRange / 2) - latBuffer; 
        maxLat = centerLat + (finalLatRange / 2) + latBuffer;
        minLon = centerLon - (finalLonRange / 2) - lonBuffer;
        maxLon = centerLon + (finalLonRange / 2) + lonBuffer;

        latRange = maxLat - minLat;
        lonRange = maxLon - minLon;

        const finalMeanLat = toRad((minLat + maxLat) / 2);
        const metersPerDegreeLon = M_PER_DEG_LON_AT_EQUATOR * Math.cos(finalMeanLat);

        mapHeightMeters = latRange * M_PER_DEG_LAT;
        mapWidthMeters = lonRange * metersPerDegreeLon;
    }

    // ---------------------------------------------------------------------------------------
    // Normalise and draw
    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

let userXPercent = 0;
let userYPercent = 0;
let userPinAndLabelHtml = '';
let userConfidenceCircleHtml = '';

let navTargetXPercent = null;
let navTargetYPercent = null;
let navTargetLat = null;
let navTargetLon = null;
let navTargetAccuracy = null;

    // 2. Normalize and generate pins HTML
        const pinsHtml = allCoords.map(t => {
        const xRaw = ((t.lon - minLon) / lonRange) * 100;
        const yRaw = ((maxLat - t.lat) / latRange) * 100;

        const xPercent = clamp(xRaw, 0, 100);
        const yPercent = clamp(yRaw, 0, 100);

        if (t.isUser) {
            // Store user position for circle and pin positioning
            userXPercent = xPercent;
            userYPercent = yPercent;

            const pinSize = 'w-3 h-3';

            // User pin
            userPinAndLabelHtml = `
                <div
                    class="absolute"
                    style="left: ${userXPercent.toFixed(2)}%; top: ${userYPercent.toFixed(2)}%; transform: translate(-50%, -50%); z-index: 20;"
                    title="Your Current Location (Acc: ${userAccuracy.toFixed(1)}m)"
                >
                    <div class="relative">
                    <div class="${pinSize} bg-blue-500 border-2 border-white shadow-lg rounded-full"></div>
                    </div>
                </div>
            `;
            return '';
        } else {
            // Target pin
            let pinColor = 'bg-primary';
            let pinSize = 'w-2 h-2';

            switch (t.status) {
                case 'Signal Detected':
                    pinColor = 'bg-green-600';
                    pinSize = 'w-3 h-3';
                    break;
                case 'Hole Dug':
                    pinColor = 'bg-yellow-500';
                    break;
                case 'Hole Refilled':
                    pinColor = 'bg-blue-600';
                    break;
                case 'Signal Ignored':
                    pinColor = 'bg-gray-500';
                    break;
                default:
                    pinColor = 'bg-primary';
            }

            // --- NEW: navigation-aware styling ---
const isCentre = t.centerOnMap === true;
const isNavTarget = navigationTargetId && t.id === navigationTargetId;

if (isNavTarget) {
    navTargetXPercent = xPercent;
    navTargetYPercent = yPercent;
    navTargetLat = t.lat;
    navTargetLon = t.lon;
    navTargetAccuracy = typeof t.accuracy === 'number' ? t.accuracy : null;
}

            const extraRing = isNavTarget
                ? '<div class="absolute -inset-1 rounded-full border-2 border-blue-500 animate-ping"></div>'
                : (isCentre
                    ? '<div class="absolute -inset-1 rounded-full border-2 border-red-500 animate-pulse"></div>'
                    : '');

            // Dim everything except the active nav target (if one is set)
            const dimClass = navigationTargetId && !isNavTarget ? 'opacity-40' : '';

            // --- OPTIONAL: confidence circle per target (using its accuracy) ---
            let targetCircleHtml = '';
            if (!isNaN(t.accuracy) && t.accuracy > 0 && mapWidthMeters && mapHeightMeters) {
                const scaleFactor = Math.max(mapWidthMeters, mapHeightMeters) / 100;
                const tDiameterPercent = (t.accuracy * 2) / (scaleFactor || 1);

                const circleBorder = isNavTarget ? 'border-blue-500' : 'border-gray-500';
                const circleBg = isNavTarget ? 'bg-blue-500/10' : 'bg-gray-500/5';

                targetCircleHtml = `
                    <div class="absolute rounded-full ${circleBorder} ${circleBg} pointer-events-none"
                        style="
                            width: ${tDiameterPercent.toFixed(2)}%; 
                            height: ${tDiameterPercent.toFixed(2)}%;
                            left: ${xPercent.toFixed(2)}%; top: ${yPercent.toFixed(2)}%;
                            transform: translate(-50%, -50%);
                            z-index: 2;
                        ">
                    </div>
                `;
            }

            return `
                ${targetCircleHtml}
                <div
                    class="absolute map-pin ${dimClass}"
                    style="left: ${xPercent.toFixed(2)}%; top: ${yPercent.toFixed(2)}%; transform: translate(-50%, -50%); z-index: 10;"
                    title="${t.description} (Target ID: ${t.vdi}) - ${t.lat.toFixed(6)}, ${t.lon.toFixed(6)} (Acc: ${t.accuracy.toFixed(1)}m)"
                    onclick="handleMapTargetClick(event, '${t.id || ''}')"
                >
                    <div class="relative">
                        ${extraRing}
                        <div class="${pinSize} rounded-full ${pinColor} border-2 border-primary shadow-lg cursor-pointer"></div>
                    </div>
                    <span class="absolute whitespace-nowrap text-xs font-semibold text-gray-800 bg-white p-1 rounded-sm shadow border border-gray-300" 
                        style="left: 100%; top: 50%; transform: translateY(-50%) translateX(5px);">
                        ${t.description} (Acc: ${t.accuracy.toFixed(1)}m)
                    </span>
                </div>
            `;
        }
    }).join('');
    
    // --- Confidence circle for user accuracy ---
    if (userCoord && userAccuracy > 0 && mapWidthMeters && mapHeightMeters) {
        const scaleFactor = Math.max(mapWidthMeters, mapHeightMeters) / 100;
        const diameterPercent = diameterInMeters / (scaleFactor || 1);

        userConfidenceCircleHtml = `
            <div class="absolute rounded-full border-2 border-red-500 bg-red-500/10 pointer-events-none"
                style="
                    width: ${diameterPercent.toFixed(2)}%; 
                    height: ${diameterPercent.toFixed(2)}%;
                    left: ${userXPercent.toFixed(2)}%; top: ${userYPercent.toFixed(2)}%;
                    transform: translate(-50%, -50%);
                    z-index: 5; 
                "
                title="Confidence Radius: ${userAccuracy.toFixed(1)}m">
            </div>
        `;
    }

     // --- NEW: line from user to navigation target (map-space, not true bearing) ---
     // --- Line from user to current navigation target (with arrow, label, and proximity logic) ---
    let navLineHtml = '';

    if (
        navigationTargetId &&
        userCoord &&
        navTargetXPercent !== null &&
        navTargetYPercent !== null &&
        typeof navTargetLat === 'number' &&
        typeof navTargetLon === 'number'
    ) {
        // Use smoothed coords if available, else raw userCoord
        const userLat = effectiveUserCoords ? effectiveUserCoords.lat : userCoord.lat;
        const userLon = effectiveUserCoords ? effectiveUserCoords.lon : userCoord.lon;

        // Real-world distance in metres
        const distanceToNavMeters = distanceMeters(userLat, userLon, navTargetLat, navTargetLon);

        // How big is the "inside the circle" threshold?
        const navAcc = (typeof navTargetAccuracy === 'number' && navTargetAccuracy > 0)
            ? navTargetAccuracy
            : null;

        // If we know the nav target accuracy, use that. Otherwise fall back to user accuracy or a small default.
        const insideCircleThreshold =
            navAcc || (userAccuracy && userAccuracy > 0 ? userAccuracy : 0);

        const isInsideCircle =
            insideCircleThreshold && distanceToNavMeters <= insideCircleThreshold;

        // If we're inside the target's confidence circle, hide the line entirely
        if (!isInsideCircle) {
            // --- Scale-dependent arrow size based on mapZoom ---
            const arrowScale = 1 + (mapZoom - 1) * 0.5; // grows as you zoom in
            const clampedArrowScale = Math.max(0.75, Math.min(arrowScale, 2.0));

            const baseMarkerSize = 6;
            const markerWidth = baseMarkerSize * clampedArrowScale;
            const markerHeight = baseMarkerSize * clampedArrowScale;
            const refX = 4 * clampedArrowScale;
            const refY = 3 * clampedArrowScale;

            // --- Distance label position (midpoint) ---
            const midX = (userXPercent + navTargetXPercent) / 2;
            const midY = (userYPercent + navTargetYPercent) / 2;

            // Human-friendly distance string
            const distLabel =
                distanceToNavMeters >= 1000
                    ? (distanceToNavMeters / 1000).toFixed(2) + ' km'
                    : distanceToNavMeters.toFixed(1) + ' m';

            // --- Pulse effect when "near" the circle but not inside it ---
            const pulseThreshold = insideCircleThreshold ? insideCircleThreshold * 1.5 : 0;
            const shouldPulse = pulseThreshold && distanceToNavMeters <= pulseThreshold;
            const lineClass = shouldPulse ? 'animate-pulse' : '';

            navLineHtml = `
                <svg
                    class="absolute inset-0 pointer-events-none"
                    viewBox="0 0 100 100"
                    preserveAspectRatio="none"
                    style="z-index: 8;"
                >
                    <defs>
                        <marker 
                            id="navArrow"
                            markerWidth="${markerWidth}"
                            markerHeight="${markerHeight}"
                            refX="${refX}"
                            refY="${refY}"
                            orient="auto"
                        >
                            <polygon points="0 0, ${markerWidth} ${markerHeight / 2}, 0 ${markerHeight}" fill="rgba(37,99,235,0.9)" />
                        </marker>
                    </defs>

                    <line
                        x1="${userXPercent.toFixed(2)}"
                        y1="${userYPercent.toFixed(2)}"
                        x2="${navTargetXPercent.toFixed(2)}"
                        y2="${navTargetYPercent.toFixed(2)}"
                        stroke="rgba(37,99,235,0.9)"
                        stroke-width="1.5"
                        stroke-dasharray="3 2"
                        marker-end="url(#navArrow)"
                        class="${lineClass}"
                    />
                    <text
                        x="${midX.toFixed(2)}"
                        y="${midY.toFixed(2)}"
                        text-anchor="middle"
                        dominant-baseline="central"
                        font-size="3"
                        fill="#1f2937"
                        stroke="white"
                        stroke-width="0.3"
                    >
                        ${distLabel}
                    </text>
                </svg>
            `;
        }
    }


    // Combine all elements for the map container
    const finalMapContent = userConfidenceCircleHtml + navLineHtml + pinsHtml + userPinAndLabelHtml;

    // --- Container with grid background & zoom/pan controls ---
    let containerClasses =
        "relative overflow-hidden border-4 border-gray-400 rounded-lg my-4 bg-gray-200 w-full aspect-square";

    const gridStyle = `
        background-image:
          linear-gradient(to right, rgba(0,0,0,0.06) 1px, transparent 1px),
          linear-gradient(to bottom, rgba(0,0,0,0.06) 1px, transparent 1px);
        background-size: 10% 10%;
    `;

    const transformStyle = `
        transform: translate(${mapOffsetX}%, ${mapOffsetY}%) scale(${mapZoom});
        transform-origin: center center;
    `;

    return `
        <div
            id="target-map-container"
            class="${containerClasses}"
            style="${gridStyle}"
            onmousedown="startMapDrag(event)"
            ontouchstart="startMapDrag(event)"
        >
            <div class="map-inner-layer absolute inset-0" style="${transformStyle}">
                ${finalMapContent}
            </div>

            <div class="absolute bottom-2 right-2 flex gap-1 bg-white/80 px-2 py-1 rounded text-xs text-gray-700 shadow pointer-events-auto map-zoom-controls">
                <button
                    type="button"
                    class="px-2 py-1 rounded bg-gray-200 hover:bg-gray-300 font-bold"
                    onclick="zoomMapOut(event)"
                >−</button>
                <button
                    type="button"
                    class="px-2 py-1 rounded bg-gray-200 hover:bg-gray-300 font-bold"
                    onclick="zoomMapIn(event)"
                >+</button>
                <button
                    type="button"
                    class="px-2 py-1 rounded bg-gray-200 hover:bg-gray-300"
                    onclick="resetMapView(event)"
                >Reset</button>
            </div>
        </div>
    `;
}
       /** Toggles the map state and re-renders immediately. */
function toggleMapFullscreen() {
    // Toggle the state variable
    isMapFullscreen = !isMapFullscreen;
    
    // Re-render the page immediately so the new class is applied
    // This also resets the auto-refresh timer, which is fine.
    render(); 
}  

function renderNavigationPanel(openSurvey) {
    // If no navigation target has been selected yet, show a hint.
    if (!navigationTargetId) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-dashed border-gray-300 mb-6">
                <h3 class="text-lg font-semibold text-gray-700 mb-1">
                    <i class="fas fa-location-arrow mr-2"></i> Navigation
                </h3>
                <p class="text-sm text-gray-600">
                    Tap a target pin on the plot to select it for navigation. 
                    Once selected, distance and bearing from your GPS position will appear here.
                </p>
            </div>
        `;
    }

    // Look up the selected target in the open survey
    const target = openSurvey.targets.find(t => t.id === navigationTargetId);

    if (!target) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-red-300 mb-6">
                <h3 class="text-lg font-semibold text-red-700 mb-1">
                    <i class="fas fa-exclamation-triangle mr-2"></i> Navigation Target Missing
                </h3>
                <p class="text-sm text-gray-600">
                    The selected navigation target could not be found. It may have been deleted.
                </p>
                <button 
                    class="mt-3 px-3 py-1 text-xs font-semibold rounded bg-gray-200 hover:bg-gray-300"
                    onclick="clearNavigationTarget()">
                    Clear navigation target
                </button>
            </div>
        `;
    }

    // Ensure the target has usable coordinates
    if (!target.coordinates || !target.coordinates.includes(',')) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-yellow-300 mb-6">
                <h3 class="text-lg font-semibold text-yellow-700 mb-1">
                    <i class="fas fa-map-marker-alt mr-2"></i> Navigation Target
                </h3>
                <p class="text-sm text-gray-600">
                    Target <strong>${target.description}</strong> is selected, but it has no valid GPS coordinates logged,
                    so distance and bearing cannot be calculated.
                </p>
                <button 
                    class="mt-3 px-3 py-1 text-xs font-semibold rounded bg-gray-200 hover:bg-gray-300"
                    onclick="clearNavigationTarget()">
                    Clear navigation target
                </button>
            </div>
        `;
    }

    // Parse target coordinates
    const parts = target.coordinates.split(',').map(c => parseFloat(c.trim()));
    const targetLat = parts[0];
    const targetLon = parts[1];

    if (isNaN(targetLat) || isNaN(targetLon)) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-yellow-300 mb-6">
                <h3 class="text-lg font-semibold text-yellow-700 mb-1">
                    <i class="fas fa-map-marker-alt mr-2"></i> Navigation Target
                </h3>
                <p class="text-sm text-gray-600">
                    Target <strong>${target.description}</strong> has invalid GPS data and cannot be used for navigation.
                </p>
                <button 
                    class="mt-3 px-3 py-1 text-xs font-semibold rounded bg-gray-200 hover:bg-gray-300"
                    onclick="clearNavigationTarget()">
                    Clear navigation target
                </button>
            </div>
        `;
    }

    // Decide which user coords to use (prefer smoothed if available)
    const effectiveUser = smoothedUserCoords || currentUserCoords;

    if (!effectiveUser) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-blue-300 mb-6">
                <h3 class="text-lg font-semibold text-blue-700 mb-1">
                    <i class="fas fa-location-arrow mr-2"></i> Navigation to: ${target.description}
                </h3>
                <p class="text-sm text-gray-600">
                    Target is selected, but waiting for your GPS position…
                    Once your location is available, distance and bearing will appear here.
                </p>
                <button 
                    class="mt-3 px-3 py-1 text-xs font-semibold rounded bg-gray-200 hover:bg-gray-300"
                    onclick="clearNavigationTarget()">
                    Clear navigation target
                </button>
            </div>
        `;
    }

    // Compute distance and bearing using the global geo helpers
    const userLat = effectiveUser.lat;
    const userLon = effectiveUser.lon;

    const distMeters = distanceMeters(userLat, userLon, targetLat, targetLon);
    const bearingDeg = initialBearingDegrees(userLat, userLon, targetLat, targetLon);
    const bearingLabel = bearingToCompassPoint(bearingDeg, 16);

    const distStr =
        distMeters >= 1000
            ? (distMeters / 1000).toFixed(2) + ' km'
            : distMeters.toFixed(1) + ' m';

    const bearingStr = `${bearingDeg.toFixed(1)}° (${bearingLabel})`;
// --- Movement-based guidance (optional, only if we have enough movement) ---
let guidanceHtml = '';
const movementBearingDeg = computeMovementBearingDegrees();

if (movementBearingDeg !== null) {
    // Relative angle from movement direction to target direction
    let rel = bearingDeg - movementBearingDeg;
    // Normalise to -180..+180
    if (rel > 180) rel -= 360;
    if (rel <= -180) rel += 360;

    const absRel = Math.abs(rel);
    let guidanceText = '';
    let guidanceIcon = '';
    let guidanceClass = 'text-gray-700';

    if (absRel < 15) {
        guidanceText = 'On course – target roughly ahead of your walking direction.';
        guidanceIcon = '<i class="fas fa-arrow-up mr-1"></i>';
        guidanceClass = 'text-green-700';
    } else if (absRel < 45) {
        if (rel > 0) {
            guidanceText = 'Target slightly to your right – adjust a little right.';
            guidanceIcon = '<i class="fas fa-arrow-up-right mr-1"></i>';
        } else {
            guidanceText = 'Target slightly to your left – adjust a little left.';
            guidanceIcon = '<i class="fas fa-arrow-up-left mr-1"></i>';
        }
        guidanceClass = 'text-yellow-700';
    } else if (absRel < 135) {
        if (rel > 0) {
            guidanceText = 'Target to your right – turn more to the right.';
            guidanceIcon = '<i class="fas fa-arrow-right mr-1"></i>';
        } else {
            guidanceText = 'Target to your left – turn more to the left.';
            guidanceIcon = '<i class="fas fa-arrow-left mr-1"></i>';
        }
        guidanceClass = 'text-orange-700';
    } else {
        guidanceText = 'Target is roughly behind you – turn around.';
        guidanceIcon = '<i class="fas fa-arrow-down mr-1"></i>';
        guidanceClass = 'text-red-700';
    }

    guidanceHtml = `
        <p class="text-sm mt-2 ${guidanceClass}">
            <span class="font-semibold">Guidance:</span> ${guidanceIcon}${guidanceText}
        </p>
        <p class="text-xs text-gray-500 mt-1">
            Based on recent movement; walk a few metres to stabilise this guidance.
        </p>
    `;
} else {
    guidanceHtml = `
        <p class="text-sm text-gray-600 mt-2">
            <span class="font-semibold">Guidance:</span> Start walking a few metres so we can estimate your direction of travel.
        </p>
    `;
}
    return `
        <div class="bg-white p-4 rounded-xl shadow-md border border-green-300 mb-6">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-lg font-semibold text-green-700">
                    <i class="fas fa-location-arrow mr-2"></i> Navigation to: ${target.description}
                </h3>
                <button 
                    class="px-2 py-1 text-xs font-semibold rounded bg-gray-200 hover:bg-gray-300"
                    onclick="clearNavigationTarget()">
                    Clear
                </button>
            </div>
            <p class="text-sm text-gray-700 mb-1">
                <span class="font-semibold">Distance:</span> ${distStr}
            </p>
            <p class="text-sm text-gray-700 mb-1">
                <span class="font-semibold">Bearing from you:</span> ${bearingStr}
            </p>
            ${guidanceHtml}
        </div>
    `;

}
        
     
function renderCompassPage(isAutoRefresh = false) {
    const openSurvey = surveys.find(s => s.status === 'Open');

    if (!openSurvey) {
        // First return path (handles no open survey)
        return `
            <div class="p-4">
                <h2 class="text-3xl font-bold text-primary mb-6">Targets Plot View</h2>
                <div class="bg-white p-6 rounded-xl shadow-lg border-l-4 border-red-500">
                    <h3 class="text-xl font-bold text-red-600 mb-3">No Open Survey</h3>
                    <p class="text-gray-700">Please open a survey on the **Home** page to view its targets on the plot.</p>
                </div>
            </div>
        `;
    }

    // Start the GPS watch and the 5-second rendering interval ONLY ONCE when navigating to the page manually
    // (This line must be inside the function body, which it is now)
    if (!isAutoRefresh) {
        startLiveMapLocationWatch();
    }
    
    // Filter for targets that actually have usable coordinates
    const targets = openSurvey.targets.filter(t => t.coordinates && t.coordinates.includes(',') && t.coordinates !== 'No GPS logged');

    // Second return path (renders the map view)
    // Second return path (renders the map view)
    return `
        <div class="p-4">
            <h2 class="text-3xl font-bold text-primary mb-6">Targets Plot View</h2>
            
            <!-- Survey info -->
            <div class="bg-card p-4 rounded-lg shadow-md mb-6 border-l-4 border-primary">
                <h3 class="text-xl font-semibold mb-1 text-gray-700">
                    Viewing Targets for: <span class="text-primary">${openSurvey.name}</span>
                </h3>
                <p class="text-sm text-gray-600">
                    Targets with valid GPS logged: <strong>${targets.length}</strong>
                </p>
                ${isAutoRefresh ? 
                    `<p class="text-sm text-green-600 mt-2">
                        <i class="fas fa-redo fa-spin mr-1"></i> Auto-refreshing map every 3 seconds...
                    </p>` : ''
                }
            </div>

            <!-- Map first -->
            <div class="bg-white p-4 rounded-xl shadow-lg border border-gray-100 mb-4">
                <h3 class="text-xl font-semibold text-gray-700 flex items-center mb-3">
                    <i class="fas fa-map mr-2"></i> Survey Map
                </h3>
                ${renderTargetPlot(targets)}
            </div>

            <!-- Then navigation panel -->
            ${renderNavigationPanel(openSurvey)}

            <!-- Explanatory text at the bottom -->
            <div class="bg-white p-3 rounded-lg shadow-sm border border-gray-200 text-xs text-gray-600 mt-4">
                <h4 class="font-semibold mb-1">Plot & navigation notes</h4>
                <ul class="list-disc list-inside space-y-1">
                    <li>The plot shows relative positions within the survey area. Targets are dots; your position is the blue circle.</li>
                    <li><span class="font-semibold">North</span> is towards the top of the box, and <span class="font-semibold">East</span> is towards the right.</li>
                    <li>Use the <span class="font-semibold">+</span> and <span class="font-semibold">−</span> buttons to zoom, and drag the map to keep targets in view.</li>
                    <li>Tap a target pin on the map to select it for navigation. The dashed line and arrow show direction from your GPS position to the target.</li>
                    <li>When you are inside the target’s confidence circle, the navigation line is hidden as you are already “on top” of the target.</li>
                </ul>
            </div>
        </div>
    `;
}
        /** Renders the content for the Settings page. */
        function renderSettingsPage() {
            const secondaryColor = 'rgb(var(--color-secondary))';
            return `
                <div class="p-4">
                    <h2 class="text-3xl font-bold text-primary mb-6">Settings & Local Data Management</h2>

                    <div class="bg-white p-4 rounded-xl shadow-lg mb-8 border border-gray-100">
                        <h3 class="text-xl font-semibold text-gray-700 mb-3">Your Profile</h3>
                        <p class="text-md text-gray-800 mb-1"><strong>Name:</strong> ${userProfile.name}</p>
                        <p class="text-md text-gray-800 mb-4"><strong>Detector:</strong> ${userProfile.detector}</p>
                        
                        <div class="mt-4 pt-3 border-t border-gray-100">
                            <button onclick="showEditProfileModal()" class="px-3 py-2 text-white font-bold rounded-md text-sm hover:opacity-90 transition duration-150" style="background-color: ${secondaryColor};">
                                <i class="fas fa-user-edit mr-1"></i> Edit Profile
                            </button>
                        </div>
                    </div>

                    <h3 class="text-2xl font-bold text-gray-700 mb-3">Data Export & Import</h3>

                    <div class="bg-white p-4 rounded-xl shadow-lg mb-6 border-l-4 border-primary">
                        <h4 class="text-lg font-semibold text-gray-700 mb-2">Export Data</h4>
                        <p class="text-sm text-gray-600 mb-3">Export all your surveys and profile data as JSON text to back it up or move it to another device.</p>
                        <button id="export-data-btn" class="w-full bg-primary text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-primary/90 transition duration-150">
                            <i class="fas fa-download mr-1"></i> Export Data (JSON)
                        </button>
                        <textarea id="exported-data-area" rows="5" readonly placeholder="Exported JSON data will appear here..." class="w-full p-2 border border-gray-300 rounded-md font-mono text-xs mt-4 hidden"></textarea>
                    </div>

                    <div class="bg-white p-4 rounded-xl shadow-lg mb-8 border-l-4 border-yellow-500">
                        <h4 class="text-lg font-semibold text-yellow-700 mb-2">Import Data (Overwrite)</h4>
                        <p class="text-sm text-gray-600 mb-3">Paste the exported JSON text here and click Import. **Warning:** This will overwrite any existing local data on this device.</p>
                        
                        <textarea id="import-data-area" rows="10" placeholder="Paste your exported JSON data here..." class="w-full p-2 border border-yellow-500 rounded-md font-mono text-xs mb-4"></textarea>
                        <button id="import-data-btn" class="w-full bg-red-500 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-red-600 transition duration-150">
                            <i class="fas fa-upload mr-1"></i> Import & Overwrite Local Data
                        </button>
                    </div>
                </div>
            `;
        }

        // --- DATA MANAGEMENT FUNCTIONS ---

        /** Exports all data (surveys and profile) to a JSON string and displays it. */
        function exportData() {
            const dataToExport = {
                surveys: surveys,
                profile: userProfile,
                userId: userId,
                exportDate: new Date().toISOString()
            };

            const jsonString = JSON.stringify(dataToExport, null, 2);
            const dataArea = document.getElementById('exported-data-area');
            
            dataArea.value = jsonString;
            dataArea.classList.remove('hidden');
            dataArea.select(); // Select the text for easy copying
            
            // Try to copy to clipboard
            navigator.clipboard.writeText(jsonString).then(() => {
                showMessage('Data copied to clipboard! Paste it safely.', 'success');
            }).catch(err => {
                showMessage('Exported data displayed. Please manually copy the text.', 'warning');
                console.error('Could not copy text: ', err);
            });
        }

        /** Imports data from a JSON string, overwriting existing local storage. */
        function importData() {
            const dataArea = document.getElementById('import-data-area');
            const jsonString = dataArea.value.trim();

            if (!jsonString) {
                return showMessage('Please paste the JSON data into the box.', 'error');
            }

            try {
                const importedData = JSON.parse(jsonString);

                if (!importedData.surveys || !importedData.profile) {
                    throw new Error("Invalid data structure. Missing 'surveys' or 'profile' key.");
                }

                showConfirmationModal(
                    "Confirm Data Import",
                    `Are you sure you want to import data? This will **permanently overwrite** your ${surveys.length} existing local surveys.`,
                    () => {
                        // Overwrite global state
                        surveys = importedData.surveys;
                        userProfile = importedData.profile;
                        userId = importedData.userId || generateId(); // Use existing ID or generate a new one
                        
                        saveSurveysToLocalStorage();
                        dataArea.value = ''; // Clear the input area
                        showMessage('Data successfully imported and saved!', 'success');
                        currentPage = 'Home'; // Navigate to home to show new data
                        render();
                    }
                );
            } catch (e) {
                console.error("Import Error:", e);
                showMessage(`Import failed: ${e.message || 'Invalid JSON format.'}`, 'error');
            }
        }


        // --- INITIALIZATION & EVENT LISTENERS ---

        // Event listener for navigation buttons
        document.querySelectorAll('.nav-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const targetPage = e.currentTarget.dataset.page;
                if (targetPage && targetPage !== currentPage) {
                    currentPage = targetPage;
                    render();
                }
            });
        });
        
        // 1. Load data first
        loadDataFromLocalStorage();
        showMessage("Data loaded instantly from local storage.", 'success'); // Show initial load message

        // 2. Initial render call
        render();

    </script>
</body>
</html>
