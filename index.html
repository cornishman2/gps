<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="manifest" href="manifest.json">
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js"></script>


<title>Detekta – A Metal Detecting App</title>

    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    
    <style>
/* Active navigation button */
.nav-btn.active {
    color: rgb(var(--color-primary));
}

.nav-btn.active span {
    font-weight: 600;
}

        
        /* Custom colors using CSS variables for guaranteed consistency */
        :root {
            --color-primary: 29 78 216;      /* Blue (For contrast/borders) */
            --color-secondary: 34 197 94;    /* Vibrant Green (For action buttons) */
            --color-background: 243 244 246; /* Light Gray */
            --color-card: 255 255 255;       /* White */
        }

        /* Configure Tailwind to use the custom variables (kept for other classes like text-primary) */
        tailwind-config {
            theme: {
                extend: {
                    colors: {
                        primary: 'rgb(var(--color-primary) / <alpha-value>)',
                        secondary: 'rgb(var(--color-secondary) / <alpha-value>)',
                        background: 'rgb(var(--color-background) / <alpha-value>)',
                        card: 'rgb(var(--color-card) / <alpha-value>)',
                    }
                }
            }
        }

        /* Basic App Styling */
        body {
            font-family: 'Arial', sans-serif;
            background-color: rgb(var(--color-background));
        }

        /* Ensure the modal is hidden by default and handles clicks outside */
        .modal {
            display: none;
            position: fixed;
            z-index: 50;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }
        /* Ensure the photo gallery always sits above other modals */
        .modal.modal-gallery {
    z-index: 100; /* higher than the normal modal z-index (50) */
}

        .modal-content {
            margin: 10vh auto;
            border-radius: 12px;
            max-width: 500px;
        }
    </style>
</head>
<body class="min-h-screen">

    <header class="bg-white shadow-md fixed top-0 left-0 right-0 z-40">
        <div class="container mx-auto max-w-lg">
            <div class="flex items-center justify-between p-4">
              <h1 class="text-xl font-extrabold text-primary leading-tight">Detekta V18
                  <span class="block text-xs font-semibold text-gray-500">A Metal Detecting App</span></h1>

                <div class="hidden sm:flex space-x-2">

                
                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Home">
                        <i class="fas fa-home text-xl"></i>
                    </button>
                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Compass">
                        <i class="fas fa-compass text-xl"></i>
                    </button>
                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Targets">
                        <i class="fas fa-bullseye text-xl"></i>
                    </button>
                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Finds">
                        <i class="fas fa-trophy text-xl"></i>
                   </button>

                   <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Export">
                        <i class="fas fa-file-export text-xl"></i>
                   </button>

                  <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Settings">
                        <i class="fas fa-cog text-xl"></i>
                  </button>
                   <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Help">
                        <i class="fas fa-question-circle mr-2"></i>
                    </button>
                    
                </div>
            </div>
        </div>
    </header>

    <main id="app-content" class="container mx-auto max-w-lg pt-20 pb-24 sm:pb-4 min-h-screen"></main>


    <div id="message-toast" class="fixed bottom-4 right-4 z-50 p-4 rounded-lg text-white shadow-xl transition-opacity duration-300 opacity-0 pointer-events-none" style="min-width: 250px;"></div>

    <div id="confirmation-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 id="confirm-title" class="text-xl font-bold text-red-600 mb-4">Confirmation</h3>
            <p id="confirm-message" class="text-gray-700 mb-6"></p>
            <div class="flex justify-end space-x-3">
                <button id="confirm-no-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button id="confirm-yes-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-semibold">Yes, Proceed</button>
            </div>
        </div>
    </div>
        <div id="photo-gallery-modal" class="modal modal-gallery">
                <div class="modal-content bg-black bg-opacity-90 text-white p-4 shadow-2xl relative max-w-full">
                <!-- Close button -->
                    <button
                    type="button"
                    class="absolute top-3 right-3 w-8 h-8 rounded-full bg-gray-800 bg-opacity-80 hover:bg-opacity-100 flex items-center justify-center"
                    onclick="closePhotoGallery()"
                    >
                    <i class="fas fa-times text-sm"></i>
                    </button>

                    <!-- Image area (swipe here) -->
                    <div id="photo-gallery-image-wrapper" class="flex items-center justify-center mt-4">
                    <img
                        id="photo-gallery-image"
                        alt="Photo"
                        class="max-h-screen w-auto rounded-lg border border-gray-700"
                    >
                </div>

            <!-- “1 of N” text -->
            <p id="photo-gallery-caption" class="mt-3 text-center text-sm text-gray-300"></p>

            <!-- Prev / Next buttons -->
            <div class="mt-4 flex justify-between items-center">
                <button
                    type="button"
                    class="px-4 py-2 rounded-md bg-gray-700 hover:bg-gray-600 text-sm font-semibold"
                    onclick="showGalleryPhoto(-1)"
                >
                    ‹ Previous
                </button>
                <button
                    type="button"
                    class="px-4 py-2 rounded-md bg-gray-700 hover:bg-gray-600 text-sm font-semibold"
                    onclick="showGalleryPhoto(1)"
                >
                    Next ›
                </button>
            </div>
        </div>
    </div>
<!-- Target QR modal -->
<div id="target-qr-modal" class="modal">
  <div class="modal-content bg-white p-6 shadow-2xl max-w-sm">
    <h3 id="target-qr-title" class="text-xl font-bold text-primary mb-4">
      Target QR
    </h3>

    <div
      id="target-qr-code-container"
      class="w-full flex items-center justify-center mb-4"
    >
      <!-- QR code will be inserted here -->
    </div>

    <p class="text-xs text-gray-500 mb-2">
      This QR encodes the main details of this target so it can be imported on another device.
    </p>

    <textarea
      id="target-qr-raw-text"
      class="w-full h-24 text-xs font-mono bg-gray-50 border border-gray-200 rounded-md p-2 mb-4"
      readonly
    ></textarea>

    <div class="flex justify-end">
      <button
        type="button"
        class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
        onclick="closeTargetQrModal()"
      >
        Close
      </button>
    </div>
  </div>
</div>
<!-- Target QR SCAN modal -->
<div id="target-qr-scan-modal" class="modal">
  <div class="modal-content bg-white p-6 shadow-2xl max-w-sm">
    <h3 class="text-xl font-bold text-primary mb-4">
      Import Target via QR
    </h3>

    <p class="text-sm text-gray-600 mb-3">
      The target will be imported into the <strong>currently open survey</strong>.
      Point your camera at a GeoFind Target QR code on another device.
    </p>

    <div class="w-full aspect-video bg-black rounded-lg overflow-hidden mb-3 flex items-center justify-center">
      <video
        id="target-qr-scan-video"
        autoplay
        playsinline
        class="w-full h-full object-cover"
      ></video>
    </div>

    <p
      id="target-qr-scan-status"
      class="text-xs text-gray-500 mb-4"
    >
      Initialising camera…
    </p>

    <div class="flex justify-end">
      <button
        type="button"
        class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
        onclick="closeTargetQrScanModal()"
      >
        Cancel
      </button>
    </div>
  </div>
</div>

<!-- Hidden canvas used internally for QR decoding -->
<canvas id="target-qr-scan-canvas" class="hidden"></canvas>

    
    <div id="new-survey-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 class="text-xl font-bold text-primary mb-4">Create New Survey</h3>
            <form id="new-survey-form">
                <div class="mb-4">
                    <label for="survey-name" class="block text-sm font-medium text-gray-700">Survey Name *</label>
                    <input type="text" id="survey-name" name="surveyName" required 
                           class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                </div>
                <div class="mb-4">
                    <label for="survey-description" class="block text-sm font-medium text-gray-700">Description / Location</label>
                    <textarea id="survey-description" name="surveyDescription" rows="3" 
                              class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"></textarea>
                </div>

            <!-- Additional Survey Details (all optional) -->
            <div class="mt-6 border-t pt-4">
                <h4 class="text-lg font-semibold text-gray-800 mb-3">Permission &amp; Site Details (optional)</h4>

                <!-- 1) Permission & Legality -->
                <div class="mb-4">
                    <label for="survey-permission-from" class="block text-sm font-medium text-gray-700">Permission From</label>
                    <input type="text" id="survey-permission-from" name="permissionFrom"
                           class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                           placeholder="e.g. Farmer Smith, National Trust, Council" />
                </div>

                <div class="mb-4">
                    <label for="survey-permission-type" class="block text-sm font-medium text-gray-700">Permission Type</label>
                    <select id="survey-permission-type" name="permissionType"
                            class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                        <option value="">(blank)</option>
                        <option>Written</option>
                        <option>Verbal</option>
                        <option>Club / Rally</option>
                        <option>Open access</option>
                    </select>
                </div>

                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="survey-permission-date-granted" class="block text-sm font-medium text-gray-700">Permission Date Granted</label>
                        <input type="text" id="survey-permission-date-granted" name="permissionDateGranted"
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary" placeholder="dd/mm/yy" inputmode="numeric" />
                    </div>
                    <div>
                        <label for="survey-permission-expiry" class="block text-sm font-medium text-gray-700">Permission Expiry / Review Date</label>
                        <input type="text" id="survey-permission-expiry" name="permissionExpiry"
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary" placeholder="dd/mm/yy" inputmode="numeric" />
                    </div>
                </div>

                <div class="mb-6">
                    <label for="survey-permission-notes" class="block text-sm font-medium text-gray-700">Permission Notes</label>
                    <textarea id="survey-permission-notes" name="permissionNotes" rows="2"
                              class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                              placeholder="e.g. No hedgerows, fill holes, pasture only..."></textarea>
                </div>

                <!-- 2) Area / Site Type -->
                <h5 class="text-md font-semibold text-gray-800 mb-2">Area / Site</h5>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                    <div>
                        <label for="survey-area-type" class="block text-sm font-medium text-gray-700">Type of Area</label>
                        <select id="survey-area-type" name="areaType"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Field (Pasture)</option>
                            <option>Field (Ploughed)</option>
                            <option>Beach (Dry)</option>
                            <option>Beach (Wet / Tidal)</option>
                            <option>Woods</option>
                            <option>Park</option>
                            <option>Moor / Heath</option>
                            <option>Riverbank / Foreshore</option>
                            <option>Other</option>
                        </select>
                    </div>
                    <div>
                        <label for="survey-land-use-current" class="block text-sm font-medium text-gray-700">Land Use (Current)</label>
                        <select id="survey-land-use-current" name="landUseCurrent"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Agricultural</option>
                            <option>Recreational</option>
                            <option>Woodland</option>
                            <option>Coastal</option>
                            <option>Urban fringe</option>
                        </select>
                    </div>
                </div>

                <!-- 3) Soil & Ground -->
                <h5 class="text-md font-semibold text-gray-800 mb-2">Soil &amp; Ground</h5>
                <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6">
                    <div>
                        <label for="survey-soil-type" class="block text-sm font-medium text-gray-700">Soil Type</label>
                        <select id="survey-soil-type" name="soilType"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Clay</option>
                            <option>Loam</option>
                            <option>Sand</option>
                            <option>Chalk</option>
                            <option>Peat</option>
                            <option>Mixed / Unknown</option>
                        </select>
                    </div>
                    <div>
                        <label for="survey-ground-condition" class="block text-sm font-medium text-gray-700">Ground Condition</label>
                        <select id="survey-ground-condition" name="groundCondition"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Dry</option>
                            <option>Damp</option>
                            <option>Wet</option>
                            <option>Waterlogged</option>
                            <option>Frozen</option>
                        </select>
                    </div>
                    <div>
                        <label for="survey-mineralisation-level" class="block text-sm font-medium text-gray-700">Mineralisation</label>
                        <select id="survey-mineralisation-level" name="mineralisationLevel"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Low</option>
                            <option>Medium</option>
                            <option>High</option>
                            <option>Unknown</option>
                        </select>
                    </div>
                </div>

                <!-- 4) Environment -->
                <h5 class="text-md font-semibold text-gray-800 mb-2">Environment</h5>
                <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6">
                    <div>
                        <label for="survey-weather" class="block text-sm font-medium text-gray-700">Weather</label>
                        <select id="survey-weather" name="weather"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Sunny</option>
                            <option>Overcast</option>
                            <option>Rain</option>
                            <option>Windy</option>
                            <option>Mixed</option>
                        </select>
                    </div>
                    <div>
                        <label for="survey-recent-rain" class="block text-sm font-medium text-gray-700">Recent Rain</label>
                        <select id="survey-recent-rain" name="recentRain"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>None</option>
                            <option>Light</option>
                            <option>Heavy (24–48h)</option>
                        </select>
                    </div>
                    <div>
                        <label for="survey-temperature" class="block text-sm font-medium text-gray-700">Temperature (approx.)</label>
                        <input type="text" id="survey-temperature" name="temperature"
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                               placeholder="e.g. 8°C" />
                    </div>
                </div>

                <!-- 5) Intent & Context -->
                <h5 class="text-md font-semibold text-gray-800 mb-2">Intent &amp; Context</h5>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Purpose of Survey (multi-select)</label>
                        <div class="space-y-1 text-sm text-gray-700">
                            <label class="flex items-center gap-2"><input type="checkbox" name="purpose" value="General detecting"> <span>General detecting</span></label>
                            <label class="flex items-center gap-2"><input type="checkbox" name="purpose" value="Coin shooting"> <span>Coin shooting</span></label>
                            <label class="flex items-center gap-2"><input type="checkbox" name="purpose" value="Relic hunting"> <span>Relic hunting</span></label>
                            <label class="flex items-center gap-2"><input type="checkbox" name="purpose" value="Beach recovery"> <span>Beach recovery</span></label>
                            <label class="flex items-center gap-2"><input type="checkbox" name="purpose" value="Scouting / Recon"> <span>Scouting / Recon</span></label>
                            <label class="flex items-center gap-2"><input type="checkbox" name="purpose" value="Follow-up visit"> <span>Follow-up visit</span></label>
                        </div>
                    </div>
                    <div>
                        <label for="survey-expected-period" class="block text-sm font-medium text-gray-700">Expected Period</label>
                        <select id="survey-expected-period" name="expectedPeriod"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Roman</option>
                            <option>Medieval</option>
                            <option>Post-Medieval</option>
                            <option>Modern</option>
                            <option>Unknown / Mixed</option>
                        </select>
                    </div>
                </div>

                <!-- 6) Access & Practical -->
                <h5 class="text-md font-semibold text-gray-800 mb-2">Access &amp; Practical</h5>
                <div class="mb-4">
                    <label for="survey-access-notes" class="block text-sm font-medium text-gray-700">Access Notes</label>
                    <textarea id="survey-access-notes" name="accessNotes" rows="2"
                              class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                              placeholder="Parking, gates, paths, tides, livestock..."></textarea>
                </div>

                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Hazards / Warnings (multi-select)</label>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-1 text-sm text-gray-700">
                        <label class="flex items-center gap-2"><input type="checkbox" name="hazards" value="Livestock"> <span>Livestock</span></label>
                        <label class="flex items-center gap-2"><input type="checkbox" name="hazards" value="Barbed wire"> <span>Barbed wire</span></label>
                        <label class="flex items-center gap-2"><input type="checkbox" name="hazards" value="Glass"> <span>Glass</span></label>
                        <label class="flex items-center gap-2"><input type="checkbox" name="hazards" value="Steep slopes"> <span>Steep slopes</span></label>
                        <label class="flex items-center gap-2"><input type="checkbox" name="hazards" value="Tides"> <span>Tides</span></label>
                        <label class="flex items-center gap-2"><input type="checkbox" name="hazards" value="None"> <span>None</span></label>
                    </div>
                </div>

                <!-- 7) Outcome Summary -->
                <h5 class="text-md font-semibold text-gray-800 mb-2">Outcome Summary</h5>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="survey-overall-productivity" class="block text-sm font-medium text-gray-700">Overall Productivity</label>
                        <select id="survey-overall-productivity" name="overallProductivity"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Poor</option>
                            <option>Fair</option>
                            <option>Good</option>
                            <option>Excellent</option>
                        </select>
                    </div>
                    <div>
                        <label for="survey-would-detect-again" class="block text-sm font-medium text-gray-700">Would Detect Again?</label>
                        <select id="survey-would-detect-again" name="wouldDetectAgain"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Yes</option>
                            <option>No</option>
                            <option>Maybe</option>
                        </select>
                    </div>
                </div>

                <div class="mb-2">
                    <label for="survey-observations" class="block text-sm font-medium text-gray-700">General Notes / Observations</label>
                    <textarea id="survey-observations" name="surveyObservations" rows="3"
                              class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                              placeholder="Anything useful you noticed..."></textarea>
                </div>
            </div>
                            <!-- Survey photo (optional) -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700">
                    Survey Photo (optional)
                </label>
                <p id="new-survey-photo-status" class="text-xs text-gray-500 mt-1">
                    No photo captured yet.
                </p>

                <div
                    id="new-survey-photo-preview-wrapper"
                    class="mt-2 hidden"
                >
                    <img
                        id="new-survey-photo-preview"
                        alt="Survey photo preview"
                        class="w-full max-h-48 object-cover rounded-lg border border-gray-200"
                    />
                </div>

                <input
                    type="hidden"
                    id="new-survey-photo-data"
                    name="surveyPhotoData"
                >

                <input
                type="file"
                id="new-survey-photo-input"
                accept="image/*"
                class="hidden"
                onchange="handleNewSurveyPhotoSelected(event)">


                <button
                    type="button"
                    onclick="triggerNewSurveyPhotoInput()"
                    class="mt-3 inline-flex items-center px-4 py-2 border border-gray-300 rounded-lg shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-100"
                >
                    <i class="fas fa-camera mr-2"></i>
                    Take / Choose Photo
                </button>
            </div>

                <div class="flex justify-end space-x-3 mt-6">
                    <button type="button" onclick="closeNewSurveyModal()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                    <button type="submit" class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
                            style="background-color: rgb(var(--color-secondary));">
                        Create & Open
                    </button>
                </div>
            </form>
        </div>
    </div>

<!-- Edit Track Modal -->
<div id="edit-track-modal" class="modal">
  <div class="modal-content bg-white p-6 shadow-2xl">
    <h3 id="edit-track-title" class="text-xl font-bold text-primary mb-4">
      Edit Track
    </h3>

    <form id="edit-track-form">
      <input type="hidden" id="edit-track-id" name="trackId" />

      <div class="mb-4">
        <label for="edit-track-name" class="block text-sm font-medium text-gray-700">
          Track Name *
        </label>
        <input
          type="text"
          id="edit-track-name"
          name="trackName"
          required
          class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
          placeholder="e.g., Foreshore sweep"
        />
      </div>

      <div class="mb-4">
        <label for="edit-track-description" class="block text-sm font-medium text-gray-700">
          Description (optional)
        </label>
        <textarea
          id="edit-track-description"
          name="trackDescription"
          rows="3"
          class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
          placeholder="e.g., Started at car park, worked north along the dunes…"
        ></textarea>
      </div>

      <div class="flex justify-end space-x-3 mt-6">
        <button
          type="button"
          onclick="closeEditTrackModal()"
          class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
        >
          Cancel
        </button>

        <button
          type="submit"
          class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
          style="background-color: rgb(var(--color-secondary));"
        >
          Save Track
        </button>
      </div>
    </form>
  </div>
</div>
    

<div id="edit-survey-modal" class="modal">
    <div class="modal-content bg-white p-6 shadow-2xl">
        <h3 class="text-xl font-bold text-primary mb-4">Edit Open Survey</h3>
        <form id="edit-survey-form">
            <input type="hidden" id="edit-survey-id" name="surveyId">

            <div class="mb-4">
                <label for="edit-survey-name" class="block text-sm font-medium text-gray-700">
                    Survey Name *
                </label>
                <input
                    type="text"
                    id="edit-survey-name"
                    name="surveyName"
                    required
                    class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                >
            </div>

            <div class="mb-4">
                <label for="edit-survey-description" class="block text-sm font-medium text-gray-700">
                    Description / Location
                </label>
                <textarea
                    id="edit-survey-description"
                    name="surveyDescription"
                    rows="3"
                    class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                ></textarea>
            </div>


            <!-- Additional Survey Details (all optional) -->
            <div class="mt-6 border-t pt-4">
                <h4 class="text-lg font-semibold text-gray-800 mb-3">Permission &amp; Site Details (optional)</h4>

                <!-- 1) Permission & Legality -->
                <div class="mb-4">
                    <label for="edit-survey-permission-from" class="block text-sm font-medium text-gray-700">Permission From</label>
                    <input type="text" id="edit-survey-permission-from" name="permissionFrom"
                           class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                           placeholder="e.g. Farmer Smith, National Trust, Council" />
                </div>

                <div class="mb-4">
                    <label for="edit-survey-permission-type" class="block text-sm font-medium text-gray-700">Permission Type</label>
                    <select id="edit-survey-permission-type" name="permissionType"
                            class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                        <option value="">(blank)</option>
                        <option>Written</option>
                        <option>Verbal</option>
                        <option>Club / Rally</option>
                        <option>Open access</option>
                    </select>
                </div>

                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="edit-survey-permission-date-granted" class="block text-sm font-medium text-gray-700">Permission Date Granted</label>
                        <input type="text" id="edit-survey-permission-date-granted" name="permissionDateGranted"
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary" placeholder="dd/mm/yy">
                    </div>
                    <div>
                        <label for="edit-survey-permission-expiry" class="block text-sm font-medium text-gray-700">Permission Expiry / Review Date</label>
                        <input type="text" id="edit-survey-permission-expiry" name="permissionExpiry"
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary" placeholder="dd/mm/yy">
                    </div>
                </div>

                <div class="mb-6">
                    <label for="edit-survey-permission-notes" class="block text-sm font-medium text-gray-700">Permission Notes</label>
                    <textarea id="edit-survey-permission-notes" name="permissionNotes" rows="2"
                              class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                              placeholder="e.g. No hedgerows, fill holes, pasture only..."></textarea>
                </div>

                <!-- 2) Area / Site Type -->
                <h5 class="text-md font-semibold text-gray-800 mb-2">Area / Site</h5>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-6">
                    <div>
                        <label for="edit-survey-area-type" class="block text-sm font-medium text-gray-700">Type of Area</label>
                        <select id="edit-survey-area-type" name="areaType"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Field (Pasture)</option>
                            <option>Field (Ploughed)</option>
                            <option>Beach (Dry)</option>
                            <option>Beach (Wet / Tidal)</option>
                            <option>Woods</option>
                            <option>Park</option>
                            <option>Moor / Heath</option>
                            <option>Riverbank / Foreshore</option>
                            <option>Other</option>
                        </select>
                    </div>
                    <div>
                        <label for="edit-survey-land-use-current" class="block text-sm font-medium text-gray-700">Land Use (Current)</label>
                        <select id="edit-survey-land-use-current" name="landUseCurrent"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Agricultural</option>
                            <option>Recreational</option>
                            <option>Woodland</option>
                            <option>Coastal</option>
                            <option>Urban fringe</option>
                        </select>
                    </div>
                </div>

                <!-- 3) Soil & Ground -->
                <h5 class="text-md font-semibold text-gray-800 mb-2">Soil &amp; Ground</h5>
                <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6">
                    <div>
                        <label for="edit-survey-soil-type" class="block text-sm font-medium text-gray-700">Soil Type</label>
                        <select id="edit-survey-soil-type" name="soilType"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Clay</option>
                            <option>Loam</option>
                            <option>Sand</option>
                            <option>Chalk</option>
                            <option>Peat</option>
                            <option>Mixed / Unknown</option>
                        </select>
                    </div>
                    <div>
                        <label for="edit-survey-ground-condition" class="block text-sm font-medium text-gray-700">Ground Condition</label>
                        <select id="edit-survey-ground-condition" name="groundCondition"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Dry</option>
                            <option>Damp</option>
                            <option>Wet</option>
                            <option>Waterlogged</option>
                            <option>Frozen</option>
                        </select>
                    </div>
                    <div>
                        <label for="edit-survey-mineralisation-level" class="block text-sm font-medium text-gray-700">Mineralisation</label>
                        <select id="edit-survey-mineralisation-level" name="mineralisationLevel"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Low</option>
                            <option>Medium</option>
                            <option>High</option>
                            <option>Unknown</option>
                        </select>
                    </div>
                </div>

                <!-- 4) Environment -->
                <h5 class="text-md font-semibold text-gray-800 mb-2">Environment</h5>
                <div class="grid grid-cols-1 sm:grid-cols-3 gap-4 mb-6">
                    <div>
                        <label for="edit-survey-weather" class="block text-sm font-medium text-gray-700">Weather</label>
                        <select id="edit-survey-weather" name="weather"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Sunny</option>
                            <option>Overcast</option>
                            <option>Rain</option>
                            <option>Windy</option>
                            <option>Mixed</option>
                        </select>
                    </div>
                    <div>
                        <label for="edit-survey-recent-rain" class="block text-sm font-medium text-gray-700">Recent Rain</label>
                        <select id="edit-survey-recent-rain" name="recentRain"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>None</option>
                            <option>Light</option>
                            <option>Heavy (24–48h)</option>
                        </select>
                    </div>
                    <div>
                        <label for="edit-survey-temperature" class="block text-sm font-medium text-gray-700">Temperature (approx.)</label>
                        <input type="text" id="edit-survey-temperature" name="temperature"
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                               placeholder="e.g. 8°C" />
                    </div>
                </div>

                <!-- 5) Intent & Context -->
                <h5 class="text-md font-semibold text-gray-800 mb-2">Intent &amp; Context</h5>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label class="block text-sm font-medium text-gray-700 mb-1">Purpose of Survey (multi-select)</label>
                        <div class="space-y-1 text-sm text-gray-700">
                            <label class="flex items-center gap-2"><input type="checkbox" name="purpose" value="General detecting"> <span>General detecting</span></label>
                            <label class="flex items-center gap-2"><input type="checkbox" name="purpose" value="Coin shooting"> <span>Coin shooting</span></label>
                            <label class="flex items-center gap-2"><input type="checkbox" name="purpose" value="Relic hunting"> <span>Relic hunting</span></label>
                            <label class="flex items-center gap-2"><input type="checkbox" name="purpose" value="Beach recovery"> <span>Beach recovery</span></label>
                            <label class="flex items-center gap-2"><input type="checkbox" name="purpose" value="Scouting / Recon"> <span>Scouting / Recon</span></label>
                            <label class="flex items-center gap-2"><input type="checkbox" name="purpose" value="Follow-up visit"> <span>Follow-up visit</span></label>
                        </div>
                    </div>
                    <div>
                        <label for="edit-survey-expected-period" class="block text-sm font-medium text-gray-700">Expected Period</label>
                        <select id="edit-survey-expected-period" name="expectedPeriod"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Roman</option>
                            <option>Medieval</option>
                            <option>Post-Medieval</option>
                            <option>Modern</option>
                            <option>Unknown / Mixed</option>
                        </select>
                    </div>
                </div>

                <!-- 6) Access & Practical -->
                <h5 class="text-md font-semibold text-gray-800 mb-2">Access &amp; Practical</h5>
                <div class="mb-4">
                    <label for="edit-survey-access-notes" class="block text-sm font-medium text-gray-700">Access Notes</label>
                    <textarea id="edit-survey-access-notes" name="accessNotes" rows="2"
                              class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                              placeholder="Parking, gates, paths, tides, livestock..."></textarea>
                </div>

                <div class="mb-6">
                    <label class="block text-sm font-medium text-gray-700 mb-1">Hazards / Warnings (multi-select)</label>
                    <div class="grid grid-cols-1 sm:grid-cols-2 gap-1 text-sm text-gray-700">
                        <label class="flex items-center gap-2"><input type="checkbox" name="hazards" value="Livestock"> <span>Livestock</span></label>
                        <label class="flex items-center gap-2"><input type="checkbox" name="hazards" value="Barbed wire"> <span>Barbed wire</span></label>
                        <label class="flex items-center gap-2"><input type="checkbox" name="hazards" value="Glass"> <span>Glass</span></label>
                        <label class="flex items-center gap-2"><input type="checkbox" name="hazards" value="Steep slopes"> <span>Steep slopes</span></label>
                        <label class="flex items-center gap-2"><input type="checkbox" name="hazards" value="Tides"> <span>Tides</span></label>
                        <label class="flex items-center gap-2"><input type="checkbox" name="hazards" value="None"> <span>None</span></label>
                    </div>
                </div>

                <!-- 7) Outcome Summary -->
                <h5 class="text-md font-semibold text-gray-800 mb-2">Outcome Summary</h5>
                <div class="grid grid-cols-1 sm:grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="edit-survey-overall-productivity" class="block text-sm font-medium text-gray-700">Overall Productivity</label>
                        <select id="edit-survey-overall-productivity" name="overallProductivity"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Poor</option>
                            <option>Fair</option>
                            <option>Good</option>
                            <option>Excellent</option>
                        </select>
                    </div>
                    <div>
                        <label for="edit-survey-would-detect-again" class="block text-sm font-medium text-gray-700">Would Detect Again?</label>
                        <select id="edit-survey-would-detect-again" name="wouldDetectAgain"
                                class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                            <option value="">(blank)</option>
                            <option>Yes</option>
                            <option>No</option>
                            <option>Maybe</option>
                        </select>
                    </div>
                </div>

                <div class="mb-2">
                    <label for="edit-survey-observations" class="block text-sm font-medium text-gray-700">General Notes / Observations</label>
                    <textarea id="edit-survey-observations" name="surveyObservations" rows="3"
                              class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                              placeholder="Anything useful you noticed..."></textarea>
                </div>
            </div>
            <!-- Survey Photo -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700">
                    Survey Photo (optional)
                </label>
                <p id="edit-survey-photo-status" class="text-xs text-gray-500 mt-1">
                    No photo captured yet.
                </p>

                <div
                    id="edit-survey-photo-preview-wrapper"
                    class="mt-2 hidden"
                >
                    <img
                        id="edit-survey-photo-preview"
                        alt="Survey photo preview"
                        class="w-full max-h-48 object-cover rounded-lg border border-gray-200"
                    />
                </div>

                <input
                    type="hidden"
                    id="edit-survey-photo-data"
                    name="surveyPhotoData"
                >

                <input
                type="file"
                id="edit-survey-photo-input"
                accept="image/*"
                class="hidden"
                onchange="handleEditSurveyPhotoSelected(event)"
                >


                <button
                    type="button"
                    onclick="triggerEditSurveyPhotoInput()"
                    class="mt-3 inline-flex items-center px-4 py-2 border border-gray-300 rounded-lg shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-100"
                >
                    <i class="fas fa-camera mr-2"></i>
                    Take / Choose Photo
                </button>
            </div>

            <div class="flex justify-end space-x-3 mt-6">
                <button
                    type="button"
                    onclick="closeEditSurveyModal()"
                    class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                >
                    Cancel
                </button>
                <button
                    type="submit"
                    class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
                    style="background-color: rgb(var(--color-secondary));"
                >
                    Save Changes
                </button>
            </div>
        </form>
    </div>
</div>
<!-- Edit Find Modal (now matches Target modal structure) -->
<div id="edit-find-modal" class="modal">
  <div class="modal-content bg-white p-6 shadow-2xl">

    <!-- Header with close button -->
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-xl font-bold text-primary">Edit Find</h3>
      <p id="edit-find-logged-datetime"
         class="text-xs text-gray-500 mt-1">
         Logged: <span class="font-semibold text-gray-700">Not recorded</span>
      </p>

      <button
        type="button"
        class="text-gray-400 hover:text-gray-600 text-xl leading-none"
        aria-label="Close"
        onclick="closeEditFindModal()">
        &times;
      </button>
    </div>

    <form id="edit-find-form" class="space-y-4">
      <!-- Hidden ID -->
      <input type="hidden" id="edit-find-id" name="findId">

           <!-- Description (now a textarea) -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-description">
          Description / Find Name
        </label>
        <textarea
          id="edit-find-description"
          name="findDescription"
          rows="4"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary"
          required></textarea>
      </div>

      <!-- Type -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-type">
          Type
        </label>
        <select
          id="edit-find-type"
          name="findType"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
          <option value="Unidentified">Unidentified</option>
          <option value="Iron Junk">Iron JUnk</option>
          <option value="Modern Junk">Modern Junk</option>        
          <option value="Button">Button</option>
          <option value="Coin">Coin</option>
          <option value="Jewellery">Jewellery</option>
          <option value="Relic">Relic</option>
          <option value="Something else">Something else</option>
        </select>
      </div>

      <!-- Identification -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-identification">
          Identification
        </label>
        <input
          type="text"
          id="edit-find-identification"
          name="findIdentification"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary"
          placeholder="e.g. George III halfpenny">
      </div>

      <!-- Material + Condition -->
      <div class="grid grid-cols-2 gap-3">
        <div>
          <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-material">Material</label>
          <select
            id="edit-find-material"
            name="findMaterial"
            class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
            <option value="">(blank)</option>
            <option value="Copper alloy">Copper alloy</option>
            <option value="Silver">Silver</option>
            <option value="Gold">Gold</option>
            <option value="Lead">Lead</option>
            <option value="Iron">Iron</option>
            <option value="Aluminium">Aluminium</option>
            <option value="Mixed">Mixed</option>
            <option value="Unknown">Unknown</option>
          </select>
        </div>
        <div>
          <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-condition">Condition</label>
          <select
            id="edit-find-condition"
            name="findCondition"
            class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
            <option value="">(blank)</option>
            <option value="Poor">Poor</option>
            <option value="Fair">Fair</option>
            <option value="Good">Good</option>
            <option value="Excellent">Excellent</option>
          </select>
        </div>
      </div>

      <!-- Period/Date -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-period">
          Period / Date
        </label>
        <input
          type="text"
          id="edit-find-period"
          name="findPeriod"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary"
          placeholder="e.g. Roman / Medieval / Victorian">
      </div>

      <!-- Weight + Dimensions -->
      <div class="grid grid-cols-2 gap-3">
        <div>
          <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-weight">Weight (g)</label>
          <input
            type="number"
            step="0.1"
            inputmode="decimal"
            id="edit-find-weight"
            name="findWeightG"
            class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary"
            placeholder="optional">
        </div>
        <div>
          <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-dimensions">Dimensions (mm)</label>
          <input
            type="text"
            id="edit-find-dimensions"
            name="findDimensionsMm"
            class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary"
            placeholder="e.g. Ø 18 mm or 22×19 mm">
        </div>
      </div>

      <!-- Where kept + Disposition -->
      <div class="grid grid-cols-2 gap-3">
        <div>
          <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-where-kept">Where kept</label>
          <input
            type="text"
            id="edit-find-where-kept"
            name="findWhereKept"
            class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary"
            placeholder="Finds box / coin tray / returned...">
        </div>
        <div>
          <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-disposition">Disposition</label>
          <select
            id="edit-find-disposition"
            name="findDisposition"
            class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
            <option value="">(blank)</option>
            <option value="Kept">Kept</option>
            <option value="Returned">Returned</option>
            <option value="Reported">Reported</option>
            <option value="Discarded">Discarded</option>
          </select>
        </div>
      </div>

      <!-- Possible treasure -->
      <div class="flex items-center gap-2">
        <input type="checkbox" id="edit-find-possible-treasure" name="findPossibleTreasure" class="h-4 w-4">
        <label class="text-sm text-gray-700 select-none" for="edit-find-possible-treasure">Possible treasure</label>
      </div>

      <!-- VDI + Depth -->
      <div class="grid grid-cols-2 gap-3">
        <div>
          <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-vdi">
            Target ID
          </label>
          <input
            type="text"
            id="edit-find-vdi"
            name="findVDI"
            class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
        </div>
        <div>
          <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-depth">
            Depth
          </label>
          <input
            type="text"
            id="edit-find-depth"
            name="findDepth"
            class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
        </div>
      </div>

      <!-- Coordinates -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-coords">
          Coordinates
        </label>
        <input
          type="text"
          id="edit-find-coords"
          name="findCoords"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
      </div>

      <!-- Accuracy -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-accuracy">
          Accuracy
        </label>
        <input
          type="text"
          id="edit-find-accuracy"
          name="findAccuracy"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
      </div>

      <!-- NEW: Find photograph controls -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1">
          Find Photograph
        </label>

        <!-- Hidden file input (camera / gallery) -->
       <input
  type="file"
  id="edit-find-photo-input"
  accept="image/*;capture=camera"
  multiple
  class="hidden"
  onchange="handleEditFindPhotoSelected(event)">

        <!-- Hidden field to store the Base64 photo data -->
        <input
          type="hidden"
          id="edit-find-photo-data"
          name="findPhotoData">

        <div class="flex items-center space-x-3 mt-1">
          <button
            type="button"
            class="px-3 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-sm font-semibold"
            onclick="triggerEditFindPhotoInput()">
            <i class="fas fa-camera mr-1"></i> Take / Choose Photo
          </button>
          <span id="edit-find-photo-status" class="text-xs text-gray-500">
            No photo captured yet.
          </span>
        </div>

        <div id="edit-find-photo-preview-wrapper" class="mt-2 hidden flex justify-center">
          <img
            id="edit-find-photo-preview"
            class="w-11/12 h-auto rounded-md border border-gray-300 object-cover"
            alt="Find photo preview">
        </div>
      </div>
      <!-- END NEW: Find photograph controls -->

      <!-- Footer buttons -->
      <div class="pt-2 flex justify-end gap-2">
        <button
          type="button"
          id="cancel-edit-find-btn"
          class="px-3 py-1 rounded-md border border-gray-300 text-gray-700 hover:bg-gray-100"
          onclick="closeEditFindModal()">
          Cancel
        </button>
        <button
          type="submit"
          class="px-4 py-2 rounded-md bg-green-600 text-white text-sm font-semibold hover:bg-green-700 transition">
          Save changes
        </button>
      </div>
    </form>
  </div>
</div>
    
    <div id="new-target-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 class="text-xl font-bold text-primary mb-4">Log New Target</h3>
            <form id="new-target-form">
    <!-- Which survey this target belongs to -->
    <input type="hidden" id="new-target-survey-id" name="targetSurveyId" />

    <div id="target-survey-display"
         class="bg-gray-100 p-2 rounded-md mb-4 text-sm font-semibold text-gray-700">
        Logging for: 
        <span id="current-target-survey-name" class="text-primary">Loading...</span>
    </div>

    <div class="grid grid-cols-2 gap-4">
        <!-- Description -->
        <div class="mb-4 col-span-2">
            <label for="target-description"
                   class="block text-sm font-medium text-gray-700">
                Description / Find Name *
            </label>
            <input type="text"
                   id="target-description"
                   name="targetDescription"
                   required
                   class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2
                          focus:ring-primary focus:border-primary">
        </div>

        <!-- VDI -->
        <div class="mb-4">
            <label for="target-vdi"
                   class="block text-sm font-medium text-gray-700">
                Target ID
            </label>
            <input type="text"
                   id="target-vdi"
                   name="targetVDI"
                   placeholder="e.g., 28"
                   class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2
                          focus:ring-primary focus:border-primary">
        </div>

        <!-- Depth -->
        <div class="mb-4">
            <label for="target-depth"
                   class="block text-sm font-medium text-gray-700">
                Depth
            </label>
            <input type="text"
                   id="target-depth"
                   name="targetDepth"
                   placeholder="e.g., 4 inches"
                   class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2
                          focus:ring-primary focus:border-primary">
        </div>

        <!-- Type -->
        <div class="mb-4">
            <label for="target-type"
                   class="block text-sm font-medium text-gray-700">
                Type
            </label>
            <select id="target-type"
                    name="targetType"
                    class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2
                           focus:ring-primary focus:border-primary">
        <option value="Unidentified" selected>Unidentified</option>
        <option value="Iron Junk">Iron Junk</option>
        <option value="Modern Junk">Modern Junk</option>
         <option value="Button">Button</option>
         <option value="Coin">Coin</option>
        <option value="Ring">Ring</option>
        <option value="Jewelry">Jewelry</option>
        <option value="Relic">Relic</option>
        <option value="Something else">Something else</option>
            </select>
        </div>

        <!-- GPS + accuracy -->
        <div class="mb-4 col-span-2">
            <label for="target-coords"
                   class="block text-sm font-medium text-gray-700">
                GPS Location
            </label>
            <input type="text"
                   id="target-coords"
                   name="targetCoords"
                   placeholder="Requesting location..."
                   class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2
                          focus:ring-primary focus:border-primary">
            <input type="hidden"
                   id="target-accuracy"
                   name="targetAccuracy">
            <p id="gps-accuracy-display"
               class="text-xs text-gray-600 mt-1">
                Accuracy (Radius): 
                <span class="font-semibold text-red-600">N/A</span>
            </p>
        </div>

        <!-- Photo section (current single-photo UI) -->
        <div class="mb-4 col-span-2">
            <label class="block text-sm font-medium text-gray-700 mb-1">
                Target Photo
            </label>

            <p id="new-target-photo-status"
               class="text-xs text-gray-600 mb-2">
                No photo captured yet.
            </p>

            <div id="new-target-photo-preview-wrapper"
                 class="hidden mb-2">
                <img id="new-target-photo-preview"
                     alt="Target preview"
                     class="w-full max-h-64 object-contain rounded-lg border border-gray-300" />
            </div>

            <input type="hidden"
                   id="target-photo-data"
                   name="targetPhotoData">

            <input type="file"
                   id="new-target-photo-input"
                   accept="image/*"
                   capture="environment"
                   class="hidden"
                   onchange="handleNewTargetPhotoSelected(event)">

            <button type="button"
                    class="px-3 py-2 text-sm font-semibold rounded-lg shadow
                           text-white"
                    style="background-color: rgb(var(--color-secondary));"
                    onclick="triggerNewTargetPhotoInput()">
                Take / Choose Photo
            </button>
        </div>
    </div>

    <!-- Button bar: force white background -->
    <div class="mt-6 pt-4 flex justify-end space-x-3 bg-white">
        <button type="button"
                onclick="closeNewTargetModal()"
                class="px-4 py-2 text-sm font-semibold bg-gray-200 text-gray-700 rounded-lg
                       hover:bg-gray-300">
            Cancel
        </button>
        <button type="submit"
                class="px-4 py-2 text-sm font-semibold rounded-lg shadow-md hover:opacity-90
                       transition duration-150 text-white"
                style="background-color: rgb(var(--color-secondary));">
            Log Target
        </button>
    </div>
</form>

        </div>
    </div>
    
    <div id="edit-target-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 class="text-xl font-bold text-primary mb-4">Edit Target Details</h3>
            <form id="edit-target-form">
                <input type="hidden" id="edit-target-id" name="targetId">
                <input type="hidden" id="edit-survey-id" name="surveyId">

                <div id="edit-target-survey-display" class="bg-gray-100 p-2 rounded-md mb-4 text-sm font-semibold text-gray-700">
                    Editing target in: <span id="current-edit-survey-name" class="text-primary">Loading...</span>
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <div class="mb-4 col-span-2">
                        <label for="edit-target-description" class="block text-sm font-medium text-gray-700">Description / Find Name *</label>
                        <input type="text" id="edit-target-description" name="targetDescription" required 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                    <div class="mb-4">
                        <label for="edit-target-vdi" class="block text-sm font-medium text-gray-700">Target ID</label>
                        <input type="text" id="edit-target-vdi" name="targetVDI" placeholder="e.g., 28" 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                    <div class="mb-4">
                        <label for="edit-target-depth" class="block text-sm font-medium text-gray-700">Depth</label>
                        <input type="text" id="edit-target-depth" name="targetDepth" placeholder="e.g., 6 inches"
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
 <div class="mb-4 col-span-2">
    <label for="edit-target-type" class="block text-sm font-medium text-gray-700">Type of Find *</label>
    <select id="edit-target-type" name="targetType" required
            class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary bg-white">
      <option value="Unidentified" selected>Unidentified</option>
        <option value="Iron Junk">Iron Junk</option>
        <option value="Modern Junk">Modern Junk</option>
         <option value="Button">Button</option>
         <option value="Coin">Coin</option>
        <option value="Ring">Ring</option>
        <option value="Jewelry">Jewelry</option>
        <option value="Relic">Relic</option>
        <option value="Something else">Something else</option>
            </select>
     
</div>
<div class="mb-4 col-span-2">
    <label class="block text-sm font-medium text-gray-700 mb-1">
        Target Photographs
    </label>

    <input
        type="file"
        id="edit-target-photo-input"
        accept="image/*;capture=camera"
        class="hidden"
        multiple
        onchange="handleEditTargetPhotoSelected(event)"
    >

    <input
        type="hidden"
        id="edit-target-photo-data"
        name="targetPhotoData"
    >

    <div class="flex items-center space-x-3">
        <button
            type="button"
            class="px-3 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-sm font-semibold"
            onclick="triggerEditTargetPhotoInput()"
        >
            <i class="fas fa-camera mr-1"></i> Take / Choose Photo(s)
        </button>
        <span id="edit-target-photo-status" class="text-xs text-gray-500">
            No photo captured yet.
        </span>
    </div>

    <!-- Thumbnails (stacked, nearly full width) -->
    <div id="edit-target-photo-preview-wrapper" class="mt-2 hidden w-full"></div>
</div>
                    
<div class="mb-4 col-span-2">
                        <label for="edit-target-coords" class="block text-sm font-medium text-gray-700">GPS Coordinates</label>
                        <input type="text" id="edit-target-coords" name="targetCoords" placeholder="e.g., 50.2568, -5.2345" 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                    <div class="mb-4 col-span-2">
                        <label for="edit-target-accuracy" class="block text-sm font-medium text-gray-700">GPS Accuracy (m)</label>
                        <input type="text" id="edit-target-accuracy" name="targetAccuracy" placeholder="e.g., 5.0" 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                </div>

                <div class="flex justify-end space-x-3 mt-6">
                    <button type="button" onclick="closeEditTargetModal()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                    <button type="submit" class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
                            style="background-color: rgb(var(--color-secondary));">
                        Save Target Changes
                    </button>
                </div>
            </form>
        </div>
    </div>
    
<div id="edit-profile-modal" class="modal">
    <div class="modal-content bg-white p-6 shadow-2xl">
        <h3 class="text-xl font-bold text-primary mb-4">
            Edit Detectorist Profile
        </h3>

        <form id="edit-profile-form">

            <!-- Detectorist name -->
            <div class="mb-4">
                <label for="profile-name" class="block text-sm font-medium text-gray-700">
                    Detectorist Name *
                </label>
                <input
                    type="text"
                    id="profile-name"
                    name="profileName"
                    required
                    class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                >
            </div>

            <!-- NCMD membership number (NEW, optional) -->
            <div class="mb-4">
                <label for="profile-ncmd-number" class="block text-sm font-medium text-gray-700">
                    NCMD Membership Number <span class="text-gray-400">(optional)</span>
                </label>
                <input
                    type="text"
                    id="profile-ncmd-number"
                    name="profileNcmdNumber"
                    placeholder="e.g. 123456"
                    class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                >
            </div>

            <!-- Detector -->
            <div class="mb-4">
                <label for="profile-detector" class="block text-sm font-medium text-gray-700">
                    Detector Used
                </label>
                <input
                    type="text"
                    id="profile-detector"
                    name="profileDetector"
                    class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                >
            </div>

            <div class="flex justify-end space-x-3 mt-6">
                <button
                    type="button"
                    onclick="closeEditProfileModal()"
                    class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                >
                    Cancel
                </button>
                <button
                    type="submit"
                    class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
                    style="background-color: rgb(var(--color-secondary));"
                >
                    Save Changes
                </button>
            </div>

        </form>
    </div>
</div>


    <script>

if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('sw.js')
      .then(reg => {
        console.log('Service Worker registered:', reg.scope);
      })
      .catch(err => {
        console.warn('SW registration failed:', err);
      });
  });
}

        // --- GLOBAL STATE & INITIALIZATION ---
// =====================
//  APP META
// =====================
const APP_NAME = 'Detekta – A Metal Detecting App';
const APP_VERSION = '0.0.0';         // change whenever you publish
const APP_BUILD = '2026-01-14';      // optional, you can keep as a date string

        
// --- GLOBAL STATE & INITIALIZATION ---
let surveys = [];
let finds = [];  // permanent library of Finds
let currentPage = 'Home';
let isMapFullscreen = false;
let targetWatchId = null;
let compassQuickTargetIdDraft = '';

// Map layer toggles (UI checkboxes on Compass/Map page)
// These affect what is DRAWN, but NOT the bounds/auto-zoom calculation.
let showMapTargets = true;
let showMapStakes  = true; // Stakes are targets with VDI -100
let showMapFinds   = true;
let showMapTracks  = true;

// A "Stake" is a target pin whose VDI is -100 (used as a ground marker).
function isStakeTarget(t) {
    if (!t || t.isFind) return false;
    const raw = (t.vdi !== undefined && t.vdi !== null && String(t.vdi).trim() !== '')
        ? t.vdi
        : (t.targetVdi !== undefined && t.targetVdi !== null && String(t.targetVdi).trim() !== '')
            ? t.targetVdi
            : (t.targetVDI !== undefined && t.targetVDI !== null && String(t.targetVDI).trim() !== '')
                ? t.targetVDI
                : '';
    const v = Number(raw);
    return Number.isFinite(v) && v === -100;
}

let showUserPosition = true; // default: show user location on the map

let targetSortMode = 'date'; // 'date' | 'id'

let hasRenderedFirstGpsFix = false;

let navBreadcrumbStartIndex = 0;

let navSession = {
    active: false,
    startLat: null,
    startLon: null,
    targetLat: null,
    targetLon: null,
    path: [],          // array of {lat, lon}
    lastLat: null,
    lastLon: null
};

let lastGpsUiRefreshMs = 0;

// Simple filter state for the Finds page
let findsFilter = {
    query: '',
    type: 'All',
    surveyId: 'All',
    date: 'All'
};

// NEW: holds photos while the Edit Find modal is open
let currentEditFindPhotos = [];

// NEW: holds photos while the New Target modal is open
let currentNewTargetPhotos = [];

// NEW: holds photos while the Edit Target modal is open
let currentEditTargetPhotos = [];

// Shared gallery state
let currentGalleryPhotos = [];
let currentGalleryIndex = 0;
let gallerySwipeInitialized = false;
let galleryTouchStartX = null;

let suppressCompassAutoRefresh = false;


     
let userProfile = {
    name: "New User",
    detector: "Default Machine",
    ncmdNumber: ""   // optional
};
        let userId;

      // --- NEW REAL-TIME LOCATION STATE ---
        let autoRefreshIntervalId = null; 
        let currentUserCoords = null;
        let currentUserAccuracy = null;
        let bestLiveAccuracy = Infinity;
        let liveMapWatchId = null;
        let navigationTargetId = null;
        let isTrackingActive = false;
        

                // --- MOVEMENT HISTORY FOR DIRECTION-OF-TRAVEL GUIDANCE ---
        // Stores recent smoothed GPS positions so we can estimate which way
        // you're walking and give "left / right / ahead" style guidance.
        let movementHistory = [];
        const MOVEMENT_HISTORY_MAX_AGE_MS = 60000;     // keep ~60s of movement
        const MOVEMENT_HISTORY_MAX_LENGTH = 30;        // max number of points
        const MOVEMENT_MIN_DISTANCE_METERS = 2;        // need at least ~2m of motion

// =====================
// PHOTO RESIZE SETTINGS
// =====================
const PHOTO_SETTINGS_KEY = 'geoFindPhotoSettings';

// default = 1000px wide (user can change in Settings)
let photoSettings = {
    maxWidth: 1000
};

// =======================================
//  SAFE PHOTO-DELETION (IndexedDB) HELPERS
// =======================================

// Survey version of openTargetPhotoGallery / openFindPhotoGallery
async function openSurveyPhotoGallery(surveyId) {
    const survey = surveys.find(s => s.id === surveyId);
    if (!survey) {
        showMessage('Survey not found.', 'error');
        return;
    }

    let photos = [];

    if (Array.isArray(survey.photos) && survey.photos.length) {
        const first = survey.photos[0];

        // If these are IndexedDB refs ("idb:..."), load to real URLs
        if (typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(first)) {
            try {
                photos = await loadPhotoUrlsFromRefs(survey.photos);
            } catch (e) {
                console.error('Error loading survey photos from IndexedDB:', e);
                photos = [];
            }
        } else {
            // Old style: already data URLs
            photos = survey.photos.slice();
        }
    } else if (survey.surveyPhotoRef) {
        // Back-compat: single ref
        if (typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(survey.surveyPhotoRef)) {
            try {
                const url = await getPhotoUrlFromRef(survey.surveyPhotoRef);
                if (url) photos = [url];
            } catch (e) {
                console.error('Error loading survey photo ref:', e);
            }
        } else {
            photos = [survey.surveyPhotoRef];
        }
    } else if (survey.surveyPhotoData) {
        // Back-compat: single data url
        photos = [survey.surveyPhotoData];
    }

    if (!photos.length) {
        showMessage('This survey has no photos yet.', 'info');
        return;
    }

    // Uses your existing gallery
    openPhotoGallery(photos, 0);
}

        
function collectIndexedDbPhotoIdsFromRefs(refsOrSingle) {
    const ids = new Set();

    const addRef = (ref) => {
        if (!ref || typeof ref !== 'string') return;
        if (typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(ref)) {
            const id = (typeof parsePhotoRef === 'function') ? parsePhotoRef(ref) : null;
            if (id != null) ids.add(id);
        }
    };

    if (Array.isArray(refsOrSingle)) refsOrSingle.forEach(addRef);
    else addRef(refsOrSingle);

    return ids;
}

function collectIndexedDbPhotoIdsFromTarget(target) {
    const ids = new Set();
    if (!target) return ids;

    if (Array.isArray(target.photos) && target.photos.length) {
        collectIndexedDbPhotoIdsFromRefs(target.photos).forEach(id => ids.add(id));
    }

    if (target.targetPhotoRef) {
        collectIndexedDbPhotoIdsFromRefs(target.targetPhotoRef).forEach(id => ids.add(id));
    }

    // Legacy / older builds (safe no-op if absent)
    if (target.photoRef) {
        collectIndexedDbPhotoIdsFromRefs(target.photoRef).forEach(id => ids.add(id));
    }

    return ids;
}

function collectIndexedDbPhotoIdsFromFind(find) {
    const ids = new Set();
    if (!find) return ids;

    if (Array.isArray(find.photos) && find.photos.length) {
        collectIndexedDbPhotoIdsFromRefs(find.photos).forEach(id => ids.add(id));
    }

    if (find.findPhotoRef) {
        collectIndexedDbPhotoIdsFromRefs(find.findPhotoRef).forEach(id => ids.add(id));
    }

    // Legacy / older builds (safe no-op if absent)
    if (find.photoRef) {
        collectIndexedDbPhotoIdsFromRefs(find.photoRef).forEach(id => ids.add(id));
    }

    // Some older find records may still have targetPhotoRef fields
    if (find.targetPhotoRef) {
        collectIndexedDbPhotoIdsFromRefs(find.targetPhotoRef).forEach(id => ids.add(id));
    }

    return ids;
}

function collectIndexedDbPhotoIdsFromSurvey(survey, { excludeTargetId = null } = {}) {
    const ids = new Set();
    if (!survey) return ids;

    if (survey.surveyPhotoRef) {
        collectIndexedDbPhotoIdsFromRefs(survey.surveyPhotoRef).forEach(id => ids.add(id));
    }

    const targets = Array.isArray(survey.targets) ? survey.targets : [];
    for (const t of targets) {
        if (!t) continue;
        if (excludeTargetId && t.id === excludeTargetId) continue;
        collectIndexedDbPhotoIdsFromTarget(t).forEach(id => ids.add(id));
    }

    return ids;
}

function collectIndexedDbPhotoIdsInUseExcludingTarget(surveyId, targetId) {
    const ids = new Set();

    // Surveys + targets (skip the one target being deleted)
    const allSurveys = Array.isArray(surveys) ? surveys : [];
    for (const s of allSurveys) {
        if (!s) continue;
        const exclude = (s.id === surveyId) ? targetId : null;
        collectIndexedDbPhotoIdsFromSurvey(s, { excludeTargetId: exclude }).forEach(id => ids.add(id));
    }

    // Finds (all of them)
    const allFinds = Array.isArray(finds) ? finds : [];
    for (const f of allFinds) {
        if (!f) continue;
        collectIndexedDbPhotoIdsFromFind(f).forEach(id => ids.add(id));
    }

    return ids;
}

function collectIndexedDbPhotoIdsInUseExcludingFind(findId) {
    const ids = new Set();

    // All surveys + targets
    const allSurveys = Array.isArray(surveys) ? surveys : [];
    for (const s of allSurveys) {
        if (!s) continue;
        collectIndexedDbPhotoIdsFromSurvey(s).forEach(id => ids.add(id));
    }

    // All finds except the one being deleted
    const allFinds = Array.isArray(finds) ? finds : [];
    for (const f of allFinds) {
        if (!f) continue;
        if (f.id === findId) continue;
        collectIndexedDbPhotoIdsFromFind(f).forEach(id => ids.add(id));
    }

    return ids;
}


async function deleteFindPermanently(findId) {
    const idx = Array.isArray(finds)
        ? finds.findIndex(f => f && f.id === findId)
        : -1;

    if (idx < 0) {
        showMessage('Delete failed: find not found.', 'error');
        return false;
    }

    const find = finds[idx];

    // 1) Photos referenced by THIS find
    const idsThisFind = collectIndexedDbPhotoIdsFromFind(find);

    // 2) Photos still used elsewhere
    const idsStillUsedElsewhere = collectIndexedDbPhotoIdsInUseExcludingFind(findId);

    // 3) Delete only those not used elsewhere
    const idsToDelete = [...idsThisFind].filter(id => !idsStillUsedElsewhere.has(id));

    if (idsToDelete.length && typeof deletePhotoBlob === 'function') {
        for (const id of idsToDelete) {
            try {
                await deletePhotoBlob(id);
            } catch (e) {
                console.warn('Failed to delete photo blob id', id, e);
            }
        }
    }

    // 4) Delete the find record
    finds.splice(idx, 1);
    saveFindsToLocalStorage();

    showMessage('Find deleted (including photos).', 'success');
    return true;
}
 /**
 * Extract IndexedDB photo IDs from any mixture of:
 *  - "idb:123" strings
 *  - arrays of refs ["idb:1","idb:2"]
 *  - null/empty/legacy base64 data URLs (ignored)
 */
function collectIndexedDbPhotoIdsFromRefs(refsOrSingle) {
    const ids = new Set();

    const addRef = (ref) => {
        if (!ref || typeof ref !== 'string') return;
        if (typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(ref)) {
            const id = (typeof parsePhotoRef === 'function') ? parsePhotoRef(ref) : null;
            if (id != null) ids.add(id);
        }
    };

    if (Array.isArray(refsOrSingle)) {
        refsOrSingle.forEach(addRef);
    } else {
        addRef(refsOrSingle);
    }

    return ids;
}

/**
 * Collect all IndexedDB photo IDs referenced by a survey + its targets.
 */
function collectIndexedDbPhotoIdsFromSurvey(survey) {
    const ids = new Set();

    if (!survey) return ids;

    // Survey photo
    if (survey.surveyPhotoRef) {
        collectIndexedDbPhotoIdsFromRefs(survey.surveyPhotoRef).forEach(id => ids.add(id));
    }

    // Targets
    const targets = Array.isArray(survey.targets) ? survey.targets : [];
    for (const t of targets) {
        if (!t) continue;

        // Preferred modern structure: t.photos = ["idb:..", ...]
        if (Array.isArray(t.photos) && t.photos.length) {
            collectIndexedDbPhotoIdsFromRefs(t.photos).forEach(id => ids.add(id));
        }

        // Convenience single-ref fields (if present)
        if (t.targetPhotoRef) {
            collectIndexedDbPhotoIdsFromRefs(t.targetPhotoRef).forEach(id => ids.add(id));
        }

        // Legacy fields sometimes used in older builds
        if (t.photoRef) {
            collectIndexedDbPhotoIdsFromRefs(t.photoRef).forEach(id => ids.add(id));
        }
    }

    return ids;
}

/**
 * Collect all IndexedDB photo IDs referenced by a find.
 */
function collectIndexedDbPhotoIdsFromFind(find) {
    const ids = new Set();
    if (!find) return ids;

    // Preferred modern structure
    if (Array.isArray(find.photos) && find.photos.length) {
        collectIndexedDbPhotoIdsFromRefs(find.photos).forEach(id => ids.add(id));
    }

    // Convenience single-ref field (if present)
    if (find.findPhotoRef) {
        collectIndexedDbPhotoIdsFromRefs(find.findPhotoRef).forEach(id => ids.add(id));
    }

    // Legacy fields (rare)
    if (find.photoRef) {
        collectIndexedDbPhotoIdsFromRefs(find.photoRef).forEach(id => ids.add(id));
    }

    return ids;
}

/**
 * Collect all IndexedDB photo IDs used by the entire app,
 * EXCLUDING a given surveyId (and excluding finds linked to that surveyId).
 * This is used to avoid deleting photos that are still referenced elsewhere.
 */
function collectIndexedDbPhotoIdsInUseExcludingSurveyId(excludeSurveyId) {
    const ids = new Set();

    // Other surveys
    const allSurveys = Array.isArray(surveys) ? surveys : [];
    for (const s of allSurveys) {
        if (!s) continue;
        if (s.id === excludeSurveyId) continue;

        collectIndexedDbPhotoIdsFromSurvey(s).forEach(id => ids.add(id));
    }

    // Other finds
    const allFinds = Array.isArray(finds) ? finds : [];
    for (const f of allFinds) {
        if (!f) continue;
        if (f.surveyId === excludeSurveyId) continue;

        collectIndexedDbPhotoIdsFromFind(f).forEach(id => ids.add(id));
    }

    return ids;
}

/**
 * DELETE a survey + its targets + its finds + its IndexedDB photos.
 * Photos are only deleted if they are not referenced by other surveys/finds.
 */
async function deleteSurveyAndAllAssociatedData(surveyId) {
    if (!surveyId) return false;

    const survey = (Array.isArray(surveys) ? surveys : []).find(s => s && s.id === surveyId);
    if (!survey) return false;

    // If deleting the OPEN survey, stop tracking/nav cleanly first
    try {
        if (survey.status === 'Open' && typeof resetLiveTrackingAndRecordingState === 'function') {
            resetLiveTrackingAndRecordingState();
        }
    } catch (_) {}

    // 1) Collect photo IDs referenced by THIS survey + its linked finds
    const idsThisSurvey = new Set();

    collectIndexedDbPhotoIdsFromSurvey(survey).forEach(id => idsThisSurvey.add(id));

    const linkedFinds = (Array.isArray(finds) ? finds : []).filter(f => f && f.surveyId === surveyId);
    for (const f of linkedFinds) {
        collectIndexedDbPhotoIdsFromFind(f).forEach(id => idsThisSurvey.add(id));
    }

    // 2) Collect IDs that are still in use elsewhere (so we don't delete shared photos)
    const idsStillUsedElsewhere = collectIndexedDbPhotoIdsInUseExcludingSurveyId(surveyId);

    // 3) Delete only the photos that are not used elsewhere
    const idsToDelete = [...idsThisSurvey].filter(id => !idsStillUsedElsewhere.has(id));

    if (idsToDelete.length && typeof deletePhotoBlob === 'function') {
        // Best-effort delete: continue even if one fails
        for (const id of idsToDelete) {
            try {
                await deletePhotoBlob(id);
            } catch (e) {
                console.warn('Failed to delete photo blob id', id, e);
            }
        }
    }

    // 4) Remove the survey (targets are inside it, so they go too)
    surveys = (Array.isArray(surveys) ? surveys : []).filter(s => s && s.id !== surveyId);

    // 5) Remove linked finds
    finds = (Array.isArray(finds) ? finds : []).filter(f => f && f.surveyId !== surveyId);

    // 6) Persist
    if (typeof saveSurveysToLocalStorage === 'function') {
        saveSurveysToLocalStorage();
    } else {
        // Fallback: older builds sometimes save separately
        try { localStorage.setItem('geoFindSurveys', JSON.stringify(surveys)); } catch (_) {}
        try { localStorage.setItem('geoFindFinds', JSON.stringify(finds)); } catch (_) {}
    }

    return true;
}
       
async function deleteTargetPermanently(surveyId, targetId) {
    const s = surveys.find(x => x.id === surveyId);
    if (!s || !Array.isArray(s.targets)) {
        showMessage('Delete failed: survey targets not found.', 'error');
        return false;
    }

    const idx = s.targets.findIndex(t => t && t.id === targetId);
    if (idx < 0) {
        showMessage('Delete failed: target not found.', 'error');
        return false;
    }

    const target = s.targets[idx];

    // 1) Photos referenced by THIS target
    const idsThisTarget = collectIndexedDbPhotoIdsFromTarget(target);

    // 2) Photos still used elsewhere (surveys/targets + finds)
    const idsStillUsedElsewhere = collectIndexedDbPhotoIdsInUseExcludingTarget(surveyId, targetId);

    // 3) Delete only those not used elsewhere
    const idsToDelete = [...idsThisTarget].filter(id => !idsStillUsedElsewhere.has(id));

    if (idsToDelete.length && typeof deletePhotoBlob === 'function') {
        for (const id of idsToDelete) {
            try {
                await deletePhotoBlob(id);
            } catch (e) {
                console.warn('Failed to delete photo blob id', id, e);
            }
        }
    }

    // 4) Delete the target record
    s.targets.splice(idx, 1);
    s.dateLastChanged = Date.now();
    saveSurveysToLocalStorage();

    showMessage('Target deleted (including photos).', 'success');
    return true;
}
        
async function purgeDeletedEverywhere() {

    // Try to log somewhere sensible (safe if not found)
    const logBox =
        document.getElementById('export-photo-gallery-log')
        || document.getElementById('import-gpx-log')
        || document.getElementById('export-open-survey-gpx-log')
        || document.getElementById('app-log-box');

    const log = (msg) => {
        console.log('[Purge]', msg);
        if (!logBox) return;
        logBox.value += msg + '\n';
        logBox.scrollTop = logBox.scrollHeight;
    };

    // -----------------------------
    // Helpers (kept inside function)
    // -----------------------------
    const collectIdsFromRefs = (refsOrSingle) => {
        const ids = new Set();

        const addRef = (ref) => {
            if (!ref || typeof ref !== 'string') return;
            if (typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(ref)) {
                const id = (typeof parsePhotoRef === 'function') ? parsePhotoRef(ref) : null;
                if (id != null) ids.add(id);
            }
        };

        if (Array.isArray(refsOrSingle)) refsOrSingle.forEach(addRef);
        else addRef(refsOrSingle);

        return ids;
    };

    const collectIdsFromTarget = (t) => {
        const ids = new Set();
        if (!t) return ids;

        if (Array.isArray(t.photos)) {
            collectIdsFromRefs(t.photos).forEach(id => ids.add(id));
        }
        if (t.targetPhotoRef) {
            collectIdsFromRefs(t.targetPhotoRef).forEach(id => ids.add(id));
        }
        if (t.photoRef) { // legacy safety
            collectIdsFromRefs(t.photoRef).forEach(id => ids.add(id));
        }

        return ids;
    };

    const collectIdsFromFind = (f) => {
        const ids = new Set();
        if (!f) return ids;

        if (Array.isArray(f.photos)) {
            collectIdsFromRefs(f.photos).forEach(id => ids.add(id));
        }
        if (f.findPhotoRef) {
            collectIdsFromRefs(f.findPhotoRef).forEach(id => ids.add(id));
        }
        if (f.photoRef) { // legacy safety
            collectIdsFromRefs(f.photoRef).forEach(id => ids.add(id));
        }
        if (f.targetPhotoRef) { // legacy safety
            collectIdsFromRefs(f.targetPhotoRef).forEach(id => ids.add(id));
        }

        return ids;
    };

    const collectIdsFromSurvey = (s) => {
        const ids = new Set();
        if (!s) return ids;

        if (s.surveyPhotoRef) {
            collectIdsFromRefs(s.surveyPhotoRef).forEach(id => ids.add(id));
        }

        const targets = Array.isArray(s.targets) ? s.targets : [];
        for (const t of targets) {
            collectIdsFromTarget(t).forEach(id => ids.add(id));
        }

        return ids;
    };

    const collectAllReferencedPhotoIds = () => {
        const ids = new Set();

        const ss = Array.isArray(surveys) ? surveys : [];
        const ff = Array.isArray(finds) ? finds : [];

        for (const s of ss) collectIdsFromSurvey(s).forEach(id => ids.add(id));
        for (const f of ff) collectIdsFromFind(f).forEach(id => ids.add(id));

        return ids;
    };

    // -----------------------------
    // 1) Purge deleted records
    // -----------------------------
    try {
        log('Purging deleted surveys / targets / finds...');

        const beforeSurveys = Array.isArray(surveys) ? surveys.length : 0;
        const beforeFinds   = Array.isArray(finds) ? finds.length : 0;

        // Purge deleted surveys (entire survey removed)
        surveys = (Array.isArray(surveys) ? surveys : []).filter(s => s && s.deleted !== true);

        // Purge deleted targets inside remaining surveys
        let purgedTargetsCount = 0;
        for (const s of surveys) {
            if (!s || !Array.isArray(s.targets)) continue;
            const before = s.targets.length;
            s.targets = s.targets.filter(t => t && t.deleted !== true);
            purgedTargetsCount += (before - s.targets.length);
        }

        // Purge deleted finds
        finds = (Array.isArray(finds) ? finds : []).filter(f => f && f.deleted !== true);

        const afterSurveys = surveys.length;
        const afterFinds   = finds.length;

        log(`Surveys purged: ${beforeSurveys - afterSurveys}`);
        log(`Targets purged: ${purgedTargetsCount}`);
        log(`Finds purged:   ${beforeFinds - afterFinds}`);

        // Persist
        if (typeof saveSurveysToLocalStorage === 'function') {
            saveSurveysToLocalStorage();
        } else {
            try { localStorage.setItem('geoFindSurveys', JSON.stringify(surveys)); } catch (_) {}
        }

        if (typeof saveFindsToLocalStorage === 'function') {
            saveFindsToLocalStorage();
        } else {
            try { localStorage.setItem('geoFindFinds', JSON.stringify(finds)); } catch (_) {}
        }
    } catch (e) {
        console.warn('Purge deleted records failed:', e);
        log('WARNING: purge deleted records failed (see console).');
    }

    // -----------------------------
    // 2) Delete orphaned IndexedDB photos
    // -----------------------------
    try {
        if (typeof indexedDB === 'undefined') {
            log('IndexedDB not available; skipping orphan photo cleanup.');
        } else if (typeof openPhotoDB !== 'function') {
            log('openPhotoDB() not found; skipping orphan photo cleanup.');
        } else if (typeof deletePhotoBlob !== 'function') {
            log('deletePhotoBlob() not found; skipping orphan photo cleanup.');
        } else if (typeof isIndexedDbPhotoRef !== 'function' || typeof parsePhotoRef !== 'function') {
            log('isIndexedDbPhotoRef()/parsePhotoRef() not found; skipping orphan photo cleanup.');
        } else {
            log('Scanning IndexedDB for orphaned photos...');

            const referenced = collectAllReferencedPhotoIds(); // Set<number>

            // Read ALL keys from the store
            const db = await openPhotoDB();

            const allKeys = await new Promise((resolve, reject) => {
                try {
                    const tx = db.transaction(PHOTO_STORE_NAME, 'readonly');
                    const store = tx.objectStore(PHOTO_STORE_NAME);
                    const req = store.getAllKeys();
                    req.onerror = () => reject(req.error);
                    req.onsuccess = () => resolve(req.result || []);
                } catch (e) {
                    reject(e);
                }
            });

            // Convert keys (likely numbers) to Set<string> for robust comparison
            const referencedStr = new Set([...referenced].map(x => String(x)));
            const allKeysStr = (allKeys || []).map(k => String(k));

            const orphanKeysStr = allKeysStr.filter(k => !referencedStr.has(k));

            log(`Photo store: "${PHOTO_STORE_NAME}" (DB: "${PHOTO_DB_NAME}")`);
            log(`Total blobs:      ${allKeysStr.length}`);
            log(`Referenced blobs: ${referencedStr.size}`);
            log(`Orphan blobs:     ${orphanKeysStr.length}`);

            let deletedCount = 0;
            for (const kStr of orphanKeysStr) {
                const id = (/^\d+$/).test(kStr) ? Number(kStr) : kStr;
                try {
                    await deletePhotoBlob(id);
                    deletedCount++;
                } catch (e) {
                    console.warn('Failed to delete orphan photo blob', id, e);
                }
            }

            log(`Orphan deletions completed: ${deletedCount}/${orphanKeysStr.length}`);

            try { db.close(); } catch (_) {}
        }
    } catch (e) {
        console.warn('Orphan photo cleanup failed:', e);
        log('WARNING: orphan photo cleanup failed (see console).');
    }

    // -----------------------------
    // 3) Final UI refresh
    // -----------------------------
    try {
        showMessage('Purge complete (deleted records removed; orphan photos cleaned).', 'success');
    } catch (_) {}

    try { render(); } catch (_) {}
}


const NAV_OVERLAY_SETTINGS_KEY = "metal_finder_nav_overlay_settings";

let navOverlaySettings = {
    aboveOffsetPct: 50, // default
    belowOffsetPct: 6   // default
};

function isStakeTarget(t) {
    return String(t?.vdi ?? '').trim() === '-100';
}

function getSurveyTargetsOnly(survey) {
    const arr = Array.isArray(survey?.targets) ? survey.targets : [];
    return arr.filter(t => t && !t.deleted && !isStakeTarget(t));
}

function getSurveyStakesOnly(survey) {
    const arr = Array.isArray(survey?.targets) ? survey.targets : [];
    return arr.filter(t => t && !t.deleted && isStakeTarget(t));
}

// Finds: prefer global 'finds' array (your app uses this) but also include survey.finds if present.
function getSurveyFindsCount(survey) {
    const sid = survey?.id;
    const fromGlobal = Array.isArray(finds) && sid ? finds.filter(f => f && !f.deleted && f.surveyId === sid) : [];
    const fromSurvey = Array.isArray(survey?.finds) ? survey.finds.filter(f => f && !f.deleted) : [];

    // de-dupe by id (in case both exist)
    const seen = new Set();
    let n = 0;
    for (const f of [...fromGlobal, ...fromSurvey]) {
        const id = f?.id || JSON.stringify(f);
        if (seen.has(id)) continue;
        seen.add(id);
        n++;
    }
    return n;
}

function getAppTotals() {
    const allSurveys = Array.isArray(surveys) ? surveys : [];
    const totalSurveys = allSurveys.length;

    let totalTargets = 0;
    let totalStakes  = 0;
    for (const s of allSurveys) {
        totalTargets += getSurveyTargetsOnly(s).length;
        totalStakes  += getSurveyStakesOnly(s).length;
    }

    const totalFinds = Array.isArray(finds)
        ? finds.filter(f => f && !f.deleted).length
        : 0;

    return { totalSurveys, totalTargets, totalStakes, totalFinds };
}


/** Home dashboard: update storage figures (browser-managed) */
async function updateHomeStorageStats() {
    const usedEl = document.getElementById('home-storage-used');
    const freeEl = document.getElementById('home-storage-free');
    if (!usedEl || !freeEl) return;

    // Default placeholders
    usedEl.textContent = '—';
    freeEl.textContent = '—';

    try {
        if (!navigator.storage || !navigator.storage.estimate) return;

        const est = await navigator.storage.estimate();
        const usage = est && typeof est.usage === 'number' ? est.usage : null;
        const quota = est && typeof est.quota === 'number' ? est.quota : null;
        if (usage == null || quota == null || quota <= 0) return;

        const bytesToNice = (bytes) => {
            if (!Number.isFinite(bytes) || bytes < 0) return '—';
            const kb = 1024;
            const mb = kb * 1024;
            const gb = mb * 1024;
            if (bytes >= gb) return (bytes / gb).toFixed(2) + ' GB';
            if (bytes >= mb) return (bytes / mb).toFixed(0) + ' MB';
            return (bytes / kb).toFixed(0) + ' KB';
        };

        usedEl.textContent = bytesToNice(usage);
        freeEl.textContent = bytesToNice(Math.max(0, quota - usage));
    } catch (e) {
        // Leave placeholders
    }
}




    function updateActiveNavButtons() {
    document.querySelectorAll('.nav-btn').forEach(btn => {
        btn.classList.remove('active');
        if (btn.dataset.page === currentPage) {
            btn.classList.add('active');
        }
    });
}
        
// -------------------- App Limits / Expiry (Tester build controls) --------------------
// -------------------- App Limits / Expiry (Tester build controls) --------------------

function isUnlimitedUser() {
    // Special unlimited mode for the named tester account (case-sensitive match).
    try {
        return (userProfile && userProfile.name === 'Laurence Wright');
    } catch (e) {
        return false;
    }
}
window.APP_LIMITS_STORAGE_KEY ??= 'detekta_app_limits_v1';
window.APP_RUNS_STORAGE_KEY   ??= 'detekta_app_runs_v1';

function getDefaultAppLimits() {
    return {
        maxSurveys: 3,
        maxTargets: 50,
        maxFinds: 30,
        expiryDate: '2026-06-01' // ISO YYYY-MM-DD
    };
}

function loadAppLimits() {
    const defaults = getDefaultAppLimits();
    try {
        const raw = localStorage.getItem(APP_LIMITS_STORAGE_KEY);
        if (!raw) return { ...defaults };

        const obj = JSON.parse(raw) || {};
        // Blank/undefined means "no limit" except defaults apply if key missing entirely.
        // If you want "blank" to persist as unlimited, store null.
        return {
            maxSurveys: (obj.maxSurveys === null) ? null : (Number.isFinite(+obj.maxSurveys) ? +obj.maxSurveys : defaults.maxSurveys),
            maxTargets: (obj.maxTargets === null) ? null : (Number.isFinite(+obj.maxTargets) ? +obj.maxTargets : defaults.maxTargets),
            maxFinds:   (obj.maxFinds   === null) ? null : (Number.isFinite(+obj.maxFinds)   ? +obj.maxFinds   : defaults.maxFinds),
            expiryDate: (obj.expiryDate === null) ? null : (typeof obj.expiryDate === 'string' && obj.expiryDate.trim() ? obj.expiryDate.trim() : defaults.expiryDate)
        };
    } catch {
        return { ...defaults };
    }
}

function saveAppLimits(limits) {
    const normIntOrNull = (v) => {
        const s = String(v ?? '').trim();
        if (!s) return null;                 // blank => unlimited
        const n = Math.max(0, Math.floor(+s));
        return Number.isFinite(n) ? n : null;
    };
    const normDateOrNull = (v) => {
        const s = String(v ?? '').trim();
        if (!s) return null;                 // blank => no expiry
        // Expect YYYY-MM-DD
        return s;
    };

    const toSave = {
        maxSurveys: normIntOrNull(limits.maxSurveys),
        maxTargets: normIntOrNull(limits.maxTargets),
        maxFinds:   normIntOrNull(limits.maxFinds),
        expiryDate: normDateOrNull(limits.expiryDate)
    };
    localStorage.setItem(APP_LIMITS_STORAGE_KEY, JSON.stringify(toSave));
    return loadAppLimits(); // return normalised
}

function getAppRunCount() {
    const n = parseInt(localStorage.getItem(APP_RUNS_STORAGE_KEY) || '0', 10);
    return Number.isFinite(n) ? n : 0;
}

function incrementAppRunCount() {
    const n = getAppRunCount() + 1;
    localStorage.setItem(APP_RUNS_STORAGE_KEY, String(n));
    return n;
}

function isExpired(limits = loadAppLimits()) {
    if (typeof isUnlimitedUser === 'function' && isUnlimitedUser()) return false;
    if (!limits.expiryDate) return false;
    const today = new Date();
    const exp = new Date(limits.expiryDate + 'T00:00:00');
    // expired if today is on/after expiry date
    return today >= exp;
}

/**
 * Returns { ok, reason, type } where type: 'surveys'|'targets'|'finds'|'expired'
 */
function canCreate(type, openSurvey = null) {
    // Unlimited mode bypasses all limits/expiry for the special tester account.
    if (typeof isUnlimitedUser === 'function' && isUnlimitedUser()) {
        return { ok: true, reason: '', type: type };
    }

    const limits = loadAppLimits();

    if (isExpired(limits)) {
        return { ok: false, reason: `This test version expired on ${limits.expiryDate}.`, type: 'expired' };
    }

    // Count surveys
    const surveysCount = Array.isArray(surveys) ? surveys.length : 0;

    // Count targets/finds (prefer open survey if supplied, else all)
    const allTargets = [];
    const allFinds = [];

    if (Array.isArray(surveys)) {
        surveys.forEach(s => {
            (Array.isArray(s.targets) ? s.targets : []).forEach(t => allTargets.push(t));
            (Array.isArray(s.finds) ? s.finds : []).forEach(f => allFinds.push(f));
        });
    }

    const targetsCount = allTargets.length;
    const findsCount   = allFinds.length;

    if (type === 'surveys' && limits.maxSurveys !== null && surveysCount >= limits.maxSurveys) {
        return { ok: false, reason: `Max surveys reached (${limits.maxSurveys}).`, type: 'surveys' };
    }
    if (type === 'targets' && limits.maxTargets !== null && targetsCount >= limits.maxTargets) {
        return { ok: false, reason: `Max targets reached (${limits.maxTargets}).`, type: 'targets' };
    }
    if (type === 'finds' && limits.maxFinds !== null && findsCount >= limits.maxFinds) {
        return { ok: false, reason: `Max finds reached (${limits.maxFinds}).`, type: 'finds' };
    }

    return { ok: true, reason: '', type: type };
}

function enforceCanCreateOrWarn(type) {
    if (typeof canCreate !== 'function') return true; // limits not wired yet
    const r = canCreate(type);

    if (r.ok) return true;

    // Prefer long message if you have it
    if (typeof showMessageLong === 'function') {
        showMessageLong(r.reason || 'Limit reached.', 'error', 7000);
    } else if (typeof showMessage === 'function') {
        showMessage(r.reason || 'Limit reached.', 'error');
    } else {
        alert(r.reason || 'Limit reached.');
    }

    // If expired, you may also want to bounce user to Settings/Home
    return false;
}
        
function renderHelpPage() {
    return `
      <div class="p-4 space-y-4">
        <h2 class="text-2xl font-bold text-primary mb-4">
          Help & Getting Started
        </h2>

        <pre class="whitespace-pre-wrap text-sm bg-white p-4 rounded-xl shadow border border-gray-200">
Detekta – A Metal Detecting App
Help & Getting Started

Detekta is a field logging and navigation app designed for metal detectorists.
It works fully offline and stores all data locally on your device.

--------------------------------
OVERVIEW
--------------------------------

On your screen you will see a row of icons.
These icons are buttons that allow you to select the different pages in the app.

Home icon  
Takes you to the Home page where you can create, open, close, and delete surveys.
Only one survey can be open at a time.
The Targets and Finds pages always show data for the currently open survey.

Compass icon  
This page is used while detecting.
Here you can record tracks, place stakes, and log target signals.

As you survey an area, a small map is drawn showing:
• Tracks
• Stakes
• Targets
• Finds

North is always at the top of the map.

The “Start Tracking” button records where you have walked.
As you move, a track is drawn on the map.

There are five coloured buttons, ranging from blue on the left to red on the right.
Each button records a target with a preset Target ID (VDI).

• Blue buttons are for low or negative Target IDs, often indicating iron.
• Red buttons are for higher-value signals that you may want to dig immediately.

When a target is saved, it is recorded with GPS coordinates.

If you tap a target on the map, you will receive guidance on how to navigate back to it.
It is important to understand that GPS accuracy varies.

GPS will only get you into the approximate area.
Errors of over one metre (3 feet) are common.
There will be error in both the recorded target position and your current position.

If you wish to return precisely to a target, it is recommended that you place a visible marker
(biodegradable if possible) directly above the target.
Use the app to get close, then locate the marker visually.

--------------------------------
TARGETS PAGE
--------------------------------

Bullseye (target) icon  
This opens the Targets page, which lists all targets and stakes for the open survey.

Each target can be edited and can have multiple photos added.

Use “Log New Target” to record detected signals.
You can record:
• Description
• Target ID (VDI)
• Depth
• GPS location and accuracy
• Photos

For each target there are three rows of buttons:

Row 1 – Hole status  
• Not Dug  
• Dug  
• Refilled  
• Ignored  

Row 2 – Actions  
• QR Code – generates a QR code containing the target details  
  This can be scanned by a friend to import the target on another device.
• Navigate – provides guidance back to the target (same as tapping it on the map)
• Centre Map – centres the map on this target

Row 3 – Management  
• Edit details – change information and manage photos  
• Copy to Finds – use this once you have dug the target and found something worth recording  
• Delete – permanently removes the target

When copying to Finds, the target is duplicated and relabelled as a Find.

--------------------------------
FINDS PAGE
--------------------------------

Trophy icon  
This opens the Finds page, which lists all finds across all surveys.

Finds can be filtered in three ways:
• By typing into the search box
• By find type (for example, coins only)
• By survey name

If a find has photos, you can tap the photo to step through them.

Each find has buttons allowing you to edit or delete it.
Deleted finds can only be restored by copying the original target again.

--------------------------------
EXPORT & IMPORT
--------------------------------

Export icon  
This opens the Export / Import page, used for backup and sharing.

Export Open Survey as ZIP  
Creates a ZIP file containing the survey and all photographs.
The ZIP file is saved to your Downloads folder.

Export Photo Gallery  
Creates a small self-contained website in your Downloads folder.
It contains an HTML file that others can open in a web browser to view your photos.
You can choose which photos to include using the checkboxes.
Most people will only want to see finds rather than all targets.

Export Open Survey as GPX  
Exports survey data (without photos) in GPX format.
GPX files can be imported into many mapping applications.

Select File and Import  
Allows you to import a survey previously exported as a ZIP file.

Select GPX and Import  
Creates a survey from a GPX file exported from another mapping app.

Import Target (QR Code)  
Creates a new target by scanning a QR code displayed on another device.

--------------------------------
GETTING STARTED
--------------------------------

1. Create a Survey  
A survey represents a detecting session or location.
You must give the survey a name.
You may optionally add a description and a photo.

2. Start Detecting and Logging Targets  
Go to the Compass page and select “Start Tracking”.
As you move around the area, log targets as you find them.
It is usually best to dig high-value targets immediately.

You may also place stakes to help orient yourself on the map.
Tracks help you see which areas you have already covered.

When you finish detecting, remember to select “Stop Tracking”.
If you forget, your journey home may be recorded, causing targets to appear clustered.

This can be corrected by deleting the track or by using “Hide My Position” on the map.

3. Reviewing Finds  
After recording finds, you should update the information.
In particular, you may wish to replace target photos with photos of the actual find.

4. Backup and Share  
Detekta provides several ways to back up and share your data.
All exports are saved to the Downloads folder.
From there they can be copied, emailed, or stored elsewhere.

It is your responsibility to make regular backups.

--------------------------------
DATA & PRIVACY
--------------------------------

Detekta does not collect or transmit personal data.
All data is stored locally on your device unless you choose to export it.

--------------------------------
END
--------------------------------

        </pre>
      </div>
    `;
}

async function exportPhotoGallery_Download() {
    const logBox = document.getElementById('export-photo-gallery-log');
    const btn = document.getElementById('export-gallery-download-btn');

    const log = (msg) => {
        console.log('[Gallery Download]', msg);
        if (!logBox) return;
        logBox.value += msg + '\n';
        logBox.scrollTop = logBox.scrollHeight;
    };
    if (logBox) logBox.value = '';

    // ---- Read checkboxes A–G ----
    const createIndex      = !!document.getElementById('gallery-dl-create-index')?.checked;      // A
    const exportOpen       = !!document.getElementById('gallery-dl-export-open')?.checked;       // B
    const exportOther      = !!document.getElementById('gallery-dl-export-other')?.checked;      // C
    const includeTargets   = !!document.getElementById('gallery-dl-include-targets')?.checked;   // D
    const includeFinds     = !!document.getElementById('gallery-dl-include-finds')?.checked;     // E
    const writeTargetJpgs  = !!document.getElementById('gallery-dl-write-target-jpgs')?.checked; // F
    const writeFindJpgs    = !!document.getElementById('gallery-dl-write-find-jpgs')?.checked;   // G

    const maxW = (typeof getMaxPhotoWidth === 'function') ? getMaxPhotoWidth() : 1000;

    // ---- Validation ----
    if (!exportOpen && !exportOther) {
        showMessage('Select Open Survey and/or Other Surveys.', 'error');
        return;
    }
    if (!includeTargets && !includeFinds) {
        showMessage('Select Targets and/or Finds to include in the gallery.', 'error');
        return;
    }
    if (typeof JSZip === 'undefined') {
        showMessage('ZIP export needs JSZip (the JSZip <script> tag).', 'error');
        return;
    }
    if (typeof resolvePhotoBlob !== 'function' || typeof resizeBlobToMaxWidthJpeg !== 'function') {
        showMessage('Photo helpers missing (resolvePhotoBlob / resizeBlobToMaxWidthJpeg).', 'error');
        return;
    }
    if (typeof downloadBlob !== 'function') {
        showMessage('Download helper missing (downloadBlob).', 'error');
        return;
    }

    let originalBtnText = '';
    if (btn) {
        originalBtnText = btn.innerText;
        btn.disabled = true;
        btn.innerText = 'Exporting…';
    }

    // ---- Helpers ----
    const escapeHtml = (s) => String(s ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');

    const safeSlug = (s) => String(s ?? 'survey')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '')
        .slice(0, 60) || 'survey';

    const safeFilePart = (s) => String(s ?? 'item')
        .replace(/[\/\\:*?"<>|]/g, '_')
        .replace(/\s+/g, ' ')
        .trim()
        .slice(0, 80) || 'item';

    const blobToDataUrl = (blob) => new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = () => reject(r.error);
        r.readAsDataURL(blob);
    });

    const yieldToUi = async () => new Promise(r => setTimeout(r, 0));

    function pickSurveys() {
        const all = Array.isArray(surveys) ? surveys : [];
        const open = all.find(s => s && s.status === 'Open');
        let selected = [];

        if (exportOpen && open) selected.push(open);
        if (exportOther) selected = selected.concat(all.filter(s => s && s.status !== 'Open'));

        const seen = new Set();
        const uniq = [];
        for (const s of selected) {
            const k = (s?.id != null) ? `id:${s.id}` : `name:${s?.name}`;
            if (seen.has(k)) continue;
            seen.add(k);
            uniq.push(s);
        }
        return { uniq, openExists: !!open };
    }

    function wrapHtmlDocument({ title, topCardsHtml, bodyHtml, exportedText }) {
        return `
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>${escapeHtml(title)}</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#f7f7f7;color:#111}
  a{color:inherit}
  header{padding:18px 16px;background:#fff;border-bottom:1px solid #e5e7eb;position:sticky;top:0;z-index:10}
  h1{margin:0;font-size:20px}
  .sub{margin:6px 0 0;color:#333;font-size:13px}
  main{padding:16px;max-width:1100px;margin:0 auto}

  .gridTop{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:12px;margin-bottom:18px}
  @media (max-width:420px){.gridTop{gap:10px}}
  a.cardTop{display:block;text-decoration:none;color:inherit;background:#fff;border:1px solid #e5e7eb;border-radius:14px;overflow:hidden;box-shadow:0 4px 14px rgba(0,0,0,.05)}
  .thumb{background:#eee;display:flex;align-items:center;justify-content:center}
  .thumb img{width:100%;height:auto;display:block}
  .noThumb{padding:18px 12px;min-height:80px;display:flex;align-items:center;justify-content:center;color:#555;font-size:12px;text-align:center;background:#f1f5f9}
  .meta{padding:10px 12px}
  .title{font-weight:800;font-size:14px;line-height:1.2}
  .hint{font-size:12px;color:#555;margin-top:4px}

  .surveySection{background:#fff;border:1px solid #e5e7eb;border-radius:16px;padding:14px;margin:18px 0;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  .surveyHeaderTop{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  .surveyTitle{margin:0;font-size:18px}
  .backTop{font-size:12px;color:#111;text-decoration:underline}
  .surveyDesc{margin:8px 0 0;color:#222;font-size:13px}
  .surveyMeta{margin:8px 0 0;color:#222;font-size:12px;display:flex;gap:12px;flex-wrap:wrap}
  .muted{color:#333;font-size:13px}

  .heroWrap{display:flex;justify-content:center;margin:12px 0 10px}
  .heroImg{width:98%;height:auto;border-radius:14px;border:1px solid #e5e7eb;display:block}

  .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px;margin-top:10px}
  @media (max-width:420px){.grid{gap:8px}}
  a.thumbLink{display:block;text-decoration:none}
  a.card{background:#fff;border:1px solid #e5e7eb;border-radius:12px;overflow:hidden;box-shadow:0 2px 10px rgba(0,0,0,.05)}
  a.card img{width:100%;height:auto;display:block}
  .noimg{padding:18px 12px;min-height:80px;display:flex;align-items:center;justify-content:center;color:#555;background:#f1f5f9;font-size:12px}
  .cap{padding:8px 10px}
  .tTitle{font-weight:800;font-size:13px;line-height:1.2;color:#111}
  .metaLine{font-size:12px;color:#333;margin-top:3px}

  h3{margin:18px 0 8px;font-size:14px;color:#111}
  .detail{margin-top:14px;padding-top:10px;border-top:1px solid #e5e7eb}
  .back{font-size:12px;color:#111;margin-bottom:8px}
  .back a{text-decoration:underline}
  .sep{display:inline-block;margin:0 8px;color:#555}
  img.full{width:100%;height:auto;border-radius:14px;border:1px solid #e5e7eb;margin-top:10px;display:block}
  .metaList{margin:10px 0 0;padding-left:18px;color:#111;font-size:13px}
  .metaList li{margin:4px 0}
</style>
</head>
<body>
<a id="top"></a>
<header>
  <h1>Photo Galleries</h1>
  <p class="sub">${escapeHtml(exportedText || '')} — self-contained (phone safe)</p>
</header>
<main>
  ${topCardsHtml ? `<div class="gridTop">${topCardsHtml}</div>` : ``}
  ${bodyHtml || ''}
</main>
</body>
</html>`.trim();
    }

    try {
        const { uniq: selectedSurveys, openExists } = pickSurveys();

        if (exportOpen && !openExists) {
            showMessage('No Open survey found (uncheck Export Open Survey or open one).', 'error');
            return;
        }
        if (selectedSurveys.length === 0) {
            showMessage('No surveys matched your selection.', 'error');
            return;
        }

        const alsoWriteJpgs = !!(writeTargetJpgs || writeFindJpgs);

        log(`Surveys selected: ${selectedSurveys.length}`);
        log(`Include Finds: ${includeFinds ? 'YES' : 'NO'}`);
        log(`Include Targets: ${includeTargets ? 'YES' : 'NO'}`);
        log(`Max width: ${maxW}px`);
        log(`Create index.html: ${createIndex ? 'YES' : 'NO'}`);
        log(`Also create JPGs: ${alsoWriteJpgs ? 'YES' : 'NO'} (Finds: ${writeFindJpgs ? 'YES' : 'NO'} | Targets: ${writeTargetJpgs ? 'YES' : 'NO'})`);
        log('---');

        // Prepare ZIP
        const zip = new JSZip();
        const jpgRoot = alsoWriteJpgs ? zip.folder('JPG') : null;
        const jpgFindsFolder = (alsoWriteJpgs && writeFindJpgs) ? jpgRoot.folder('Finds') : null;
        const jpgTargetsFolder = (alsoWriteJpgs && writeTargetJpgs) ? jpgRoot.folder('Targets') : null;

        // Count work up front (for log/progress pacing)
        let totalPhotosPlanned = 0;
        for (const s of selectedSurveys) {
            if (!s) continue;

            // survey hero (used for html but not jpg)
            const surveyPhotoRef = s?.surveyPhotoData || s?.surveyPhotoRef || '';
            if (surveyPhotoRef) totalPhotosPlanned += 1;

            if (includeFinds) {
                const sf = (Array.isArray(finds) ? finds : []).filter(f => f && f.surveyId === s.id);
                for (const f of sf) {
                    const refs = Array.isArray(f.photos) && f.photos.length
                        ? f.photos
                        : [f.photoData, f.targetPhotoData, f.photoDataUrl].filter(Boolean);
                    totalPhotosPlanned += refs.length;
                }
            }

            if (includeTargets && Array.isArray(s?.targets)) {
                for (const t of s.targets) {
                    const refs = Array.isArray(t.photos) && t.photos.length
                        ? t.photos
                        : [t.targetPhotoData, t.photoDataUrl, t.photoRef].filter(Boolean);
                    totalPhotosPlanned += refs.length;
                }
            }
        }

        let photosDone = 0;
        const bumpProgressLog = (force = false) => {
            if (!totalPhotosPlanned) return;
            if (!force && (photosDone % 8 !== 0)) return; // log every ~8 photos
            const pct = Math.min(100, Math.round((photosDone / totalPhotosPlanned) * 100));
            log(`Progress: ${photosDone}/${totalPhotosPlanned} photos processed (${pct}%)`);
        };

        async function photoRefToDataUrlSized(photoRef, maxWidthPx) {
            if (!photoRef) return '';
            try {
                const raw = await resolvePhotoBlob(photoRef);
                if (!raw) return '';
                const resized = await resizeBlobToMaxWidthJpeg(raw, maxWidthPx, 0.85);
                if (!resized) return '';
                return await blobToDataUrl(resized);
            } catch {
                return '';
            }
        }

        async function photoRefToResizedJpegBlob(photoRef, maxWidthPx) {
            if (!photoRef) return null;
            try {
                const raw = await resolvePhotoBlob(photoRef);
                if (!raw) return null;
                const resized = await resizeBlobToMaxWidthJpeg(raw, maxWidthPx, 0.85);
                return resized || null;
            } catch {
                return null;
            }
        }

        async function buildSingleSurveyHtmlAndMaybeJpgs(s, surveyIndex) {
            const title = s?.name || 'Survey';
            const surveySlug = safeSlug(title);
            const surveyIdShort = (s?.id != null) ? String(s.id).slice(-6) : '';
            const sid = `survey-${surveySlug}${surveyIdShort ? `-${surveyIdShort}` : ''}`.slice(0, 90);

            // Survey hero + thumb
            const surveyPhotoRef = s?.surveyPhotoData || s?.surveyPhotoRef || '';
            const heroDataUrl = surveyPhotoRef ? await photoRefToDataUrlSized(surveyPhotoRef, maxW) : '';
            const heroThumbUrl = surveyPhotoRef ? await photoRefToDataUrlSized(surveyPhotoRef, 320) : '';

            // Items: Finds first, then Targets
            const items = [];

            if (includeFinds) {
                const sf = (Array.isArray(finds) ? finds : []).filter(f => f && f.surveyId === s.id);
                for (const f of sf) {
                    const refs = Array.isArray(f.photos) && f.photos.length
                        ? f.photos
                        : [f.photoData, f.targetPhotoData, f.photoDataUrl].filter(Boolean);

                    for (let i = 0; i < refs.length; i++) {
                        items.push({
                            kind: 'Find',
                            parentId: f.id,
                            indexInParent: i + 1,
                            title: f.description || `Find ${f.id}`,
                            type: f.type || '',
                            vdi: f.vdi || '',
                            depth: f.depth || '',
                            coords: f.coordinates || '',
                            accuracy: f.accuracy || '',
                            photoRef: refs[i]
                        });
                    }
                }
            }

            if (includeTargets && Array.isArray(s?.targets)) {
                for (const t of s.targets) {
                    const refs = Array.isArray(t.photos) && t.photos.length
                        ? t.photos
                        : [t.targetPhotoData, t.photoDataUrl, t.photoRef].filter(Boolean);

                    for (let i = 0; i < refs.length; i++) {
                        items.push({
                            kind: 'Target',
                            parentId: t.id,
                            indexInParent: i + 1,
                            title: t.description || `Target ${t.id}`,
                            type: t.type || '',
                            vdi: t.vdi || '',
                            depth: t.depth || '',
                            coords: t.coordinates || '',
                            accuracy: t.accuracy || '',
                            photoRef: refs[i]
                        });
                    }
                }
            }

            const thumbCards = [];
            const fullBlocks = [];

            // For master thumbnail fallback:
            let firstFindThumb = '';
            let firstTargetThumb = '';

            // Process photos (keep log alive)
            for (let n = 0; n < items.length; n++) {
                const it = items[n];

                // UI pacing
                photosDone++;
                if (photosDone % 2 === 0) await yieldToUi();

                // Build ids
                const pid = `${sid}-${safeSlug(it.kind)}-${safeSlug(it.parentId)}-${it.indexInParent}`;

                // Make thumb + full
                // (we generate blobs for full anyway so we can also save JPGs without refetching)
                let fullBlob = await photoRefToResizedJpegBlob(it.photoRef, maxW);
                let thumbBlob = await photoRefToResizedJpegBlob(it.photoRef, 320);

                const fullUrl = fullBlob ? await blobToDataUrl(fullBlob) : '';
                const thumbUrl = thumbBlob ? await blobToDataUrl(thumbBlob) : '';

                if (thumbUrl) {
                    if (!firstFindThumb && it.kind === 'Find') firstFindThumb = thumbUrl;
                    if (!firstTargetThumb && it.kind === 'Target') firstTargetThumb = thumbUrl;
                }

                // Optional JPG writing into ZIP
                if (alsoWriteJpgs && fullBlob) {
                    const base =
                        `${safeFilePart(surveySlug)}__${safeFilePart(it.kind)}__${safeFilePart(it.parentId)}__${String(it.indexInParent).padStart(2, '0')}`;

                    if (it.kind === 'Find' && writeFindJpgs && jpgFindsFolder) {
                        jpgFindsFolder.file(`${base}.jpg`, fullBlob);
                    }
                    if (it.kind === 'Target' && writeTargetJpgs && jpgTargetsFolder) {
                        jpgTargetsFolder.file(`${base}.jpg`, fullBlob);
                    }
                }

                thumbCards.push(`
<a class="thumbLink card" href="#${pid}">
  ${thumbUrl
        ? `<img src="${thumbUrl}" alt="${escapeHtml(it.kind)} photo">`
        : `<div class="noimg">No photo</div>`
    }
  <div class="cap">
    <div class="tTitle">${escapeHtml(it.kind)} — ${escapeHtml(it.title)}</div>
    ${it.type ? `<div class="metaLine">Type: ${escapeHtml(it.type)}</div>` : `<div class="metaLine">&nbsp;</div>`}
    <div class="metaLine">
      ${it.vdi ? `VDI: ${escapeHtml(it.vdi)}` : ''}
      ${it.depth ? `&nbsp;&nbsp;Depth: ${escapeHtml(it.depth)}` : ''}
    </div>
  </div>
</a>`.trim());

                fullBlocks.push(`
<div class="detail" id="${pid}">
  <div class="back">
    <a href="#${sid}-thumbs">Back to thumbnails</a>
    <span class="sep">|</span>
    <a href="#top">Top</a>
  </div>
  ${fullUrl ? `<img class="full" src="${fullUrl}" alt="${escapeHtml(it.kind)} photo">` : ''}
  <ul class="metaList">
    <li><strong>Kind:</strong> ${escapeHtml(it.kind)}</li>
    <li><strong>Title:</strong> ${escapeHtml(it.title)}</li>
    ${it.type ? `<li><strong>Type:</strong> ${escapeHtml(it.type)}</li>` : ''}
    ${it.vdi ? `<li><strong>VDI:</strong> ${escapeHtml(it.vdi)}</li>` : ''}
    ${it.depth ? `<li><strong>Depth:</strong> ${escapeHtml(it.depth)}</li>` : ''}
    ${it.coords ? `<li><strong>GPS:</strong> ${escapeHtml(it.coords)}</li>` : ''}
    ${it.accuracy ? `<li><strong>Accuracy:</strong> ${escapeHtml(it.accuracy)}</li>` : ''}
  </ul>
</div>`.trim());

                // keep log alive
                bumpProgressLog(false);
            }

            bumpProgressLog(true);

            // Master card thumb priority:
            // Survey photo thumb -> Find thumb -> Target thumb
            const thumbDataUrl = heroThumbUrl || firstFindThumb || firstTargetThumb || '';

            const surveyHeroHtml = heroDataUrl
                ? `<div class="heroWrap"><img class="heroImg" src="${heroDataUrl}" alt="Survey photo"></div>`
                : '';

            const sectionHtml = `
<div class="surveySection" id="${sid}">
  <div class="surveyHeaderTop">
    <h2 class="surveyTitle">${escapeHtml(title)}</h2>
    <a class="backTop" href="#top">Back to top</a>
  </div>
  ${s?.description ? `<div class="surveyDesc">${escapeHtml(s.description)}</div>` : ''}
  <div class="surveyMeta">
    ${s?.status ? `<span><strong>Status:</strong> ${escapeHtml(s.status)}</span>` : ''}
    ${s?.dateCreated ? `<span><strong>Created:</strong> ${escapeHtml(formatDate(s.dateCreated))}</span>` : ''}
  </div>

  ${surveyHeroHtml}

  <h3 id="${sid}-thumbs">Thumbnails</h3>
  ${thumbCards.length ? `<div class="grid">${thumbCards.join('')}</div>` : `<p class="muted">No photos found.</p>`}

  ${thumbCards.length ? `<h3>Full Photos</h3>${fullBlocks.join('')}` : ``}
</div>`.trim();

            // HTML name for ZIP
            const htmlName = createIndex
                ? null
                : `gallery__${surveySlug}${surveyIdShort ? `__${surveyIdShort}` : ''}.html`;

            return { title, sid, thumbDataUrl, sectionHtml, htmlName };
        }

        // Build all survey sections
        const built = [];
        for (let i = 0; i < selectedSurveys.length; i++) {
            const s = selectedSurveys[i];
            log(`[${i + 1}/${selectedSurveys.length}] Processing: ${s?.name || 'Survey'}`);
            built.push(await buildSingleSurveyHtmlAndMaybeJpgs(s, i + 1));
        }

        // Write HTML into ZIP
        const now = new Date();
        const exportedText = `Exported ${now.toLocaleString()}`;

        if (!createIndex) {
            // one HTML per survey
            for (const one of built) {
                const page = wrapHtmlDocument({
                    title: `Gallery — ${one.title}`,
                    topCardsHtml: '',
                    bodyHtml: one.sectionHtml,
                    exportedText
                });
                const fname = one.htmlName || `gallery__${safeSlug(one.title)}.html`;
                zip.file(fname, page);
            }
            log(`Added ${built.length} gallery HTML file(s) to ZIP.`);
        } else {
            // ONE index.html with master thumbnails + embedded sections
            const cardsHtml = built.map(b => `
<a class="cardTop" href="#${b.sid}">
  <div class="thumb">
    ${b.thumbDataUrl
        ? `<img src="${b.thumbDataUrl}" alt="${escapeHtml(b.title)}">`
        : `<div class="noThumb">No photo</div>`}
  </div>
  <div class="meta">
    <div class="title">${escapeHtml(b.title)}</div>
    <div class="hint">Jump to gallery</div>
  </div>
</a>`.trim()).join('\n');

            const bodyHtml = built.map(b => b.sectionHtml).join('\n\n');

            const indexHtml = wrapHtmlDocument({
                title: 'geoFind Gallery',
                topCardsHtml: cardsHtml,
                bodyHtml,
                exportedText
            });

            zip.file('index.html', indexHtml);
            log('Added index.html to ZIP.');
        }

        // Generate ZIP with progress
        log('Building ZIP… (this can take a while)');
        const zipBlob = await zip.generateAsync(
            { type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } },
            (meta) => {
                const pct = Math.round(meta.percent || 0);
                // Keep log alive without spamming
                if (pct % 10 === 0) {
                    log(`ZIP progress: ${pct}%`);
                }
            }
        );

        const zipName = `geoFind_gallery_${now.toISOString().slice(0, 10)}_${String(now.getHours()).padStart(2,'0')}${String(now.getMinutes()).padStart(2,'0')}.zip`;
        downloadBlob(zipName, zipBlob);

        showMessage('Gallery ZIP downloaded (check Downloads).', 'success');
        log('DONE: ZIP download triggered.');

    } catch (e) {
        console.error('exportPhotoGallery_Download error:', e);
        showMessage(`Export failed: ${e.message || e}`, 'error');
        log(`ERROR: ${e.message || e}`);
    } finally {
        if (btn) {
            btn.disabled = false;
            btn.innerText = originalBtnText || 'Export Gallery to Downloads';
        }
    }
}



        
// ================================
// DOWNLOAD HELPERS (Gallery export)
// ================================
function downloadBlob(filename, blob) {
    try {
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = filename;

        // Some browsers behave better if it's in the DOM
        document.body.appendChild(a);
        a.click();

        setTimeout(() => {
            URL.revokeObjectURL(url);
            a.remove();
        }, 1000);
    } catch (e) {
        console.error('downloadBlob failed:', e);
        showMessage?.(`Download failed: ${e?.message || e}`, 'error');
    }
}

function downloadTextFile(filename, text, mime = 'text/plain') {
    const blob = new Blob([text], { type: mime });
    downloadBlob(filename, blob);
}

// ---- Compatibility aliases (common typos / older code paths) ----
window.downloadBlod = downloadBlob;          // typo safety
window.downloadTextfile = downloadTextFile;  // case/typo safety

/**
 * Phone-safe export: creates ONE self-contained HTML file (no folder handles).
 * Uses embedded images (data URLs). Works reliably on Android.
 *
 * Assumes you already have:
 * - surveys[]
 * - finds[]
 * - resolvePhotoBlob(ref) OR the older idb/dataURL logic you used
 * - resizeBlobToMaxWidthJpeg(blob, maxW, quality)
 */
async function exportAllSurveysGallery_DownloadSingleHtml({ includeTargets = true, includeFinds = true, maxW = 1000 } = {}) {
    const logBox = document.getElementById('export-photo-gallery-log');
    const log = (msg) => {
        console.log('[Gallery Download]', msg);
        if (!logBox) return;
        logBox.value += msg + '\n';
        logBox.scrollTop = logBox.scrollHeight;
    };
    if (logBox) logBox.value = '';

    if (!Array.isArray(surveys) || surveys.length === 0) {
        showMessage('No surveys to export.', 'error');
        return;
    }

    const escapeHtml = (s) => String(s ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');

    const blobToDataUrl = (blob) => new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = () => reject(r.error || new Error('File read failed'));
        r.readAsDataURL(blob);
    });

    async function photoRefToDataUrl(photoRef) {
        if (!photoRef) return '';
        try {
            const raw = await resolvePhotoBlob(photoRef); // your existing helper
            if (!raw) return '';
            const resized = await resizeBlobToMaxWidthJpeg(raw, maxW, 0.85);
            if (!resized) return '';
            return await blobToDataUrl(resized);
        } catch {
            return '';
        }
    }

    // Build master cards + embedded sections
    const cards = [];
    const sections = [];

    log(`Building single HTML gallery for ${surveys.length} surveys...`);
    log(`Max width: ${maxW}px`);

    for (let i = 0; i < surveys.length; i++) {
        const s = surveys[i];
        const title = s?.name || `Survey ${i + 1}`;
        const sid = `survey_${String(s?.id ?? i + 1).replace(/[^a-z0-9]+/gi,'_')}`;

        // Survey thumb (prefer survey photo)
        const surveyPhotoRef = s?.surveyPhotoData || s?.surveyPhotoRef || '';
        let thumb = await photoRefToDataUrl(surveyPhotoRef);

        // If no survey photo, fallback to first find/target photo
        if (!thumb && includeFinds) {
            const sf = (Array.isArray(finds) ? finds : []).find(f => f && f.surveyId === s.id);
            const pref = (sf?.photos && sf.photos[0]) || sf?.photoData || sf?.targetPhotoData || '';
            thumb = await photoRefToDataUrl(pref);
        }
        if (!thumb && includeTargets) {
            const t = Array.isArray(s?.targets) ? s.targets.find(x => x) : null;
            const pref = (t?.photos && t.photos[0]) || t?.targetPhotoData || t?.photoDataUrl || '';
            thumb = await photoRefToDataUrl(pref);
        }

        cards.push(`
          <a class="cardTop" href="#${sid}">
            <div class="thumb">
              ${thumb ? `<img src="${thumb}" alt="${escapeHtml(title)}">`
                     : `<div class="noThumb">No photo</div>`}
            </div>
            <div class="meta">
              <div class="title">${escapeHtml(title)}</div>
              <div class="hint">Jump to gallery</div>
            </div>
          </a>
        `);

        // Build survey section (simple: just show all photos in one stream)
        const photoBlocks = [];

        // Survey photo
        if (surveyPhotoRef) {
            const d = await photoRefToDataUrl(surveyPhotoRef);
            if (d) photoBlocks.push(`<img class="full" src="${d}" alt="Survey photo">`);
        }

        // Finds
        if (includeFinds) {
            const sf = (Array.isArray(finds) ? finds : []).filter(f => f && f.surveyId === s.id);
            for (const f of sf) {
                const refs = Array.isArray(f.photos) && f.photos.length
                    ? f.photos
                    : [f.photoData, f.targetPhotoData, f.photoDataUrl].filter(Boolean);

                for (let p = 0; p < refs.length; p++) {
                    const d = await photoRefToDataUrl(refs[p]);
                    if (d) photoBlocks.push(`<img class="full" src="${d}" alt="Find photo">`);
                }
            }
        }

        // Targets
        if (includeTargets && Array.isArray(s?.targets)) {
            for (const t of s.targets) {
                const refs = Array.isArray(t.photos) && t.photos.length
                    ? t.photos
                    : [t.targetPhotoData, t.photoDataUrl, t.photoRef].filter(Boolean);

                for (let p = 0; p < refs.length; p++) {
                    const d = await photoRefToDataUrl(refs[p]);
                    if (d) photoBlocks.push(`<img class="full" src="${d}" alt="Target photo">`);
                }
            }
        }

        sections.push(`
          <section class="surveySection" id="${sid}">
            <div class="surveyHeader">
              <h2>${escapeHtml(title)}</h2>
              <a href="#top">Back to top</a>
            </div>
            ${photoBlocks.length ? photoBlocks.join('\n') : `<p class="muted">No photos found.</p>`}
          </section>
        `);

        log(`[${i + 1}/${surveys.length}] Added: ${title}`);
    }

    const now = new Date();
    const html = `
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>geoFind Gallery</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#f7f7f7;color:#111}
  header{padding:18px 16px;background:#fff;border-bottom:1px solid #e5e7eb;position:sticky;top:0;z-index:10}
  h1{margin:0;font-size:20px}
  .sub{margin:6px 0 0;color:#444;font-size:13px}
  main{padding:16px;max-width:1100px;margin:0 auto}
  .gridTop{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:14px;margin-bottom:18px}
  a.cardTop{display:block;text-decoration:none;color:inherit;background:#fff;border:1px solid #e5e7eb;border-radius:14px;overflow:hidden;box-shadow:0 4px 14px rgba(0,0,0,.05)}
  .thumb{aspect-ratio:4/3;background:#eee;display:flex;align-items:center;justify-content:center}
  .thumb img{width:100%;height:100%;object-fit:cover;display:block}
  .noThumb{padding:12px;color:#666;font-size:12px;text-align:center}
  .meta{padding:10px 12px}
  .title{font-weight:800;font-size:14px;line-height:1.2}
  .hint{font-size:12px;color:#666;margin-top:4px}
  .surveySection{background:#fff;border:1px solid #e5e7eb;border-radius:16px;padding:14px;margin:18px 0;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  .surveyHeader{display:flex;align-items:center;justify-content:space-between;gap:12px;flex-wrap:wrap}
  .surveyHeader h2{margin:0;font-size:18px}
  .muted{color:#64748b;font-size:13px}
  img.full{width:100%;height:auto;border-radius:14px;border:1px solid #e5e7eb;margin-top:12px;display:block}
</style>
</head>
<body>
<a id="top"></a>
<header>
  <h1>Photo Galleries</h1>
  <p class="sub">Exported ${escapeHtml(now.toLocaleString())} — this file is self-contained (phone-safe).</p>
</header>
<main>
  <div class="gridTop">
    ${cards.join('\n')}
  </div>

  ${sections.join('\n')}
</main>
</body>
</html>`.trim();

    const filename = `geoFind_gallery_${now.toISOString().slice(0,10)}.html`;
    downloadTextFile(filename, html, 'text/html');

    showMessage('Gallery HTML downloaded (check Downloads).', 'success');
    log('DONE: Download triggered.');
}

        
    function showProgressOverlay(title = 'Working...', message = 'Please wait.') {
    const overlay = document.getElementById('progress-overlay');
    if (!overlay) return;

    overlay.classList.remove('hidden');
    overlay.classList.add('flex');

    document.getElementById('progress-title').textContent = title;
    document.getElementById('progress-message').textContent = message;

    updateProgressOverlay(0, 'Starting…');
}

function updateProgressOverlay(percent, detailText = '') {
    const overlay = document.getElementById('progress-overlay');
    if (!overlay || overlay.classList.contains('hidden')) return;

    const p = Math.max(0, Math.min(100, Number(percent) || 0));
    const bar = document.getElementById('progress-bar');
    const pct = document.getElementById('progress-percent');
    const det = document.getElementById('progress-detail');

    if (bar) bar.style.width = `${p}%`;
    if (pct) pct.textContent = `${Math.round(p)}%`;
    if (det) det.textContent = detailText || '';
}

function hideProgressOverlay() {
    const overlay = document.getElementById('progress-overlay');
    if (!overlay) return;

    overlay.classList.add('hidden');
    overlay.classList.remove('flex');
}

        
function hideAppSplash() {
  const el = document.getElementById('app-splash');
  if (!el) return;
  el.style.transition = 'opacity 180ms ease';
  el.style.opacity = '0';
  setTimeout(() => { el.remove(); }, 200);
}

function promptRenameTrack(trackId) {
    const found = findTrackById(trackId);
    if (!found || !found.track) {
        showMessage('Track not found.', 'error');
        return;
    }

    const currentName = String(found.track.name || 'Track').trim();
    const newName = prompt('Rename track:', currentName);

    // User cancelled
    if (newName === null) return;

    const trimmed = String(newName).trim();
    if (!trimmed) {
        showMessage('Track name cannot be blank.', 'warning');
        return;
    }

    // No change
    if (trimmed === currentName) {
        showMessage('No change.', 'info');
        return;
    }

    renameTrack(trackId, trimmed);
}


        
function navViewRadiusMetersForDistance(distMeters) {
    // How many metres from the user to the edge of the mini-map.
    // Bigger far away, tighter when close.
    if (!isFinite(distMeters)) return 40;

    if (distMeters > 200) return 120;
    if (distMeters > 120) return 80;
    if (distMeters > 60)  return 50;
    if (distMeters > 30)  return 30;
    if (distMeters > 15)  return 20;
    return 12; // very close: show fine detail
}

// Holds the chosen folder handle for this session
let photoGalleryExportRootHandle = null;

function turnInstructionFromRelativeAngle(relDeg) {
    // relDeg: -180..+180 (negative = target left, positive = target right)
    const a = Math.abs(relDeg);
    if (a < 10) return 'STRAIGHT';
    if (a < 25) return relDeg > 0 ? 'SLIGHT RIGHT' : 'SLIGHT LEFT';
    if (a < 60) return relDeg > 0 ? 'RIGHT' : 'LEFT';
    if (a < 110) return relDeg > 0 ? 'HARD RIGHT' : 'HARD LEFT';
    return 'TURN AROUND';
}

        
function needsGpsNow() {
    // GPS needed if: user wants to see themselves OR navigation is active OR tracking is recording
    return !!showUserPosition || !!navigationTargetId || isAnyTrackRecording();
}

/** Step 1: user picks a folder; we store the handle and show its name in the textbox. */
// Step 1: Pick folder (FIXED: must be async)
async function pickPhotoGalleryExportFolder() {
    try {
        if (!window.showDirectoryPicker) {
            showMessage('Folder picking is not supported in this browser.', 'error');
            return;
        }

        const handle = await window.showDirectoryPicker();
        photoGalleryExportRootHandle = handle;

        // If you re-render the page, keep this (your UI uses it)
        if (typeof render === 'function') render();

        const box = document.getElementById('gallery-export-folder-name');
        if (box) box.value = handle.name || 'Selected folder';

        showMessage('Folder selected.', 'success');
    } catch (e) {
        // User cancelled folder picker: ignore quietly
        if (e && (e.name === 'AbortError' || String(e.message || '').toLowerCase().includes('aborted'))) {
            showMessage('Folder selection cancelled.', 'info');
            return;
        }
        console.error('pickPhotoGalleryExportFolder error:', e);
        showMessage(`Could not select folder: ${e.message || e}`, 'error');
    }
}


async function exportPhotoGalleryToSelectedFolder() {
    if (!photoGalleryExportRootHandle) {
        showMessage('Please pick a Master folder first (Step 1).', 'error');
        return;
    }

    const opts = {
        createIndex: !!document.getElementById('gallery-opt-create-index')?.checked,

        exportOpen:  !!document.getElementById('gallery-opt-export-open')?.checked,
        exportOther: !!document.getElementById('gallery-opt-export-other')?.checked,

        includeTargetsInHtml: !!document.getElementById('gallery-opt-include-targets')?.checked,
        includeFindsInHtml:   !!document.getElementById('gallery-opt-include-finds')?.checked,

        writeTargetJpgs: !!document.getElementById('gallery-opt-write-target-jpgs')?.checked,
        writeFindJpgs:   !!document.getElementById('gallery-opt-write-find-jpgs')?.checked,

        // sensible defaults (match your previous exporter style)
        maxW: (typeof getMaxPhotoWidth === 'function') ? getMaxPhotoWidth() : 1000
    };

    if (!opts.exportOpen && !opts.exportOther) {
        showMessage('Please select at least one survey scope: Open and/or Other surveys.', 'error');
        return;
    }
    if (!opts.includeTargetsInHtml && !opts.includeFindsInHtml) {
        showMessage('Please select at least one: Export Targets and/or Export Finds (for the gallery).', 'error');
        return;
    }

    // One confirmation, then run
    const msg = `
      Export photo galleries into the selected Master folder?<br>
      ${opts.createIndex ? '<strong>index.html will be created/overwritten.</strong><br>' : ''}
      <span class="text-sm text-gray-600">
        HTML files will be written directly into the chosen folder.
        Optional JPGs will also be written directly into the same folder.
      </span>
    `;
    if (typeof showConfirmationModal === 'function') {
        showConfirmationModal('Export Photo Gallery', msg, async () => {
            if (typeof closeConfirmationModal === 'function') closeConfirmationModal();
            await exportPhotoGalleries_MasterFolder(photoGalleryExportRootHandle, opts);
        });
    } else {
        // If your app doesn’t have a confirm modal in this build
        await exportPhotoGalleries_MasterFolder(photoGalleryExportRootHandle, opts);
    }
}


// Master-folder exporter (no subfolders)
async function exportPhotoGalleries_MasterFolder(rootHandle, opts) {
    const logBox = document.getElementById('export-photo-gallery-log');
    const btn = document.getElementById('export-gallery-to-folder-btn');

    const log = (msg) => {
        console.log('[Gallery Export Master]', msg);
        if (!logBox) return;
        logBox.value += msg + '\n';
        logBox.scrollTop = logBox.scrollHeight;
    };
    if (logBox) logBox.value = '';

    let originalBtnText = '';
    if (btn) {
        originalBtnText = btn.innerText;
        btn.disabled = true;
        btn.innerText = 'Exporting galleries...';
    }

    // Helpers (local, safe)
    const escapeHtml = (s) => String(s ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');

    const safeSlugLocal = (s) => {
        if (typeof safeSlug === 'function') return safeSlug(s);
        return String(s ?? 'survey')
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '')
            .slice(0, 50) || 'survey';
    };

    const blobToDataUrl = (blob) => new Promise((resolve, reject) => {
        const r = new FileReader();
        r.onload = () => resolve(r.result);
        r.onerror = () => reject(r.error || new Error('File read failed'));
        r.readAsDataURL(blob);
    });

    const fmt = (t) => (typeof fmtDateTime === 'function') ? fmtDateTime(t) : String(t ?? '');

    const collectPhotoInputs = (obj, kind) => {
        const out = [];
        const add = (v) => {
            if (!v) return;
            if (Array.isArray(v)) return v.forEach(add);
            const s = String(v).trim();
            if (!s) return;
            out.push(s);
        };

        // Modern arrays
        add(obj?.photos);
        add(obj?.photoRefs);

        // Common single fields
        add(obj?.photoRef);
        add(obj?.photoData);
        add(obj?.photoDataUrl);

        if (kind === 'survey') {
            add(obj?.surveyPhotoRef);
            add(obj?.surveyPhotoData);
            add(obj?.surveyPhotoDataUrl);
        } else if (kind === 'find') {
            add(obj?.findPhotoRef);
            add(obj?.findPhotoData);
            add(obj?.findPhotoDataUrl);
            // legacy
            add(obj?.targetPhotoRef);
            add(obj?.targetPhotoData);
            add(obj?.targetPhotoDataUrl);
        } else if (kind === 'target') {
            add(obj?.targetPhotoRef);
            add(obj?.targetPhotoData);
            add(obj?.targetPhotoDataUrl);
        }

        // Dedup keep order
        const seen = new Set();
        const dedup = [];
        for (const x of out) {
            if (seen.has(x)) continue;
            seen.add(x);
            dedup.push(x);
        }
        return dedup;
    };

    const pickSurveys = () => {
        const all = Array.isArray(surveys) ? surveys : [];
        const open = all.find(s => s && s.status === 'Open');

        let chosen = [];
        if (opts.exportOpen && open) chosen.push(open);

        if (opts.exportOther) {
            chosen = chosen.concat(all.filter(s => s && s.status !== 'Open'));
        }

        // De-dupe by id if present
        const seen = new Set();
        const uniq = [];
        for (const s of chosen) {
            const key = (s && s.id != null) ? `id:${s.id}` : `obj:${uniq.length}`;
            if (seen.has(key)) continue;
            seen.add(key);
            uniq.push(s);
        }
        return { uniq, openExists: !!open };
    };

    const { uniq: chosenSurveys, openExists } = pickSurveys();
    if (opts.exportOpen && !openExists) {
        showMessage('No Open survey found. Either open one, or uncheck “Export Open survey”.', 'error');
        if (btn) { btn.disabled = false; btn.innerText = originalBtnText || 'Export'; }
        return;
    }
    if (chosenSurveys.length === 0) {
        showMessage('No surveys matched your selection.', 'error');
        if (btn) { btn.disabled = false; btn.innerText = originalBtnText || 'Export'; }
        return;
    }

    // Ensure unique HTML filenames even if survey names collide
    const usedHtmlNames = new Set();
    const uniqueHtmlName = (base) => {
        let name = base;
        let n = 2;
        while (usedHtmlNames.has(name)) name = base.replace(/\.html$/i, '') + `_${n++}.html`;
        usedHtmlNames.add(name);
        return name;
    };

    // JPG naming de-dupe (avoid overwrites)
    const usedJpgNames = new Set();
    const uniqueJpgName = (base) => {
        let name = base;
        let n = 2;
        while (usedJpgNames.has(name)) name = base.replace(/\.jpg$/i, '') + `_${n++}.jpg`;
        usedJpgNames.add(name);
        return name;
    };

    // Write helper
    const writeFile = async (name, blob) => {
        const fh = await rootHandle.getFileHandle(name, { create: true });
        const w = await fh.createWritable();
        await w.write(blob);
        await w.close();
    };

    // This builds ONE survey gallery HTML and optionally writes JPGs (all in master folder)
    async function buildSurveyGallery({ survey }) {
        const surveyName = survey?.name || 'Survey';
        const surveyIdShort = String(survey?.id ?? '').slice(0, 8);
        const surveySlug = safeSlugLocal(surveyName);

        // Output HTML filename
        const htmlBase = `gallery__${surveySlug}${surveyIdShort ? `__${surveyIdShort}` : ''}.html`;
        const htmlName = uniqueHtmlName(htmlBase);

        // Build items list (one item per photo)
        const items = [];

        // Survey photo (hero only, not counted as “find/target”)
        const surveyPhotos = collectPhotoInputs(survey, 'survey');
        const surveyHeroInput = surveyPhotos[0] || '';

        // Finds
        const surveyFinds = (Array.isArray(finds) ? finds : []).filter(f => f && f.surveyId === survey.id);
        if (opts.includeFindsInHtml) {
            for (const f of surveyFinds) {
                const photoInputs = collectPhotoInputs(f, 'find');
                for (let i = 0; i < photoInputs.length; i++) {
                    items.push({
                        kind: 'find',
                        parentId: f.id,
                        indexInParent: i + 1,
                        title: f.description || f.name || `Find ${f.id}`,
                        vdi: f.vdi || '',
                        type: f.type || '',
                        depth: f.depth || '',
                        time: f.time || f.date || '',
                        coords: f.coordinates || '',
                        accuracy: f.accuracy || '',
                        photoInput: photoInputs[i]
                    });
                }
            }
        }

        // Targets
        const surveyTargets = Array.isArray(survey.targets) ? survey.targets : [];
        if (opts.includeTargetsInHtml) {
            for (const t of surveyTargets) {
                const photoInputs = collectPhotoInputs(t, 'target');
                for (let i = 0; i < photoInputs.length; i++) {
                    items.push({
                        kind: 'target',
                        parentId: t.id,
                        indexInParent: i + 1,
                        title: t.description || `Target ${t.id}`,
                        vdi: t.vdi || t.targetId || '',
                        type: t.type || '',
                        depth: t.depth || '',
                        time: t.time || '',
                        coords: t.coordinates || '',
                        accuracy: t.accuracy || '',
                        photoInput: photoInputs[i]
                    });
                }
            }
        }

        if (!surveyHeroInput && items.length === 0) {
            return null; // nothing to export for this survey
        }

        // Convert photo input -> resized jpeg blob -> dataURL (embedded)
        async function inputToEmbeddedDataUrl(photoInput) {
            const raw = await resolvePhotoBlob(photoInput);
            if (!raw) return '';
            const resized = await resizeBlobToMaxWidthJpeg(raw, opts.maxW, 0.85);
            if (!resized) return '';
            return await blobToDataUrl(resized);
        }

        // Optional: write JPG files (still embed in HTML)
        async function maybeWriteJpg(kind, parentId, indexInParent, embeddedDataUrl) {
            if (!embeddedDataUrl || !embeddedDataUrl.startsWith('data:image/')) return null;

            const shouldWrite =
                (kind === 'find' && opts.writeFindJpgs) ||
                (kind === 'target' && opts.writeTargetJpgs);

            if (!shouldWrite) return null;

            // Convert dataURL -> blob
            const res = await fetch(embeddedDataUrl);
            const blob = await res.blob();

            const base = `${surveySlug}__${kind}__${safeSlugLocal(parentId)}__p${String(indexInParent).padStart(2, '0')}.jpg`;
            const jpgName = uniqueJpgName(base);

            await writeFile(jpgName, blob);
            return jpgName;
        }

        // Build hero
        let heroHtml = '';
        if (surveyHeroInput) {
            const heroDataUrl = await inputToEmbeddedDataUrl(surveyHeroInput);
            if (heroDataUrl) {
                heroHtml = `<div class="hero"><img src="${escapeHtml(heroDataUrl)}" alt="Survey photo"></div>`;
            }
        }

        // Build cards and full sections
        const findCards = [];
        const targetCards = [];
        const fullSections = [];

        for (let i = 0; i < items.length; i++) {
            const it = items[i];
            const anchorId = `${it.kind}_${safeSlugLocal(it.parentId)}_${String(it.indexInParent).padStart(2, '0')}`;

            const dataUrl = await inputToEmbeddedDataUrl(it.photoInput);
            if (!dataUrl) continue;

            // optional JPG write (extra)
            await maybeWriteJpg(it.kind, it.parentId, it.indexInParent, dataUrl);

            const card = `
              <div class="card">
                <a class="thumbLink" href="#${anchorId}">
                  <img src="${escapeHtml(dataUrl)}" alt="${escapeHtml(it.title)}">
                </a>
                <div class="cap">
                  <div class="title">${escapeHtml(it.title)}</div>
                  <div class="metaLine">${escapeHtml(it.vdi)} ${it.type ? '· ' + escapeHtml(it.type) : ''}</div>
                  <div class="metaLine">${escapeHtml(fmt(it.time))}</div>
                </div>
              </div>
            `;

            if (it.kind === 'find') findCards.push(card);
            else targetCards.push(card);

            fullSections.push(`
              <div class="detail" id="${anchorId}">
                <p class="back"><a href="#top">↑ Back to top</a></p>
                <h3>${escapeHtml(it.title)}</h3>
                <p class="muted">${escapeHtml(it.kind)} photo ${it.indexInParent}</p>
                <img class="full" src="${escapeHtml(dataUrl)}" alt="${escapeHtml(it.title)}">
                <ul class="meta">
                  ${it.type ? `<li><strong>Type:</strong> ${escapeHtml(it.type)}</li>` : ''}
                  ${it.vdi ? `<li><strong>VDI/ID:</strong> ${escapeHtml(it.vdi)}</li>` : ''}
                  ${it.depth ? `<li><strong>Depth:</strong> ${escapeHtml(it.depth)}</li>` : ''}
                  ${it.time ? `<li><strong>Date/Time:</strong> ${escapeHtml(fmt(it.time))}</li>` : ''}
                  ${it.coords ? `<li><strong>Coordinates:</strong> ${escapeHtml(it.coords)}</li>` : ''}
                  ${it.accuracy ? `<li><strong>Accuracy:</strong> ${escapeHtml(it.accuracy)}</li>` : ''}
                  <li><strong>Parent ID:</strong> ${escapeHtml(it.parentId)}</li>
                  <li><strong>Photo #:</strong> ${it.indexInParent}</li>
                </ul>
                <hr>
              </div>
            `);
        }

        const html = `<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>Gallery — ${escapeHtml(surveyName)}</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:18px;color:#111;background:#f8fafc;}
  .wrap{max-width:1200px;margin:0 auto;}
  .box{background:#fff;border:1px solid #e5e7eb;border-left:6px solid #0ea5e9;border-radius:14px;padding:16px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  h1{margin:0 0 8px 0;font-size:26px}
  h2{margin:22px 0 10px 0}
  h3{margin:8px 0 10px 0}
  .muted{color:#64748b;font-size:14px}

  .hero{background:#fff;border:1px solid #e5e7eb;border-radius:14px;overflow:hidden;box-shadow:0 6px 18px rgba(0,0,0,0.06); margin-top:12px;}
  .hero img{width:100%;height:auto;display:block;}

  .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:12px}
  @media (max-width:900px){.grid{grid-template-columns:repeat(2,minmax(0,1fr));}}
  @media (max-width:520px){.grid{grid-template-columns:repeat(2,minmax(0,1fr));}}

  .card{background:#fff;border:1px solid #e5e7eb;border-radius:14px;overflow:hidden;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  .card img{width:100%;height:200px;object-fit:cover;display:block}
  .cap{padding:10px}
  .title{font-weight:800;font-size:14px;margin-bottom:4px}
  .metaLine{font-size:12px;color:#64748b}
  a.thumbLink{text-decoration:none;color:inherit}

  .detail{background:#fff;border:1px solid #e5e7eb;border-radius:14px;padding:14px;margin-top:14px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  img.full{width:100%;height:auto;border-radius:12px;border:1px solid #e5e7eb}
  .meta{margin:12px 0 0 0;padding:0;list-style:none}
  .meta li{padding:6px 0;border-bottom:1px solid #f1f5f9}
  .back{margin:0 0 8px 0}
</style>
</head>
<body>
<a id="top"></a>
<div class="wrap">
  <div class="box">
    <h1>${escapeHtml(surveyName)}</h1>
    <p class="muted">Exported ${escapeHtml(new Date().toLocaleString())}</p>
    <p class="muted">File: ${escapeHtml(htmlName)}</p>
  </div>

  ${heroHtml}

  ${opts.includeFindsInHtml ? `<h2>Finds</h2><div class="grid">${findCards.join('')}</div>` : ``}
  ${opts.includeTargetsInHtml ? `<h2>Targets</h2><div class="grid">${targetCards.join('')}</div>` : ``}

  <h2>Full Photos</h2>
  ${fullSections.join('')}

  <p class="muted" style="margin-top:22px;">Generated by geoFind.</p>
</div>
</body>
</html>`;

        await writeFile(htmlName, new Blob([html], { type: 'text/html' }));

        // thumbnail for master index: prefer hero, else first item
        let thumbDataUrl = '';
        if (surveyHeroInput) thumbDataUrl = await inputToEmbeddedDataUrl(surveyHeroInput);
        if (!thumbDataUrl && items[0]) thumbDataUrl = await inputToEmbeddedDataUrl(items[0].photoInput);

        return { surveyName, htmlName, thumbDataUrl };
    }

    try {
        log(`Selected Master folder: ${photoGalleryExportRootHandle?.name || '(folder)'}`);
        log(`Surveys to export: ${chosenSurveys.length}`);
        log(`Include Targets in HTML: ${opts.includeTargetsInHtml ? 'YES' : 'NO'}`);
        log(`Include Finds in HTML: ${opts.includeFindsInHtml ? 'YES' : 'NO'}`);
        log(`Write Target JPGs: ${opts.writeTargetJpgs ? 'YES' : 'NO'}`);
        log(`Write Find JPGs: ${opts.writeFindJpgs ? 'YES' : 'NO'}`);
        log(`Create index.html: ${opts.createIndex ? 'YES' : 'NO'}`);
        log(`Max photo width: ${opts.maxW}px`);
        log('---');

        const masterEntries = [];

        for (let i = 0; i < chosenSurveys.length; i++) {
            const s = chosenSurveys[i];
            const title = s?.name || `Survey ${i + 1}`;
            log(`\n[${i + 1}/${chosenSurveys.length}] Building: ${title}`);

            const result = await buildSurveyGallery({ survey: s });
            if (!result) {
                log(`SKIP: No photos found for "${title}".`);
                continue;
            }
            log(`Wrote: ${result.htmlName}`);
            masterEntries.push(result);
        }

        if (opts.createIndex && masterEntries.length > 0) {
            const now = new Date();
            const idxHtml = `
<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>geoFind — Galleries</title>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#f7f7f7;color:#111}
    header{padding:18px 16px;background:#fff;border-bottom:1px solid #e5e7eb}
    h1{margin:0;font-size:20px}
    p{margin:6px 0 0;color:#444;font-size:13px}
    main{padding:16px;max-width:1100px;margin:0 auto}
    .grid{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:14px}
    a.card{display:block;text-decoration:none;color:inherit;background:#fff;border:1px solid #e5e7eb;border-radius:14px;overflow:hidden;box-shadow:0 4px 14px rgba(0,0,0,.05)}
    .thumb{aspect-ratio:4/3;background:#eee;display:flex;align-items:center;justify-content:center}
    .thumb img{width:100%;height:100%;object-fit:cover;display:block}
    .meta{padding:10px 12px}
    .title{font-weight:800;font-size:14px;line-height:1.2}
    .hint{font-size:12px;color:#666;margin-top:4px}
    .file{font-size:11px;color:#94a3b8;margin-top:4px;word-break:break-all}
  </style>
</head>
<body>
  <header>
    <h1>Photo Galleries</h1>
    <p>Exported ${escapeHtml(now.toLocaleString())} — tap a survey to open its gallery.</p>
  </header>
  <main>
    <div class="grid">
      ${masterEntries.map(e => `
        <a class="card" href="./${encodeURIComponent(e.htmlName)}">
          <div class="thumb">
            ${e.thumbDataUrl
                ? `<img src="${e.thumbDataUrl}" alt="${escapeHtml(e.surveyName)}">`
                : `<div style="padding:12px;color:#666;font-size:12px;text-align:center">No photo</div>`
            }
          </div>
          <div class="meta">
            <div class="title">${escapeHtml(e.surveyName)}</div>
            <div class="hint">Open gallery</div>
            <div class="file">${escapeHtml(e.htmlName)}</div>
          </div>
        </a>
      `).join('')}
    </div>
  </main>
</body>
</html>`.trim();

            await writeFile('index.html', new Blob([idxHtml], { type: 'text/html' }));
            log('\nWrote/overwrote: index.html');
        } else {
            log('\nNo master index written (option disabled, or no galleries created).');
        }

        showMessage('Gallery export complete.', 'success');
        log('\nDONE.');
    } catch (e) {
        console.error('exportPhotoGalleries_MasterFolder error:', e);
        showMessage(`Export failed: ${e.message || e}`, 'error');
    } finally {
        if (btn) {
            btn.disabled = false;
            btn.innerText = originalBtnText || 'Step 2: Export to Master Folder';
        }
    }
}

    function safeSlug(str) {
    return String(str || '')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '') || 'item';
}

function fmtDateTime(ts) {
    if (!ts) return '';
    try { return new Date(ts).toLocaleString(); } catch { return String(ts); }
}

function escapeHtml(str) {
    return String(str ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');
}

// Resolve one photo ref or dataURL into a Blob
async function resolvePhotoBlob(refOrDataUrl) {
    if (!refOrDataUrl) return null;

    // IndexedDB ref: "idb:123"
    if (typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(refOrDataUrl)) {
        const id = parsePhotoRef(refOrDataUrl);
        if (id == null) return null;
        return await loadPhotoBlob(id);
    }

    // Legacy: data URL
    if (typeof refOrDataUrl === 'string' && refOrDataUrl.startsWith('data:image/')) {
        return await dataUrlToBlob(refOrDataUrl);
    }

    return null;
}

/**
 * Resize an image Blob to maxWidth (keeps aspect ratio) and return JPEG Blob.
 * Uses your Settings Max Photo Width via getMaxPhotoWidth().
 */
async function resizeBlobToMaxWidthJpeg(blob, maxWidth, quality = 0.85) {
    if (!blob) return null;
    if (!maxWidth || maxWidth < 1) return blob; // 0 => no resize

    const dataUrl = await blobToDataUrl(blob); // you already have this helper in your export path
    const img = await new Promise((resolve, reject) => {
        const im = new Image();
        im.onload = () => resolve(im);
        im.onerror = reject;
        im.src = dataUrl;
    });

    const srcW = img.naturalWidth || img.width;
    const srcH = img.naturalHeight || img.height;
    if (!srcW || !srcH) return blob;

    if (srcW <= maxWidth) {
        // Still convert to JPEG to keep exports consistent/small
        const canvas = document.createElement('canvas');
        canvas.width = srcW;
        canvas.height = srcH;
        const ctx = canvas.getContext('2d');
        ctx.drawImage(img, 0, 0);
        return await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', quality));
    }

    const scale = maxWidth / srcW;
    const dstW = Math.round(srcW * scale);
    const dstH = Math.round(srcH * scale);

    const canvas = document.createElement('canvas');
    canvas.width = dstW;
    canvas.height = dstH;
    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(img, 0, 0, dstW, dstH);

    return await new Promise(resolve => canvas.toBlob(resolve, 'image/jpeg', quality));
}

async function blobToArrayBuffer(blob) {
    return await blob.arrayBuffer();
}

async function writeFileToHandle(dirHandle, filename, blob) {
    const fileHandle = await dirHandle.getFileHandle(filename, { create: true });
    const writable = await fileHandle.createWritable();
    await writable.write(blob);
    await writable.close();
}

// Create (or get) a sub-directory
async function getOrCreateDir(parentHandle, name) {
    return await parentHandle.getDirectoryHandle(name, { create: true });
}

        
        
        function loadPhotoSettingsFromLocalStorage() {
    try {
        const raw = localStorage.getItem(PHOTO_SETTINGS_KEY);
        if (!raw) return;

        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed.maxWidth === 'number' && !isNaN(parsed.maxWidth)) {
            photoSettings.maxWidth = parsed.maxWidth;
        }
    } catch (e) {
        console.warn('Could not load photo settings:', e);
    }
}

function loadNavOverlaySettingsFromLocalStorage() {
    try {
        const raw = localStorage.getItem(NAV_OVERLAY_SETTINGS_KEY);
        if (!raw) return;

        const parsed = JSON.parse(raw);
        if (parsed && typeof parsed === 'object') {
            if (typeof parsed.aboveOffsetPct === 'number') navOverlaySettings.aboveOffsetPct = parsed.aboveOffsetPct;
            if (typeof parsed.belowOffsetPct === 'number') navOverlaySettings.belowOffsetPct = parsed.belowOffsetPct;
        }
    } catch (e) {
        console.warn('Failed to load nav overlay settings:', e);
    }

    // Clamp to safe ranges
    navOverlaySettings.aboveOffsetPct = Math.max(10, Math.min(80, Number(navOverlaySettings.aboveOffsetPct) || 50));
    navOverlaySettings.belowOffsetPct = Math.max(0, Math.min(30, Number(navOverlaySettings.belowOffsetPct) || 6));
}

function saveNavOverlaySettingsToLocalStorage() {
    try {
        localStorage.setItem(NAV_OVERLAY_SETTINGS_KEY, JSON.stringify(navOverlaySettings));
    } catch (e) {
        console.warn('Failed to save nav overlay settings:', e);
    }
}

function getNavOverlayAboveOffsetPct() {
    const v = Number(navOverlaySettings.aboveOffsetPct);
    return isNaN(v) ? 50 : v;
}

function getNavOverlayBelowOffsetPct() {
    const v = Number(navOverlaySettings.belowOffsetPct);
    return isNaN(v) ? 6 : v;
}

        
function savePhotoSettingsToLocalStorage() {
    try {
        localStorage.setItem(PHOTO_SETTINGS_KEY, JSON.stringify(photoSettings));
    } catch (e) {
        console.warn('Could not save photo settings:', e);
    }
}

function getMaxPhotoWidth() {
    const w = Number(photoSettings && photoSettings.maxWidth);
    // 0 or NaN => treat as "no resize"
    return (!w || isNaN(w) || w < 1) ? 0 : Math.round(w);
}
function fileToDataUrl(file) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = (e) => resolve(e.target.result);
        reader.onerror = () => reject(reader.error || new Error('File read failed'));
        reader.readAsDataURL(file);
    });
}

function loadImageFromDataUrl(dataUrl) {
    return new Promise((resolve, reject) => {
        const img = new Image();
        img.onload = () => resolve(img);
        img.onerror = () => reject(new Error('Image decode failed'));
        img.src = dataUrl;
    });
}

/**
 * Resize a dataURL down to maxWidth (keeps aspect ratio).
 * If the image is already <= maxWidth, returns original dataUrl.
 * Output format: JPEG (good size reduction). Quality tweakable.
 */
async function resizeDataUrlToMaxWidth(dataUrl, maxWidth) {
    if (!dataUrl || typeof dataUrl !== 'string') return '';
    if (!maxWidth || maxWidth < 1) return dataUrl; // 0 => no resizing

    const img = await loadImageFromDataUrl(dataUrl);

    const srcW = img.naturalWidth || img.width;
    const srcH = img.naturalHeight || img.height;

    if (!srcW || !srcH) return dataUrl;
    if (srcW <= maxWidth) return dataUrl;

    const scale = maxWidth / srcW;
    const dstW = Math.round(srcW * scale);
    const dstH = Math.round(srcH * scale);

    const canvas = document.createElement('canvas');
    canvas.width = dstW;
    canvas.height = dstH;

    const ctx = canvas.getContext('2d');
    ctx.imageSmoothingEnabled = true;
    ctx.imageSmoothingQuality = 'high';
    ctx.drawImage(img, 0, 0, dstW, dstH);

    // JPEG saves lots of space. (If you really need PNG, we can add a toggle.)
    const quality = 0.85;
    return canvas.toDataURL('image/jpeg', quality);
}

/**
 * Full pipeline: File -> dataUrl -> resized dataUrl (based on Settings)
 */
async function fileToResizedDataUrl(file) {
    const dataUrl = await fileToDataUrl(file);
    const maxW = getMaxPhotoWidth();
    return await resizeDataUrlToMaxWidth(dataUrl, maxW);
}

// NEW: smoothed position for the live map
        let smoothedUserCoords = null;
        const USER_SMOOTHING_ALPHA = 0.15; // 0 < alpha ≤ 1 (lower = smoother, slower)
// --- TRACK RECORDING STATE ---
        let activeTrackSurveyId = null;
        let activeTrackId = null;
        const TRACK_POINT_MIN_DISTANCE_METERS = 3; // only log a point if you've moved at least this far

function isAnyTrackRecording() {
    return Boolean(activeTrackId && activeTrackSurveyId);
}
        

function ensureTrackingThen(fn) {
    // If already recording, run immediately
    if (typeof isAnyTrackRecording === 'function' && isAnyTrackRecording()) {
        fn();
        return;
    }

    // Start a new track
    if (typeof handleStartTrackClick === 'function') {
        handleStartTrackClick();
    }

    // Give the GPS/watch a brief moment to populate coords.
    // If coords already exist, this returns almost immediately.
    const start = Date.now();
    const maxWaitMs = 1200;     // short, keeps UI snappy
    const tickMs = 100;

    const timer = setInterval(() => {
        const gps = smoothedUserCoords || currentUserCoords;
        const hasFix = gps && typeof gps.lat === 'number' && typeof gps.lon === 'number' && !isNaN(gps.lat) && !isNaN(gps.lon);

        if (hasFix || (Date.now() - start) >= maxWaitMs) {
            clearInterval(timer);
            fn();
        }
    }, tickMs);
}

        
function pickTrackColor(index) {
    const palette = [
        'rgba(59,130,246,0.9)',  // blue
        'rgba(239,68,68,0.9)',   // red
        'rgba(34,197,94,0.9)',   // green
        'rgba(245,158,11,0.9)',  // amber
        'rgba(168,85,247,0.9)',  // purple
        'rgba(20,184,166,0.9)',  // teal
        'rgba(236,72,153,0.9)',  // pink
        'rgba(100,116,139,0.9)'  // slate
    ];
    return palette[Math.abs(index) % palette.length];
}

function clearNavigationTarget() {
    navigationTargetId = null;

    if (navSession) {
        navSession.active = false;
        navSession.path = [];
        navSession.startLat = null;
        navSession.startLon = null;
        navSession.lastLat = null;
        navSession.lastLon = null;
        navSession.baseBearingDeg = null;
    }

    showMessage('Navigation target cleared.', 'info');

    if (currentPage === 'Compass') {
        render();
    }
}

        
    function clearStaleRecordingTracksOnLoad() {
    let changed = false;

    if (!Array.isArray(surveys)) return;

    for (const survey of surveys) {
        if (!survey || !Array.isArray(survey.tracks)) continue;

        for (const t of survey.tracks) {
            if (t && t.isRecording) {
                t.isRecording = false;
                changed = true;
            }
        }
    }

    // Clear runtime state too (so Start works immediately)
    activeTrackSurveyId = null;
    activeTrackId = null;
    isTrackingActive = false;

    if (changed) {
        saveSurveysToLocalStorage();
    }
}


function resetLiveTrackingAndRecordingState() {
    // Stop UI auto refresh
    if (typeof stopCompassAutoRefresh === 'function') stopCompassAutoRefresh();

    // Stop GPS watch + clear live location state
    if (typeof stopLiveMapLocationWatch === 'function') {
        stopLiveMapLocationWatch();
    } else {
        // fallback
        try {
            if (typeof liveMapWatchId !== 'undefined' && liveMapWatchId) {
                navigator.geolocation.clearWatch(liveMapWatchId);
            }
        } catch (e) {}
        liveMapWatchId = null;
        bestLiveAccuracy = Infinity;
        smoothedUserCoords = null;
        currentUserCoords = null;
        currentUserAccuracy = null;
        movementHistory = [];
    }

    // Reset tracking flag
    isTrackingActive = false;

    // Reset track recording state (use the names you already have)
    // These are common in your app; keep whichever exist in your code.
    if (typeof isRecordingTrack !== 'undefined') isRecordingTrack = false;
    if (typeof currentRecordingTrackId !== 'undefined') currentRecordingTrackId = null;
    if (typeof activeTrackId !== 'undefined') activeTrackId = null;
    if (typeof lastRecordedCoords !== 'undefined') lastRecordedCoords = null;
    if (typeof lastRecordedPoint !== 'undefined') lastRecordedPoint = null;

    console.log("Live tracking + track recording state reset (survey changed).");
}

        
        function updateSmoothedUserCoords(newLat, newLon) {
    // First reading: snap straight to the new value
    if (!smoothedUserCoords) {
        smoothedUserCoords = { lat: newLat, lon: newLon };
        return;
    }

    // Exponential moving average
    smoothedUserCoords.lat =
        smoothedUserCoords.lat + USER_SMOOTHING_ALPHA * (newLat - smoothedUserCoords.lat);
    smoothedUserCoords.lon =
        smoothedUserCoords.lon + USER_SMOOTHING_ALPHA * (newLon - smoothedUserCoords.lon);
}

// =====================
//  INDEXEDDB FOR PHOTOS
// =====================

// DB / store names
const PHOTO_DB_NAME    = 'geoFindDB';
const PHOTO_DB_VERSION = 1;
const PHOTO_STORE_NAME = 'photos';

// Simple prefix to mark "this is an IndexedDB photo reference"
const PHOTO_REF_PREFIX = 'idb:';

function resetAllAppData() {
    if (!confirm("⚠️ WARNING:\n\nThis will permanently delete ALL saved Surveys, Targets, Finds and Photos stored locally on THIS device.\n\nThis cannot be undone.\n\nDo you want to continue?")) {
        return;
    }

    try {
        // Clear localStorage keys
        localStorage.clear();

        // Clear IndexedDB photo database
        indexedDB.deleteDatabase('geoFindDB');

        alert("All local app data has been deleted.\nThe app will now restart.");
        location.reload();
    } catch (e) {
        console.error("Failed to reset app data:", e);
        alert("Could not reset app data.");
    }
}
        
/**
 * Opens (or creates) our photo database.
 * Returns a Promise that resolves to the DB instance.
 */
function openPhotoDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(PHOTO_DB_NAME, PHOTO_DB_VERSION);

        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(PHOTO_STORE_NAME)) {
                // Simple auto-increment numeric key: 1, 2, 3, ...
                db.createObjectStore(PHOTO_STORE_NAME, { keyPath: 'id', autoIncrement: true });
            }
        };

        request.onsuccess = () => resolve(request.result);
        request.onerror   = () => reject(request.error);
    });
}

/**
 * Save a Blob (photo) into IndexedDB.
 * Resolves to the numeric ID.
 */
async function savePhotoBlob(blob) {
    const db = await openPhotoDB();
    return new Promise((resolve, reject) => {
        const tx    = db.transaction(PHOTO_STORE_NAME, 'readwrite');
        const store = tx.objectStore(PHOTO_STORE_NAME);

        const request = store.add({
            blob,
            createdAt: Date.now()
        });

        request.onsuccess = () => resolve(request.result); // numeric ID
        request.onerror   = () => reject(request.error);
    });
}

/**
 * Load a Blob (photo) from IndexedDB by ID.
 * Resolves to the Blob or null.
 */
async function loadPhotoBlob(id) {
    const db = await openPhotoDB();
    return new Promise((resolve, reject) => {
        const tx    = db.transaction(PHOTO_STORE_NAME, 'readonly');
        const store = tx.objectStore(PHOTO_STORE_NAME);

        const request = store.get(id);
        request.onsuccess = () => {
            const record = request.result;
            resolve(record ? record.blob : null);
        };
        request.onerror = () => reject(request.error);
    });
}

/**
 * Optional: delete a photo blob by ID (for when you delete targets/finds later).
 */
async function deletePhotoBlob(id) {
    const db = await openPhotoDB();
    return new Promise((resolve, reject) => {
        const tx    = db.transaction(PHOTO_STORE_NAME, 'readwrite');
        const store = tx.objectStore(PHOTO_STORE_NAME);

        const request = store.delete(id);
        request.onsuccess = () => resolve(true);
        request.onerror   = () => reject(request.error);
    });
}


// ========================
//  PHOTO REFERENCE HELPERS
// ========================

/**
 * Build a reference string from a numeric ID, eg "idb:5".
 */
function makePhotoRef(id) {
    return `${PHOTO_REF_PREFIX}${id}`;
}

/**
 * Check if a string is an IndexedDB photo reference.
 */
function isIndexedDbPhotoRef(ref) {
    return typeof ref === 'string' && ref.startsWith(PHOTO_REF_PREFIX);
}

/**
 * Extract the numeric ID from a reference string, eg "idb:5" -> 5.
 */
function parsePhotoRef(ref) {
    if (!isIndexedDbPhotoRef(ref)) return null;
    const num = Number(ref.slice(PHOTO_REF_PREFIX.length));
    return Number.isFinite(num) ? num : null;
}

/**
 * Convert a data URL (base64) to a Blob using fetch.
 * Works offline because it's a data: URL.
 */
async function dataUrlToBlob(dataUrl) {
    const response = await fetch(dataUrl);
    return await response.blob();
}

/**
 * Given an array of data URLs, store them in IndexedDB and
 * return an array of references, e.g. ["idb:1", "idb:2"].
 */
async function saveDataUrlsAsPhotoRefs(dataUrls) {
    const refs = [];
    for (const url of dataUrls) {
        if (typeof url !== 'string' || !url) continue;
        const blob = await dataUrlToBlob(url);
        const id   = await savePhotoBlob(blob);
        refs.push(makePhotoRef(id));
    }
    return refs;
}

/**
 * Given a single reference ("idb:5"), return an object URL you can use as img.src.
 * Resolves to null if not found.
 */
async function getPhotoUrlFromRef(ref) {
    // If we ever had plain data URLs in refs, we could handle them here:
    if (typeof ref !== 'string' || !ref) return null;

    // In the new world we only use "idb:NNN"
    const id = parsePhotoRef(ref);
    if (id == null) {
        // If you *later* want to support old base64 refs, you could:
        // if (ref.startsWith('data:image/')) return ref;
        return null;
    }

    const blob = await loadPhotoBlob(id);
    if (!blob) return null;

    return URL.createObjectURL(blob);
}

/**
 * For galleries: turn ["idb:1", "idb:2"] into an array of object URLs.
 */
async function loadPhotoUrlsFromRefs(refs) {
    const urls = [];
    for (const ref of refs || []) {
        const url = await getPhotoUrlFromRef(ref);
        if (url) urls.push(url);
    }
    return urls;
}

 // ======================================
// SHARED STORAGE HELPERS
// ======================================

// Helper: return only non-deleted targets for a survey
function getActiveTargets(survey) {
    if (!survey || !Array.isArray(survey.targets)) return [];
    return survey.targets.filter(t => !t.deleted);
}

function saveCollectionToStorage(key, data) {
    try {
        localStorage.setItem(key, JSON.stringify(data));
    } catch (err) {
        console.error(`Error saving ${key} to localStorage:`, err);

        // Detect quota errors across different browsers
        const isQuotaError =
            err &&
            (
                err.name === 'QuotaExceededError' ||
                err.name === 'NS_ERROR_DOM_QUOTA_REACHED' ||
                err.code === 22 ||          // some WebKit
                err.code === 1014           // some Firefox
            );

        if (isQuotaError) {
            showMessage(
                "Storage quota exceeded. Consider exporting and clearing old data.",
                'error'
            );
        } else {
            // For other errors, just log them.
            // If you really want a toast, you could downgrade it to 'warning':
            // showMessage(`Problem saving ${key}. See console for details.`, 'warning');
        }
    }
}

function loadCollectionFromStorage(key, fallback = []) {
    try {
        const raw = localStorage.getItem(key);
        if (!raw) return fallback;

        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : fallback;
    } catch (err) {
        console.error(`Error loading ${key} from localStorage:`, err);
        showMessage(`Could not load ${key} from local storage. Using defaults.`, 'warning');
        return fallback;
    }
}
       
// --- GEOGRAPHY HELPER FUNCTIONS ---

/** Converts degrees to radians. */
function toRad(degrees) {
    return degrees * (Math.PI / 180);
}

/** Converts radians to degrees. */
function toDeg(radians) {
    return radians * (180 / Math.PI);
}

/**
 * Normalises a longitude delta to the range [-180, 180] degrees.
 * This is what makes things behave correctly across the International Date Line.
 */
function normaliseDeltaLonDegrees(lon1Deg, lon2Deg) {
    let d = lon2Deg - lon1Deg; // in degrees
    if (d > 180) d -= 360;
    if (d < -180) d += 360;
    return d;
}

/**
 * Returns the great-circle distance between two WGS84 coordinates in metres.
 * Works globally (north/south of equator, across date line, any hemisphere).
 */
function distanceMeters(lat1Deg, lon1Deg, lat2Deg, lon2Deg) {
    const R = 6371000; // mean Earth radius in metres

    const φ1 = toRad(lat1Deg);
    const φ2 = toRad(lat2Deg);
    const Δφ = toRad(lat2Deg - lat1Deg);
    const Δλ = toRad(normaliseDeltaLonDegrees(lon1Deg, lon2Deg));

    const sinΔφ2 = Math.sin(Δφ / 2);
    const sinΔλ2 = Math.sin(Δλ / 2);

    const a =
        sinΔφ2 * sinΔφ2 +
        Math.cos(φ1) * Math.cos(φ2) * sinΔλ2 * sinΔλ2;

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
}

// Backwards-compat alias (older code expects this name)
function haversineDistanceMetres(lat1, lon1, lat2, lon2) {
    return distanceMeters(lat1, lon1, lat2, lon2);
}

// Optional extra alias in case any older code used this spelling
function haversineDistanceMeters(lat1, lon1, lat2, lon2) {
    return distanceMeters(lat1, lon1, lat2, lon2);
}



// Alias used by navigation code (legacy name)
function metersBetweenLatLon(lat1, lon1, lat2, lon2) {
    return haversineDistanceMeters(lat1, lon1, lat2, lon2);
}

/**
 * Returns the initial bearing (forward azimuth) from point 1 to point 2
 * in degrees from true North, normalised to [0, 360).
 *
 * This also uses the normalised longitude delta so it behaves
 * correctly when crossing the date line.
 */
function initialBearingDegrees(lat1Deg, lon1Deg, lat2Deg, lon2Deg) {
    const φ1 = toRad(lat1Deg);
    const φ2 = toRad(lat2Deg);
    const Δλ = toRad(normaliseDeltaLonDegrees(lon1Deg, lon2Deg));

    const y = Math.sin(Δλ) * Math.cos(φ2);
    const x =
        Math.cos(φ1) * Math.sin(φ2) -
        Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

    let θ = Math.atan2(y, x); // in radians, -π..+π
    let bearing = (toDeg(θ) + 360) % 360; // into [0, 360)
    return bearing;
}

// ------------------------------------------------------
// NAVIGATION COMPATIBILITY WRAPPERS (do not remove)
// Some parts of the app (or older cached versions) call these names.
// The core implementations in this file are distanceMeters() and initialBearingDegrees().
// ------------------------------------------------------

function haversineDistanceMeters(lat1, lon1, lat2, lon2) {
    return distanceMeters(lat1, lon1, lat2, lon2);
}

// Common UK spelling (in case any old code calls it)
function haversineDistanceMetres(lat1, lon1, lat2, lon2) {
    return distanceMeters(lat1, lon1, lat2, lon2);
}

// Optional alias some code paths check for
function calculateDistanceMeters(lat1, lon1, lat2, lon2) {
    return distanceMeters(lat1, lon1, lat2, lon2);
}

function calculateBearingDegrees(lat1, lon1, lat2, lon2) {
    return initialBearingDegrees(lat1, lon1, lat2, lon2);
}

        
/**
 * Converts a bearing in degrees into a human-friendly compass label.
 * precision:
 *   4  -> N, E, S, W
 *   8  -> N, NE, E, SE, S, SW, W, NW
 *   16 -> N, NNE, NE, ENE, E, ... (default)
 */
function bearingToCompassPoint(bearingDeg, precision = 16) {
    const dirs =
        precision === 4
            ? ['N', 'E', 'S', 'W']
            : precision === 8
            ? ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']
            : [
                  'N', 'NNE', 'NE', 'ENE',
                  'E', 'ESE', 'SE', 'SSE',
                  'S', 'SSW', 'SW', 'WSW',
                  'W', 'WNW', 'NW', 'NNW'
              ];

    const step = 360 / dirs.length;
    const normalised = ((bearingDeg % 360) + 360) % 360; // 0..360
    const index = Math.round(normalised / step) % dirs.length;
    return dirs[index];
}

/** Clamps a number between a minimum and maximum value. */
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

/** Calculates the diameter (in meters) for the confidence circle: Accuracy * 2. */
function getCircleDiameter(accuracyInMeters) {
    if (typeof accuracyInMeters === 'number' && accuracyInMeters > 0) {
        return (accuracyInMeters * 2).toFixed(1); // Diameter = 2 * radius
    }
    return 'N/A';
}

// --- MOVEMENT & GUIDANCE HELPER FUNCTIONS ---

/**
 * Records a new smoothed movement sample.
 * Called from the live map GPS watch each time we get a new reading.
 */
function recordMovementSample(lat, lon) {
    const now = Date.now();
    movementHistory.push({ lat, lon, time: now });

    // Trim to recent history only
    if (movementHistory.length > MOVEMENT_HISTORY_MAX_LENGTH) {
        movementHistory.shift();
    }
}

/**
 * Computes the bearing of recent movement based on the movementHistory array.
 * Returns:
 *   - a bearing in degrees [0, 360) if we have enough motion
 *   - null if we don't have enough recent movement yet
 */
/**
 * Computes the bearing of recent movement based on the movementHistory array.
 * Returns:
 *   - a bearing in degrees [0, 360) if we have enough motion
 *   - null if we don't have enough recent movement yet
 */
function computeMovementBearingDegrees() {
    if (!movementHistory || movementHistory.length < 2) {
        return null;
    }

    const now = Date.now();

    // Keep only samples from the recent window
    movementHistory = movementHistory.filter(p => now - p.time <= MOVEMENT_HISTORY_MAX_AGE_MS);

    if (movementHistory.length < 2) {
        return null;
    }

    const first = movementHistory[0];
    const last = movementHistory[movementHistory.length - 1];

    // Distance moved in metres (use existing distanceMeters helper)
    const dist = distanceMeters(first.lat, first.lon, last.lat, last.lon);

    if (dist < MOVEMENT_MIN_DISTANCE_METERS) {
        // Too little movement to get a stable direction
        return null;
    }

    // Bearing of travel from first point in history to the most recent
    return initialBearingDegrees(first.lat, first.lon, last.lat, last.lon);
}
        
// --- END GEOGRAPHY HELPER FUNCTIONS ---



// ======================================
// SHARED MODAL HELPERS
// ======================================
function openModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;

    modal.style.display = 'block';

    // Make sure we start at the top of the modal + page
    setTimeout(() => {
        modal.scrollTop = 0;
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }, 50);
}

function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    modal.style.display = 'none';
}

async function exportOpenSurveyPhotoGallery_ToFolder(rootPick) {
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('No open survey to export.', 'error');
        return;
    }

    const logBox = document.getElementById('export-photo-gallery-log');
    const btn = document.getElementById('export-gallery-to-folder-btn');

    const log = (msg) => {
        if (!logBox) return;
        logBox.value += msg + '\n';
        logBox.scrollTop = logBox.scrollHeight;
    };
    if (logBox) logBox.value = '';

    // Spinner overlay
    function ensureSpinner() {
        let overlay = document.getElementById('gallery-export-overlay');
        if (overlay) return overlay;

        overlay = document.createElement('div');
        overlay.id = 'gallery-export-overlay';
        overlay.style.cssText =
            'position:fixed; inset:0; z-index:9999; background:rgba(0,0,0,0.35);' +
            'display:none; align-items:center; justify-content:center;';
        overlay.innerHTML = `
          <div style="background:#fff;border:1px solid #e5e7eb;border-radius:16px;padding:16px 18px;
                      width:min(420px,92vw);box-shadow:0 10px 30px rgba(0,0,0,0.25);
                      font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;">
            <div style="display:flex;gap:12px;align-items:center;">
              <div style="width:22px;height:22px;border-radius:999px;border:3px solid #cbd5e1;border-top-color:#0ea5e9;
                          animation:spin 0.9s linear infinite;"></div>
              <div>
                <div style="font-weight:800;font-size:14px;color:#0f172a;">Exporting photo gallery…</div>
                <div id="gallery-export-overlay-text" style="margin-top:2px;font-size:12px;color:#64748b;">Starting…</div>
              </div>
            </div>
          </div>
          <style>@keyframes spin{to{transform:rotate(360deg)}}</style>
        `;
        document.body.appendChild(overlay);
        return overlay;
    }
    function showSpinner(text) {
        const overlay = ensureSpinner();
        const t = overlay.querySelector('#gallery-export-overlay-text');
        if (t) t.textContent = text || '';
        overlay.style.display = 'flex';
    }
    function hideSpinner() {
        const overlay = document.getElementById('gallery-export-overlay');
        if (overlay) overlay.style.display = 'none';
    }

    // Confirm includeTargets (no folder picking here)
    const confirmHtml = `
        Export gallery into the selected folder?<br>
        <span class="text-sm text-gray-600">index.html is embedded/phone-safe. JPGs are also saved into Finds/Targets subfolders (not linked from index.html).</span>
        <div style="margin-top:10px; display:flex; align-items:center; gap:10px;">
            <input id="gallery-include-targets" type="checkbox" checked style="width:18px;height:18px;">
            <label for="gallery-include-targets" style="font-weight:700;">Also export Target JPGs</label>
        </div>
    `;

    showConfirmationModal('Export Photo Gallery', confirmHtml, async () => {
        // close modal immediately
        if (typeof closeConfirmationModal === 'function') closeConfirmationModal();
        else {
            const m = document.getElementById('confirmation-modal');
            if (m) m.style.display = 'none';
        }

        let originalBtnText = '';
        if (btn) {
            originalBtnText = btn.innerText;
            btn.disabled = true;
            btn.innerText = 'Exporting...';
        }

        try {
            const includeTargets =
                document.getElementById('gallery-include-targets')?.checked ?? true;

            const maxW = (typeof getMaxPhotoWidth === 'function') ? getMaxPhotoWidth() : 1000;

            log(`Survey: ${openSurvey.name || 'Unnamed survey'}`);
            log(`Max photo width: ${maxW || 0}px`);
            log(`Export Target JPGs: ${includeTargets ? 'YES' : 'NO'}`);

            const safeName = safeSlug(openSurvey.name || 'survey');
            const folderName =
                `${safeName}_` +
                new Date().toISOString().replace(/[:.]/g, '').replace('T', '_').replace('Z', '');

            const galleryDir = await getOrCreateDir(rootPick, folderName);

            // Subfolders for JPG access (NOT referenced by index.html)
            const surveyDir  = await getOrCreateDir(galleryDir, 'Survey');
            const findsDir   = await getOrCreateDir(galleryDir, 'Finds');
            const targetsDir = await getOrCreateDir(galleryDir, 'Targets');

            async function saveJpg(dirHandle, filenameBase, photoRefOrDataUrl) {
                const rawBlob = await resolvePhotoBlob(photoRefOrDataUrl);
                if (!rawBlob) return null;

                const outBlob = await resizeBlobToMaxWidthJpeg(rawBlob, maxW, 0.85);
                if (!outBlob) return null;

                const fileName = `${filenameBase}.jpg`;
                await writeFileToHandle(dirHandle, fileName, outBlob);
                return outBlob; // return blob for embedding
            }
// Build item list
const items = [];

// Survey photos (supports multi-photo surveys)
const surveyRefs = Array.isArray(openSurvey.photos) && openSurvey.photos.length
    ? openSurvey.photos
    : (openSurvey.surveyPhotoRef ? [openSurvey.surveyPhotoRef] : []);

// Also allow legacy inline data URL fields if present (very old builds)
const legacySurveyDataUrl = (openSurvey.surveyPhotoData || openSurvey.surveyPhotoDataUrl || '');

if (surveyRefs.length) {
    surveyRefs.forEach((ref, idx) => {
        if (!ref) return;
        // Only include IndexedDB refs here; inline data URL handled by legacySurveyDataUrl
        if (typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(ref)) {
            items.push({
                kind: 'survey',
                parentId: openSurvey.id,
                indexInParent: idx + 1,
                title: `${openSurvey.name || 'Survey'} photo ${idx + 1}`,
                type: 'Survey',
                vdi: '',
                depth: '',
                time: openSurvey.updatedAt || openSurvey.lastChanged || openSurvey.createdAt || '',
                photoRefOrDataUrl: ref
            });
        }
    });
} else if (legacySurveyDataUrl) {
    items.push({
        kind: 'survey',
        parentId: openSurvey.id,
        indexInParent: 1,
        title: openSurvey.name || 'Survey photo',
        type: 'Survey',
        vdi: '',
        depth: '',
        time: openSurvey.updatedAt || openSurvey.lastChanged || openSurvey.createdAt || '',
        photoRefOrDataUrl: legacySurveyDataUrl
    });
}

            const linkedFinds = finds.filter(f => f.surveyId === openSurvey.id);
            for (const f of linkedFinds) {
                const refs = Array.isArray(f.photos) ? f.photos : [];
                const legacy = (f.targetPhotoData || f.photoData || f.photoDataUrl)
                    ? [f.targetPhotoData || f.photoData || f.photoDataUrl]
                    : [];
                const photoInputs = refs.length ? refs : legacy;

                for (let i = 0; i < photoInputs.length; i++) {
                    items.push({
                        kind: 'find',
                        parentId: f.id,
                        indexInParent: i + 1,
                        title: f.description || f.name || `Find ${f.id}`,
                        type: f.type || '',
                        vdi: f.vdi || '',
                        depth: f.depth || '',
                        time: f.time || f.date || '',
                        coords: f.coordinates || '',
                        accuracy: f.accuracy || '',
                        photoRefOrDataUrl: photoInputs[i]
                    });
                }
            }

            if (includeTargets && Array.isArray(openSurvey.targets)) {
                for (const t of openSurvey.targets) {
                    const refs = Array.isArray(t.photos) ? t.photos : [];
                    const legacy = (t.targetPhotoData || t.photoDataUrl)
                        ? [t.targetPhotoData || t.photoDataUrl]
                        : [];
                    const photoInputs = refs.length ? refs : legacy;

                    for (let i = 0; i < photoInputs.length; i++) {
                        items.push({
                            kind: 'target',
                            parentId: t.id,
                            indexInParent: i + 1,
                            title: t.description || `Target ${t.id}`,
                            type: t.type || '',
                            vdi: t.vdi || '',
                            depth: t.depth || '',
                            time: t.time || '',
                            coords: t.coordinates || '',
                            accuracy: t.accuracy || '',
                            photoRefOrDataUrl: photoInputs[i]
                        });
                    }
                }
            }

            if (!items.length) {
                showMessage('No photos found to export.', 'info');
                log('No photos found.');
                return;
            }

            log(`Total photos to process: ${items.length}`);
            showSpinner(`Processing 0/${items.length}…`);

            // HTML bits (embedded index.html only)
            let surveyHeroHtml = '';
            let hasSurveyHero = false;
            const surveyCards = [];
            const findCards = [];
            const targetCards = [];
            const sections = [];

            for (let i = 0; i < items.length; i++) {
                const it = items[i];
                const baseName = `${it.kind}_${safeSlug(it.parentId)}_${String(it.indexInParent).padStart(2, '0')}`;
                const anchorId = baseName;

                log(`Photo ${i + 1}/${items.length}: ${it.kind} ${it.parentId} #${it.indexInParent}`);
                showSpinner(`Processing ${i + 1}/${items.length}…`);

                let dirHandle = findsDir;
                if (it.kind === 'survey') dirHandle = surveyDir;
                else if (it.kind === 'target') dirHandle = targetsDir;

                const outBlob = await saveJpg(dirHandle, baseName, it.photoRefOrDataUrl);
                if (!outBlob) {
                    log('  SKIP (missing/failed)');
                    continue;
                }

                const dataUrl = await blobToDataUrl(outBlob);

                // Survey hero: full width, only for the first survey photo
                if (it.kind === 'survey' && !hasSurveyHero) {
                    hasSurveyHero = true;
                    surveyHeroHtml = `
                      <div class="surveyHero">
                        <img class="surveyImg" src="${escapeHtml(dataUrl)}" alt="Survey photo">
                      </div>
                    `;
                } else {
                    const card = `
                      <div class="card">
                        <a class="thumbLink" href="#${anchorId}">
                          <img src="${escapeHtml(dataUrl)}" alt="${escapeHtml(it.title)}">
                        </a>
                        <div class="cap">
                          <div class="title">${escapeHtml(it.title)}</div>
                          <div class="metaLine">${escapeHtml(it.vdi)} ${it.type ? '· ' + escapeHtml(it.type) : ''}</div>
                          <div class="metaLine">${escapeHtml(fmtDateTime(it.time))}</div>
                        </div>
                      </div>
                    `;
                    if (it.kind === 'survey') surveyCards.push(card);
                    else if (it.kind === 'find') findCards.push(card);
                    else targetCards.push(card);
                }

                // Full sections (embedded + internal only)
                sections.push(`
                  <div class="detail" id="${anchorId}">
                    <p class="back"><a href="#top">↑ Back to top</a></p>
                    <h3>${escapeHtml(it.title)}</h3>
                    <p class="muted">${escapeHtml(it.kind)}</p>
                    <img class="full" src="${escapeHtml(dataUrl)}" alt="${escapeHtml(it.title)}">
                    <ul class="meta">
                      <li><strong>Type:</strong> ${escapeHtml(it.type)}</li>
                      ${it.vdi ? `<li><strong>VDI/ID:</strong> ${escapeHtml(it.vdi)}</li>` : ''}
                      ${it.depth ? `<li><strong>Depth:</strong> ${escapeHtml(it.depth)}</li>` : ''}
                      ${it.time ? `<li><strong>Date/Time:</strong> ${escapeHtml(fmtDateTime(it.time))}</li>` : ''}
                      ${it.coords ? `<li><strong>Coordinates:</strong> ${escapeHtml(it.coords)}</li>` : ''}
                      ${it.accuracy ? `<li><strong>Accuracy:</strong> ${escapeHtml(it.accuracy)}</li>` : ''}
                      <li><strong>Parent ID:</strong> ${escapeHtml(it.parentId)}</li>
                      <li><strong>Photo #:</strong> ${it.indexInParent}</li>
                    </ul>
                    <hr>
                  </div>
                `);

                log('  OK');
            }

            const surveyInfoHtml = `
              <div class="surveyBox">
                <h1>${escapeHtml(openSurvey.name || 'Unnamed survey')}</h1>
                <p><strong>Description:</strong> ${escapeHtml(openSurvey.description || '')}</p>
                <p><strong>Exported:</strong> ${escapeHtml(new Date().toLocaleString())}</p>
                <p class="muted">index.html is embedded/phone-safe and does not link to the JPG folders.</p>
              </div>
            `;

            const indexHtml = `<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>geoFind Gallery - ${escapeHtml(openSurvey.name || 'Survey')}</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:18px;color:#111;background:#f8fafc;}
  .wrap{max-width:1200px;margin:0 auto;}
  .surveyBox{background:#fff;border:1px solid #e5e7eb;border-left:6px solid #0ea5e9;border-radius:14px;padding:16px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  h1{margin:0 0 8px 0;font-size:26px}
  h2{margin:22px 0 10px 0}
  h3{margin:8px 0 10px 0}
  .muted{color:#64748b;font-size:14px}

  .surveyHero{background:#fff;border:1px solid #e5e7eb;border-radius:14px;overflow:hidden;box-shadow:0 6px 18px rgba(0,0,0,0.06); margin-top:12px;}
  .surveyImg{width:100%; height:auto; display:block;}

  .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:12px}
  @media (max-width:900px){.grid{grid-template-columns:repeat(2,minmax(0,1fr));}}
  @media (max-width:520px){.grid{grid-template-columns:repeat(2,minmax(0,1fr));}}

  .card{background:#fff;border:1px solid #e5e7eb;border-radius:14px;overflow:hidden;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  .card img{width:100%;height:200px;object-fit:cover;display:block}
  .cap{padding:10px}
  .title{font-weight:800;font-size:14px;margin-bottom:4px}
  .metaLine{font-size:12px;color:#64748b}
  a.thumbLink{text-decoration:none;color:inherit}

  .detail{background:#fff;border:1px solid #e5e7eb;border-radius:14px;padding:14px;margin-top:14px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  img.full{width:100%;height:auto;border-radius:12px;border:1px solid #e5e7eb}
  .meta{margin:12px 0 0 0;padding:0;list-style:none}
  .meta li{padding:6px 0;border-bottom:1px solid #f1f5f9}
  .back{margin:0 0 8px 0}
</style>
</head>
<body>

  <a id="top"></a>
  <div class="wrap">
    ${surveyInfoHtml}
    ${surveyHeroHtml}

    ${surveyCards.length ? `<h2>Survey Photos</h2><div class="grid">${surveyCards.join('')}</div>` : ''}

    <h2>Finds</h2>
    <div class="grid">${findCards.join('')}</div>

    ${includeTargets ? `<h2>Targets</h2><div class="grid">${targetCards.join('')}</div>` : ''}

    <h2>Full Photos</h2>
    ${sections.join('')}

    <p class="muted" style="margin-top:22px;">Generated by geoFind.</p>
  </div>
</body>
</html>`;

            await writeFileToHandle(galleryDir, 'index.html', new Blob([indexHtml], { type: 'text/html' }));

            hideSpinner();
            log('Done.');
            showMessage('Gallery exported successfully.', 'success');
            log(`Saved folder: ${folderName}`);
            log(`JPG folders: Survey/, Finds/, Targets/`);

        } catch (e) {
            hideSpinner();
            console.error('Gallery export error:', e);

            if (e && (e.name === 'AbortError' || String(e.message || '').toLowerCase().includes('aborted'))) {
                showMessage('Cancelled.', 'info');
                log('Cancelled by user.');
                return;
            }

            log(`ERROR: ${e.message || e}`);
            showMessage(`Could not export gallery: ${e.message || 'Unknown error'}`, 'error');
        } finally {
            hideSpinner();
            if (btn) {
                btn.disabled = false;
                btn.innerText = originalBtnText || 'Step 2: Export to Selected Folder';
            }
        }
    });
}
// ======================================
// SHARED FORM HELPERS
// ======================================

function attachFormSubmitHandler(formId, handler) {
    const form = document.getElementById(formId);
    if (!form) return null;

    form.removeEventListener('submit', handler);
    form.addEventListener('submit', handler);

    return form;
}

        
async function openEditFindModal(findId) {
    const find = finds.find(f => f.id === findId);
    if (!find) {
        showMessage('Find not found.', 'error');
        return;
    }

    const modal = document.getElementById('edit-find-modal');
    const form  = document.getElementById('edit-find-form');
    if (!modal || !form) return;

    // Core fields
    form['findId'].value           = find.id;
    form['findDescription'].value  = find.description || '';
    form['findType'].value         = find.type || 'Unknown';
    form['findVDI'].value          = find.vdi || '';
    form['findDepth'].value        = find.depth || '';
    form['findCoords'].value       = find.coordinates || '';
    form['findAccuracy'].value     = find.accuracy || '';


    // New optional fields (Find data model v1)
    if (form['findIdentification'])  form['findIdentification'].value = find.identification || '';
    if (form['findMaterial'])        form['findMaterial'].value = find.material || '';
    if (form['findCondition'])       form['findCondition'].value = find.condition || '';
    if (form['findPeriod'])          form['findPeriod'].value = find.period || '';
    if (form['findWeightG'])         form['findWeightG'].value = (find.weightG ?? '') === 0 ? '0' : (find.weightG || '');
    if (form['findDimensionsMm'])    form['findDimensionsMm'].value = find.dimensionsMm || '';
    if (form['findWhereKept'])       form['findWhereKept'].value = find.whereKept || '';
    if (form['findDisposition'])     form['findDisposition'].value = find.disposition || '';
    if (form['findPossibleTreasure']) form['findPossibleTreasure'].checked = !!find.possibleTreasure;
    // Photos for editing: resolve IndexedDB refs -> object URLs, or use existing data URLs
    try {
        if (Array.isArray(find.photos) && find.photos.length > 0) {
            const first = find.photos[0];
            if (isIndexedDbPhotoRef(first)) {
                // Load from IndexedDB
                currentEditFindPhotos = await loadPhotoUrlsFromRefs(find.photos);
            } else {
                // Legacy: direct data URLs
                currentEditFindPhotos = find.photos.slice();
            }
        } else if (find.targetPhotoData) {
            currentEditFindPhotos = [find.targetPhotoData];
        } else if (find.photoData) {
            currentEditFindPhotos = [find.photoData];
        } else {
            currentEditFindPhotos = [];
        }
    } catch (e) {
        console.error('Error preparing edit find photos:', e);
        currentEditFindPhotos = [];
    }

    // Update preview + hidden field from currentEditFindPhotos
    updateEditFindPhotoPreview();

    // Attach the submit handler via shared helper
    attachFormSubmitHandler('edit-find-form', handleEditFindSubmit);

    // Show the modal
    openModal('edit-find-modal');
}
function closeEditFindModal() {
    closeModal('edit-find-modal');
}

function openEditTrackModal(trackId, options = {}) {
    const found = findTrackById(trackId);
    if (!found || !found.track || !found.survey) {
        showMessage('Track not found.', 'error');
        return;
    }

    const modal = document.getElementById('edit-track-modal');
    const form  = document.getElementById('edit-track-form');
    if (!modal || !form) {
        showMessage('Edit Track modal not found in page.', 'error');
        return;
    }

    const titleEl = document.getElementById('edit-track-title');
    const idEl    = document.getElementById('edit-track-id');
    const nameEl  = document.getElementById('edit-track-name');
    const descEl  = document.getElementById('edit-track-description');

    const track = found.track;

    // Title
    const isNew = !!options.isNew;
    if (titleEl) titleEl.textContent = isNew ? 'New Track Details' : 'Edit Track';

    // Fill fields
    if (idEl)   idEl.value = track.id;
    if (nameEl) nameEl.value = String(track.name || 'Track');
    if (descEl) descEl.value = String(track.description || '');

    // Attach submit safely (you already use this pattern elsewhere)
    if (typeof attachFormSubmitHandler === 'function') {
        attachFormSubmitHandler('edit-track-form', handleEditTrackSubmit);
    } else {
        // Fallback (in case attachFormSubmitHandler isn't in this build)
        form.onsubmit = handleEditTrackSubmit;
    }

    openModal('edit-track-modal');

    // Focus for faster editing on mobile
    setTimeout(() => {
        try {
            if (nameEl) {
                nameEl.focus();
                nameEl.setSelectionRange(nameEl.value.length, nameEl.value.length);
            }
        } catch (e) {}
    }, 50);
}

function closeEditTrackModal() {
    closeModal('edit-track-modal');
}

function handleEditTrackSubmit(event) {
    event.preventDefault();

    const form = event.target;

    const trackId = (form['trackId']?.value || '').trim();
    const newName = String(form['trackName']?.value || '').trim();
    const newDesc = String(form['trackDescription']?.value || '').trim();

    if (!trackId) {
        showMessage('Missing track id.', 'error');
        return;
    }
    if (!newName) {
        showMessage('Track name is required.', 'error');
        return;
    }

    const found = findTrackById(trackId);
    if (!found || !found.track || !found.survey) {
        showMessage('Track not found.', 'error');
        closeEditTrackModal();
        return;
    }

    found.track.name = newName;
    found.track.description = newDesc;

    found.survey.dateLastChanged = Date.now();

    if (typeof saveSurveysToLocalStorage === 'function') {
        saveSurveysToLocalStorage();
    }

    closeEditTrackModal();
    showMessage('Track updated.', 'success');

    // Refresh UI (Compass list + map)
    if (typeof rerenderCompassIfActive === 'function') {
        rerenderCompassIfActive();
    } else if (typeof render === 'function') {
        render();
    }
}


/**
 * Save changes from Edit Find form back into the find object.
 * This now supports multiple photos via find.photos.
 */
async function handleSurveyWithPhotosImport(event) {
    const file = event?.target?.files?.[0];
    const logBox = document.getElementById('import-survey-log');

    const log = (msg) => {
        if (!logBox) return;
        logBox.value += msg + '\n';
        logBox.scrollTop = logBox.scrollHeight;
    };

    if (logBox) logBox.value = '';

    if (!file) {
        showMessage('Please choose a survey file to import.', 'error');
        return;
    }

    // Confirm first
    showImportConfirmModal(file.name, async () => {
        try {
            log(`Reading "${file.name}"...`);

            const lower = file.name.toLowerCase();

            // Legacy JSON import still supported
            if (lower.endsWith('.json')) {
                const text = await file.text();
                log('JSON read successfully. Importing...');
                await performSurveyImport(text, file.name, log);
                return;
            }

            // ZIP import
            if (!lower.endsWith('.zip')) {
                showMessage('Unsupported file type. Please select a .zip or .json export.', 'error');
                log('ERROR: Unsupported file type.');
                return;
            }

            if (typeof JSZip === 'undefined') {
                showMessage('ZIP import needs JSZip. Add the JSZip <script> tag first.', 'error');
                log('ERROR: JSZip missing.');
                return;
            }

            log('Loading ZIP...');
            const zip = await JSZip.loadAsync(file);

            const surveyJsonFile = zip.file('survey.json');
            if (!surveyJsonFile) {
                showMessage('Import failed: survey.json not found in the ZIP.', 'error');
                log('ERROR: survey.json not found in ZIP.');
                return;
            }

            const jsonText = await surveyJsonFile.async('string');
            log('survey.json extracted. Importing...');
            await performSurveyZipImport(zip, jsonText, file.name, log);

        } catch (e) {
            console.error('Survey ZIP import error:', e);
            log(`ERROR: ${e.message || 'Unknown error'}`);
            showMessage(`Survey import failed: ${e.message || 'Unknown error'}`, 'error');
        } finally {
            // reset file input so selecting same file again triggers onchange
            try { event.target.value = ''; } catch (_) {}
        }
    });
}
        
async function performSurveyZipImport(zip, jsonText, filename, log) {
    let payload;

    log(`Parsing survey.json from "${filename}"...`);
    try {
        payload = JSON.parse(jsonText);
    } catch (e) {
        log(`ERROR: Invalid JSON (${e.message})`);
        showMessage(`Import failed: invalid JSON (${e.message})`, 'error');
        return;
    }

    if (!payload || !payload.survey) {
        log('ERROR: This ZIP does not look like a survey export.');
        showMessage('Import failed: this ZIP does not look like a survey export.', 'error');
        return;
    }

    const importedSurvey = payload.survey;
    const importedFinds  = Array.isArray(payload.finds) ? payload.finds : [];


    // Backwards/forwards compatibility: ensure newly added Survey fields exist (blank if missing)
    const _surveyFieldDefaults = {
        permissionFrom: '',
        permissionType: '',
        permissionDateGranted: '',
        permissionExpiry: '',
        permissionNotes: '',
        areaType: '',
        landUseCurrent: '',
        soilType: '',
        groundCondition: '',
        recentRain: '',
        weather: '',
        mineralisationLevel: ''
    };
    for (const [k, v] of Object.entries(_surveyFieldDefaults)) {
        if (importedSurvey[k] === undefined) importedSurvey[k] = v;
    }

    // Backwards/forwards compatibility: ensure newly added Find fields exist (blank/default if missing)
    const _findFieldDefaults = {
        identification: '',
        material: '',
        condition: '',
        period: '',
        weightG: '',
        dimensionsMm: '',
        whereKept: '',
        possibleTreasure: false,
        disposition: ''
    };
    for (const f of importedFinds) {
        if (!f || typeof f !== 'object') continue;
        for (const [k, v] of Object.entries(_findFieldDefaults)) {
            if (f[k] === undefined) f[k] = v;
        }
        // Coerce boolean if older exports stored strings
        if (typeof f.possibleTreasure !== 'boolean') {
            f.possibleTreasure = String(f.possibleTreasure).toLowerCase() === 'true';
        }
    }
    // LIMITS: importing a ZIP creates a NEW survey, so enforce survey limit / expiry
    const rs = canCreate('surveys');
    if (!rs.ok) {
        log(`LIMIT: ${rs.reason}`);
        showMessage(rs.reason, 'error');
        return;
    }

    // ---------- LIMITS: compute remaining slots ONCE for this import ----------
    // Reason: canCreate() won't "see" imported items until we merge at the end.
    const limits = (typeof loadAppLimits === 'function') ? loadAppLimits() : null;

    const countExistingTargets = () => {
        let n = 0;
        if (Array.isArray(surveys)) {
            surveys.forEach(s => {
                n += (Array.isArray(s?.targets) ? s.targets.length : 0);
            });
        }
        return n;
    };

    const countExistingFinds = () => {
        // Your app uses global 'finds' as the library (you merge into it below),
        // so this is the most accurate count for enforcing maxFinds.
        return Array.isArray(finds) ? finds.length : 0;
    };

    const existingTargets = countExistingTargets();
    const existingFinds   = countExistingFinds();

    const remainingTargets = (!limits || limits.maxTargets == null)
        ? Infinity
        : Math.max(0, limits.maxTargets - existingTargets);

    const remainingFinds = (!limits || limits.maxFinds == null)
        ? Infinity
        : Math.max(0, limits.maxFinds - existingFinds);

    // Count files for progress
    const allPhotoPaths = [];
    if (Array.isArray(importedSurvey.photoFiles)) allPhotoPaths.push(...importedSurvey.photoFiles);

    if (Array.isArray(importedSurvey.targets)) {
        for (const t of importedSurvey.targets) {
            if (Array.isArray(t.photoFiles)) allPhotoPaths.push(...t.photoFiles);
        }
    }
    for (const f of importedFinds) {
        if (Array.isArray(f.photoFiles)) allPhotoPaths.push(...f.photoFiles);
    }

    const totalPhotos = allPhotoPaths.length;
    let donePhotos = 0;

    try {
        showProgressOverlay('Importing ZIP', 'Restoring survey + photos…');
        updateProgressOverlay(1, 'Preparing import…');

        if (!importedSurvey.id) importedSurvey.id = generateId();
// ---- Survey photos ----
updateProgressOverlay(5, 'Restoring survey photos…');

// Prefer the exported photoFiles array (ZIP export)
const surveyPhotoPaths = Array.isArray(importedSurvey.photoFiles) && importedSurvey.photoFiles.length
    ? importedSurvey.photoFiles
    : [];

importedSurvey.photos = [];

if (surveyPhotoPaths.length) {
    for (const path of surveyPhotoPaths) {
        const zf = zip.file(path);
        if (!zf) continue;
        const blob = await zf.async('blob');
        const id = await savePhotoBlob(blob);
        importedSurvey.photos.push(makePhotoRef(id));
        donePhotos++;
        updateProgressOverlay(
            5 + (totalPhotos ? (donePhotos / totalPhotos) * 70 : 0),
            `Restoring photos ${donePhotos}/${totalPhotos}…`
        );
    }
} else if (importedSurvey.surveyPhotoRef) {
    // Legacy single-photo export/import
    importedSurvey.photos = [importedSurvey.surveyPhotoRef];
}

// Backward compatibility: keep surveyPhotoRef as the first photo
importedSurvey.surveyPhotoRef = importedSurvey.photos[0] || importedSurvey.surveyPhotoRef || '';
importedSurvey.surveyPhotoData = '';



        // ---- Targets ----
        if (!Array.isArray(importedSurvey.targets)) importedSurvey.targets = [];

        // Ensure tracks exist and are well-formed (backwards compatible)
        if (!Array.isArray(importedSurvey.tracks)) importedSurvey.tracks = [];
        for (const tr of importedSurvey.tracks) {
            if (!tr) continue;
            if (!tr.id) tr.id = generateId();
            tr.name = String(tr.name || 'Track');
            tr.description = String(tr.description || '');
            if (tr.isVisible === undefined) tr.isVisible = true;
            if (!tr.color) tr.color = pickTrackColor(0); // only if missing; won’t override existing colours
            if (!Array.isArray(tr.points)) tr.points = [];
        }

        log(`Restoring ${importedSurvey.targets.length} targets...`);
        updateProgressOverlay(10, `Restoring ${importedSurvey.targets.length} targets…`);

        let tIndex = 0;
        let importedTargetsThisZip = 0;

        for (const t of importedSurvey.targets) {
            // LIMITS: stop importing targets once we hit remaining slots
            if (importedTargetsThisZip >= remainingTargets) {
                log(`LIMIT: Max targets reached (${limits?.maxTargets}). Stopping target import.`);
                // Keep only targets already processed
                importedSurvey.targets = importedSurvey.targets.slice(0, tIndex);
                break;
            }

            tIndex++;
            importedTargetsThisZip++;

            if (!t.id) t.id = generateId();

            const files = Array.isArray(t.photoFiles) ? t.photoFiles : [];
            const refs = [];

            for (const path of files) {
                const zf = zip.file(path);
                if (!zf) continue;
                const blob = await zf.async('blob');
                const id = await savePhotoBlob(blob);
                refs.push(makePhotoRef(id));

                donePhotos++;
                const pct = 5 + (totalPhotos ? (donePhotos / totalPhotos) * 70 : 0);
                updateProgressOverlay(pct, `Restoring photos ${donePhotos}/${totalPhotos}…`);
            }

            t.photos = refs;
            t.targetPhotoRef = refs[0] || '';
            t.targetPhotoData = '';
            delete t.photoFiles;

            if (tIndex % 10 === 0) log(`  Targets processed: ${tIndex}/${importedSurvey.targets.length}`);
        }

        // ---- Finds ----
        log(`Restoring ${importedFinds.length} finds...`);
        updateProgressOverlay(80, `Restoring ${importedFinds.length} finds…`);

        let fIndex = 0;
        for (const f of importedFinds) {
            // LIMITS: stop importing finds once we hit remaining slots
            if (fIndex >= remainingFinds) {
                log(`LIMIT: Max finds reached (${limits?.maxFinds}). Stopping finds import.`);
                break;
            }

            fIndex++;
            if (!f.id) f.id = generateId();
            if (!f.surveyId) f.surveyId = importedSurvey.id;

            const files = Array.isArray(f.photoFiles) ? f.photoFiles : [];
            const refs = [];

            for (const path of files) {
                const zf = zip.file(path);
                if (!zf) continue;
                const blob = await zf.async('blob');
                const id = await savePhotoBlob(blob);
                refs.push(makePhotoRef(id));

                donePhotos++;
                const pct = 5 + (totalPhotos ? (donePhotos / totalPhotos) * 70 : 0);
                updateProgressOverlay(pct, `Restoring photos ${donePhotos}/${totalPhotos}…`);
            }

            f.photos = refs;
            f.findPhotoRef = refs[0] || '';
            f.targetPhotoData = '';
            delete f.photoFiles;

            if (fIndex % 10 === 0) log(`  Finds processed: ${fIndex}/${importedFinds.length}`);
        }

        // ---- Merge ----
        updateProgressOverlay(92, 'Saving imported data…');
        log('Merging imported survey into local data...');

        surveys.push(importedSurvey);

        const importedFindsAllowed = importedFinds.slice(0, fIndex);
        finds = finds.concat(importedFindsAllowed);

        saveSurveysToLocalStorage();
        saveFindsToLocalStorage();

        updateProgressOverlay(100, 'Done.');
        setTimeout(() => hideProgressOverlay(), 400);

        const importedTargetsActual = Array.isArray(importedSurvey.targets) ? importedSurvey.targets.length : 0;
        const importedFindsActual   = importedFindsAllowed.length;

        log(`"${filename}" imported successfully.`);
        showMessage(
            `Imported survey "${importedSurvey.name || 'Unnamed survey'}" with ` +
            `${importedTargetsActual} targets and ` +
            `${importedFindsActual} finds.`,
            'success'
        );

    } catch (e) {
        console.error('Error importing ZIP survey:', e);
        log(`ERROR: ${e.message || 'Unknown error'}`);
        showMessage(`Survey import failed: ${e.message || 'Unknown error'}`, 'error');
        hideProgressOverlay();
    }
}

    async function handleEditFindSubmit(event) {
    event.preventDefault();
    const form = event.target;

    const id = form['findId'].value;
    const find = finds.find(f => f.id === id);
    if (!find) {
        showMessage('Find not found.', 'error');
        closeEditFindModal();
        return;
    }

    const desc = form['findDescription'].value.trim();
    if (!desc) {
        showMessage('Description is required.', 'error');
        return;
    }

    // Core fields
    find.description = desc;
    find.type        = form['findType'].value || 'Unknown';
    find.vdi         = form['findVDI'].value.trim();
    find.depth       = form['findDepth'].value.trim();
    find.coordinates = form['findCoords'].value.trim();
    find.accuracy    = form['findAccuracy'].value.trim();


    // New optional fields (Find data model v1)
    if (form['findIdentification'])   find.identification = (form['findIdentification'].value || '').trim();
    if (form['findMaterial'])         find.material = (form['findMaterial'].value || '').trim();
    if (form['findCondition'])        find.condition = (form['findCondition'].value || '').trim();
    if (form['findPeriod'])           find.period = (form['findPeriod'].value || '').trim();
    if (form['findWeightG'])          find.weightG = (form['findWeightG'].value || '').trim();
    if (form['findDimensionsMm'])     find.dimensionsMm = (form['findDimensionsMm'].value || '').trim();
    if (form['findWhereKept'])        find.whereKept = (form['findWhereKept'].value || '').trim();
    if (form['findDisposition'])      find.disposition = (form['findDisposition'].value || '').trim();
    if (form['findPossibleTreasure']) find.possibleTreasure = !!form['findPossibleTreasure'].checked;
    // --- Photos: read JSON array from hidden field, then save into IndexedDB ---
    let photosDataUrls = [];
    if (form['findPhotoData']) {
        const raw = form['findPhotoData'].value;

        if (raw) {
            try {
                const temp = JSON.parse(raw);
                if (Array.isArray(temp)) {
                    photosDataUrls = temp.filter(p => typeof p === 'string' && p.length > 0);
                } else if (typeof temp === 'string' && temp.length > 0) {
                    photosDataUrls = [temp];
                }
            } catch (e) {
                // If it's not valid JSON, fall back to treating it as a single URL
                if (typeof raw === 'string' && raw.length > 0) {
                    photosDataUrls = [raw];
                }
            }
        }
    }

    let photoRefs = [];
    try {
        photoRefs = await saveDataUrlsAsPhotoRefs(photosDataUrls);
    } catch (e) {
        console.error('Error saving edited find photos to IndexedDB:', e);
        photoRefs = [];
    }

    const primaryDataUrl = photosDataUrls[0] || '';
    const primaryRef     = photoRefs[0] || '';

    // Store new IndexedDB-backed structure
    find.photos         = photoRefs;
    find.findPhotoRef   = primaryRef;
    find.targetPhotoData = photoRefs.length > 0 ? '' : primaryDataUrl;

    find.updatedAt = Date.now();

    saveFindsToLocalStorage();

    closeEditFindModal();
    showMessage('Find updated.', 'success');
    render();
}
        
function deleteFind(findId) {
    const find = finds.find(f => f && f.id === findId);
    if (!find) {
        showMessage('Find not found.', 'error');
        return;
    }

    const executeDelete = async () => {
        const ok = await deleteFindPermanently(findId);
        if (ok) render();
    };

    showConfirmationModal(
        `Confirm Delete Find: ${find.description || 'this find'}`,
        `Are you sure you want to permanently delete this find?<br>
         <span class="text-sm text-gray-600">This will also delete any IndexedDB photos linked ONLY to this find. This cannot be undone.</span>`,
        executeDelete
    );
}
        /** Generates a simple unique ID. */
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2, 5);
        }

  /** Formats a timestamp into DD/MM/YY (UK style). Safe for missing/invalid values. */
function formatDate(timestamp) {
    if (timestamp === null || timestamp === undefined || timestamp === '') return '';

    const d = new Date(timestamp);
    if (Number.isNaN(d.getTime())) return '';

    const dd = String(d.getDate()).padStart(2, '0');
    const mm = String(d.getMonth() + 1).padStart(2, '0');
    const yy = String(d.getFullYear()).slice(-2);

    return `${dd}/${mm}/${yy}`;
}

/**
 * Normalizes survey permission dates into DD/MM/YY.
 * Accepts:
 *  - '' (returns '')
 *  - timestamp number (ms since epoch)
 *  - 'YYYY-MM-DD' (from <input type="date">)
 *  - 'DD/MM/YY' or 'D/M/YYYY' (normalizes + pads, trims to 2-digit year)
 */
function formatSurveyPermissionDate(value) {
    if (value === null || value === undefined) return '';
    const v = String(value).trim();
    if (!v) return '';

    // If it's already DD/MM/YY (or DD/MM/YYYY), normalize it.
    const m1 = v.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
    if (m1) {
        const dd = String(parseInt(m1[1], 10)).padStart(2, '0');
        const mm = String(parseInt(m1[2], 10)).padStart(2, '0');
        const yy = String(m1[3]).slice(-2);
        return `${dd}/${mm}/${yy}`;
    }

    // If it's YYYY-MM-DD, convert.
    const m2 = v.match(/^(\d{4})-(\d{2})-(\d{2})$/);
    if (m2) {
        const yy = String(m2[1]).slice(-2);
        const mm = m2[2];
        const dd = m2[3];
        return `${dd}/${mm}/${yy}`;
    }

    // If it's a number (timestamp), use the existing formatter.
    if (/^\d+$/.test(v)) {
        const n = Number(v);
        if (!Number.isNaN(n)) return formatDate(n);
    }

    // Last resort: try Date parsing (covers ISO strings etc.)
    const d = new Date(v);
    if (!Number.isNaN(d.getTime())) return formatDate(d.getTime());

    return '';
}

/**
 * Takes a target + its parent survey and snapshots it into the permanent Finds library.
 * The Find is independent: if the survey/target are later deleted, this record remains.
 */
/**
 * Takes a target + its parent survey and snapshots it into the permanent Finds library.
 * The Find is independent: if the survey/target are later deleted, this record remains.
 */
        /** Saves the current surveys and profile data to Local Storage. */
function saveFindsToLocalStorage() {
    try {
        localStorage.setItem('geoFindFinds', JSON.stringify(finds));
    } catch (e) {
        console.error("Error saving Finds to Local Storage:", e);
        // No toast here – we don't want to confuse the user
    }
}

function createFindFromTarget(target, survey) {
    // LIMITS: block creating finds if over limit / expired
    const r = canCreate('finds');
    if (!r.ok) {
        showMessage(r.reason, 'error');
        return false;
    }

    // Photos from the target (we now prefer IndexedDB refs)
    let photoRefs = [];
    let thumbDataUrl = '';

    if (Array.isArray(target.photos) && target.photos.length) {
        const first = target.photos[0];

        if (isIndexedDbPhotoRef(first)) {
            // New style: photos already refer to IndexedDB blobs
            photoRefs = target.photos.slice();
            thumbDataUrl = '';
        } else {
            // Legacy style: target.photos are data URLs (rare now)
            photoRefs = []; // we won't convert them here
            thumbDataUrl =
                target.photos[0] ||
                target.targetPhotoData ||
                target.photoDataUrl ||
                '';
        }
    } else if (target.targetPhotoData || target.photoDataUrl) {
        // No array, just a single thumbnail
        thumbDataUrl = target.targetPhotoData || target.photoDataUrl;
    }

    const primaryRef = photoRefs[0] || '';

    const find = {
        id: generateId(),

        // Links back to original context (not required to still exist)
        surveyId: survey.id,
        surveyName: survey.name || 'Untitled survey',
        surveyDescription: survey.description || '',
        targetId: target.id,

        // Core fields (object-centric; values copied from target are context only)
        description: target.description || 'Unnamed Find',
        type: target.type || 'Unknown',

        // Recovery context (copied from target; informational)
        vdi: target.vdi || '',
        depth: target.depth || '',

        // Object details (new – all optional)
        identification: '',
        material: '',
        condition: '',
        period: '',
        weightG: '',
        dimensionsMm: '',
        whereKept: '',
        possibleTreasure: false,
        disposition: '',

        // Location
        coordinates: target.coordinates || '',
        accuracy: target.accuracy || '',
        centerOnMap: !!target.centerOnMap,

        // Media
        targetPhotoData: thumbDataUrl,  // thumbnail for UI (legacy / fallback)
        photos: photoRefs,              // IndexedDB references (idb:...)
        findPhotoRef: primaryRef,       // first ref for convenience

        // Logged date/time
        dateCreated: Date.now(),

        // Metadata
        statusAtSave: target.status || '',
        user: target.user || userProfile.name || '',
        detector: target.detector || userProfile.detector || ''
    };

    finds.push(find);

    // Save finds separately (no scary warnings)
    saveFindsToLocalStorage();

    // Optional small vibration for mobile feedback (safe no-op on unsupported devices)
    if (navigator.vibrate) {
        navigator.vibrate(120);
    }

    return true;
}
        
function saveSurveysToLocalStorage() {
    try {
        localStorage.setItem('geoFindSurveys', JSON.stringify(surveys));
        localStorage.setItem('geoFindProfile', JSON.stringify(userProfile));
        localStorage.setItem('geoFindUserId', userId);
        // CRITICAL: Also save finds here to ensure they persist on refresh
        localStorage.setItem('geoFindFinds', JSON.stringify(finds));
    } catch (e) {
        console.error("Error saving to Local Storage:", e);
        // Only show message for actual localStorage errors (like quota exceeded)
        if (e.name === 'QuotaExceededError') {
            showMessage("Storage quota exceeded. Consider exporting and clearing old data.", 'error');
        }
    }
}
        
/** Loads data from Local Storage. Initializes if no data found. */
 /** Loads data from Local Storage. Initializes if no data found. */
function loadDataFromLocalStorage() {
    try {
        const storedSurveys = localStorage.getItem('geoFindSurveys');
        const storedFinds   = localStorage.getItem('geoFindFinds');   // <--- NEW
        const storedProfile = localStorage.getItem('geoFindProfile');
        const storedUserId  = localStorage.getItem('geoFindUserId');
        loadPhotoSettingsFromLocalStorage();
        loadNavOverlaySettingsFromLocalStorage();

        if (storedSurveys) {
            surveys = JSON.parse(storedSurveys);
        } else {
            // ✅ After a reset (or first run), start truly empty (no sample survey)
            surveys = [];
        }

        
        // --- Survey metadata normalization (optional fields: Permission/Area/Soil/Conditions/Intent/Access/Outcome) ---
        const ensureSurveyMetaDefaults = (survey) => {
            if (!survey) return;

            const setIfUndef = (key, defaultValue) => {
                if (survey[key] === undefined || survey[key] === null) survey[key] = defaultValue;
            };

            // 1) Permission & Legality
            setIfUndef('permissionFrom', '');
            setIfUndef('permissionType', '');
            setIfUndef('permissionDateGranted', '');
            setIfUndef('permissionExpiry', '');
            setIfUndef('permissionNotes', '');

            // 2) Area / Site Type
            setIfUndef('areaType', '');
            setIfUndef('landUseCurrent', '');

            // 3) Soil & Ground
            setIfUndef('soilType', '');
            setIfUndef('groundCondition', '');
            setIfUndef('mineralisationLevel', '');

            // 4) Environment
            setIfUndef('weather', '');
            setIfUndef('recentRain', '');
            setIfUndef('temperature', '');

            // 5) Intent & Context
            if (!Array.isArray(survey.purpose)) survey.purpose = [];
            setIfUndef('expectedPeriod', '');

            // 6) Access & Practical
            setIfUndef('accessNotes', '');
            if (!Array.isArray(survey.hazards)) survey.hazards = [];

            // 7) Outcome Summary
            setIfUndef('overallProductivity', '');
            setIfUndef('wouldDetectAgain', '');
            setIfUndef('surveyObservations', '');
        };

        if (Array.isArray(surveys)) {
            surveys.forEach(ensureSurveyMetaDefaults);
        }

// Load Finds (can be empty even if surveys exist)
        if (storedFinds) {
            finds = JSON.parse(storedFinds);
        } else {
            finds = [];
        }

        if (storedProfile) {
            // Update userProfile only if storedProfile exists and is valid
            const tempProfile = JSON.parse(storedProfile);
            if (tempProfile && tempProfile.name && tempProfile.detector) {
                userProfile = tempProfile;
            }
        } else {
            // Re-initialize sample profile if needed
          userProfile = { name: "Sample Dectorist", detector: "Minelab Equinox", ncmdNumber: "" };

        }

        if (storedUserId) {
            userId = storedUserId;
        } else {
            userId = generateId();
        }

        saveSurveysToLocalStorage();
        clearStaleRecordingTracksOnLoad();

    } catch (e) {
        console.error("Error loading from Local Storage:", e);
        showMessage("Error loading data. Data may be reset.", 'error');
    }
}

        /** Renders the current page content into the main container. */
        function render() {
            const appContent = document.getElementById('app-content');
            let contentHtml = '';

            // Update navigation button styles
            document.querySelectorAll('.nav-btn').forEach(btn => {
                if (btn.dataset.page === currentPage) {
                    btn.classList.add('text-primary', 'bg-gray-100');
                    btn.classList.remove('text-gray-500', 'hover:text-primary');
                } else {
                    btn.classList.remove('text-primary', 'bg-gray-100');
                    btn.classList.add('text-gray-500', 'hover:text-primary');
                }
            });

// In the render function...
        
// Stop auto-refresh only when leaving the Compass page
if (currentPage !== 'Compass' && autoRefreshIntervalId) {
    clearInterval(autoRefreshIntervalId);
    autoRefreshIntervalId = null;
    console.log("Auto-refresh stopped.");
}

switch (currentPage) {
    case 'Home':
        contentHtml = renderHomePage();
        break;
    case 'Targets':
        contentHtml = renderTargetsPage();
        break;
    case 'Finds':                           // <--- NEW
        contentHtml = renderFindsPage();
        break;
    case 'Compass':
        contentHtml = renderCompassPage(false);
        break;
    case 'Export':
        contentHtml = renderExportPage();
        break;
    case 'Settings':
        contentHtml = renderSettingsPage();
        break;
    case 'Help':
        contentHtml = renderHelpPage();
        break;
        
    default:
        contentHtml = `<div class="p-4 text-center">Page Not Found</div>`;
}
            appContent.innerHTML = contentHtml;
            // Re-attach event listeners specific to the rendered page
            attachPageEventListeners();
            // Update Home storage figures after DOM is in place
            if (currentPage === 'Home') { setTimeout(() => { updateHomeStorageStats(); }, 0); }
            updateActiveNavButtons();

       
}

        
        function randomIntInclusive(min, max) {
    const a = Math.ceil(Number(min));
    const b = Math.floor(Number(max));
    return Math.floor(Math.random() * (b - a + 1)) + a;
}

/**
 * Shared worker: logs a new quick target into the OPEN survey using the given VDI/Target ID.
 * This is the same logic as your existing "Log New Target" button, centralised.
 */
function quickLogTargetByVDI(raw, sourceLabel = '', opts = {}) {

    // LIMITS: block quick target creation if over limit / expired
    const r = canCreate('targets');
    if (!r.ok) {
        showMessage(r.reason, 'error');
        return false;
    }

    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('You must have an open survey to log a target.', 'error');
        return false;
    }

    const vdiStr = String(raw).trim();

    // Must be an integer, allow negatives
    if (!/^-?\d+$/.test(vdiStr)) {
        showMessage('Target ID must be a whole number (you can use negatives).', 'error');
        return false;
    }

    const now = Date.now();

    // Only use GPS if we currently have it
    const coords =
        (isAnyTrackRecording() &&
         currentUserCoords && typeof currentUserCoords.lat === 'number' && typeof currentUserCoords.lon === 'number')
            ? `${currentUserCoords.lat.toFixed(6)}, ${currentUserCoords.lon.toFixed(6)}`
            : 'No GPS logged';

    const acc =
        (isAnyTrackRecording() && currentUserAccuracy != null)
            ? String(currentUserAccuracy)
            : 'N/A';

    const newTarget = {
        id: generateId(),
        description: opts.description || `Logged ${new Date(now).toLocaleString()}`,
        vdi: vdiStr,
        depth: 'Unknown',
        type: opts.type || 'Unidentified',
        status: 'Not dug',
        time: now,
        coordinates: coords,
        accuracy: acc,
        user: userProfile.name,
        detector: userProfile.detector,
        centerOnMap: false,

        photos: [],
        targetPhotoRef: '',
        targetPhotoData: ''
    };

    if (!Array.isArray(openSurvey.targets)) openSurvey.targets = [];
    openSurvey.targets.unshift(newTarget);
    openSurvey.dateLastChanged = now;

    saveSurveysToLocalStorage();

    // Feedback: short vibration + obvious toast
    if (navigator.vibrate) navigator.vibrate(60);

    const extra = sourceLabel ? ` (${sourceLabel})` : '';
    showMessage(`New Target logged: ${vdiStr}${extra}`, 'success');

    // Only restart auto-refresh if tracking is on
    if (isTrackingActive) startCompassAutoRefresh();

    // Re-render once so the new pin appears immediately
    updateMapWithUserLocationAndRender();

    return true;
}
        
function exportOpenSurveyAsGPX() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('No open survey to export.', 'error');
        return;
    }

    const exportTargets = document.getElementById('gpx-export-targets')?.checked ?? true;
    const exportStakes  = document.getElementById('gpx-export-stakes')?.checked ?? true;
    const exportFinds   = document.getElementById('gpx-export-finds')?.checked ?? true;
    const exportTracks  = document.getElementById('gpx-export-tracks')?.checked ?? true;

    const parts = [];
    if (exportTargets) parts.push('Targets');
    if (exportStakes)  parts.push('Stakes');
    if (exportFinds)   parts.push('Finds');
    if (exportTracks)  parts.push('Tracks');

    const what = parts.length ? parts.join(', ') : 'Nothing (no boxes ticked)';

    showConfirmationModal(
        'Export GPX',
        `Export the open survey to a GPX file?\n\nIncluded: ${what}`,
        () => actuallyExportOpenSurveyAsGPX()
    );
}

function actuallyExportOpenSurveyAsGPX() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('No open survey to export.', 'error');
        return;
    }

    const logBox = document.getElementById('export-open-survey-gpx-log');
    const btn    = document.getElementById('export-open-survey-gpx-btn');

    const log = (msg) => {
        if (!logBox) return;
        logBox.value += msg + '\n';
        logBox.scrollTop = logBox.scrollHeight;
    };

    if (logBox) logBox.value = '';

    let originalBtnText = '';
    if (btn) {
        originalBtnText = btn.innerText;
        btn.disabled = true;
        btn.innerText = 'Exporting GPX...';
    }

    // Read export options (default ON if UI missing)
    const exportTargets = document.getElementById('gpx-export-targets')?.checked ?? true;
    const exportStakes  = document.getElementById('gpx-export-stakes')?.checked ?? true;
    const exportFinds   = document.getElementById('gpx-export-finds')?.checked ?? true;
    const exportTracks  = document.getElementById('gpx-export-tracks')?.checked ?? true;

    if (!exportTargets && !exportStakes && !exportFinds && !exportTracks) {
        showMessage('Nothing selected to export (tick at least one box).', 'error');
        if (btn) {
            btn.disabled = false;
            btn.innerText = originalBtnText || 'Export Open Survey as GPX';
        }
        return;
    }

    try {
        const nowIso = new Date().toISOString();

        // Colours
        const COLOR_TARGETS = '#0000FF'; // blue
        const COLOR_FINDS   = '#00FF00'; // green
        const COLOR_STAKES  = '#000000'; // black

        // Garmin-friendly symbols (also safe as plain text elsewhere)
        const SYM_TARGET = 'Flag, Blue';
        const SYM_FIND   = 'Flag, Green';
        const SYM_STAKE  = 'Navaid, Black';

        const xmlEscape = (s) => String(s ?? '')
            .replace(/&/g, '&amp;')
            .replace(/</g, '&lt;')
            .replace(/>/g, '&gt;')
            .replace(/"/g, '&quot;')
            .replace(/'/g, '&apos;');

        const parseLatLon = (coordsStr) => {
            if (!coordsStr || typeof coordsStr !== 'string') return null;
            if (coordsStr === 'No GPS logged') return null;

            const parts = coordsStr.split(',').map(x => Number(String(x).trim()));
            if (parts.length < 2) return null;

            const lat = parts[0];
            const lon = parts[1];
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;
            if (lat < -90 || lat > 90 || lon < -180 || lon > 180) return null;

            return { lat, lon };
        };

        const makeWpt = ({ lat, lon, name, desc, sym, extensionsObj }) => {
            let ext = '';
            if (extensionsObj && typeof extensionsObj === 'object') {
                const extLines = Object.entries(extensionsObj)
                    .filter(([_, v]) => v !== undefined && v !== null && String(v).trim() !== '')
                    .map(([k, v]) => `      <${k}>${xmlEscape(v)}</${k}>`)
                    .join('\n');
                if (extLines) {
                    ext = `\n    <extensions>\n${extLines}\n    </extensions>`;
                }
            }

            return `
  <wpt lat="${lat}" lon="${lon}">
    <name>${xmlEscape(name)}</name>
    <desc>${xmlEscape(desc || '')}</desc>
    <sym>${xmlEscape(sym || 'Waypoint')}</sym>${ext}
  </wpt>`;
        };

        const makeTrk = (track) => {
            const pts = (track.points || [])
                .map(p => {
                    if (!p || typeof p.lat !== 'number' || typeof p.lon !== 'number') return '';
                    if (!Number.isFinite(p.lat) || !Number.isFinite(p.lon)) return '';
                    if (p.lat < -90 || p.lat > 90 || p.lon < -180 || p.lon > 180) return '';

                    const tRaw = p.time || p.timestamp || p.date || null;
                    const timeIso = tRaw ? new Date(tRaw).toISOString() : '';

                    const acc = (p.accuracy != null && String(p.accuracy).trim() !== '') ? String(p.accuracy) : '';
                    const ext = acc
                        ? `\n        <extensions>\n          <accuracy>${xmlEscape(acc)}</accuracy>\n        </extensions>`
                        : '';

                    return `
      <trkpt lat="${p.lat}" lon="${p.lon}">${timeIso ? `\n        <time>${timeIso}</time>` : ''}${ext}
      </trkpt>`;
                })
                .filter(Boolean)
                .join('');

            if (!pts) return '';

 const name = track.name || 'Track';
const desc = track.description || '';

return `
  <trk>
    <name>${xmlEscape(name)}</name>
    <desc>${xmlEscape(desc)}</desc>${trackExt}
    <trkseg>${pts}
    </trkseg>
  </trk>`;
       };

        // Header/metadata (best practice)
        const header = `<?xml version="1.0" encoding="UTF-8"?>
<gpx version="1.1"
     creator="Detekta"
     xmlns="http://www.topografix.com/GPX/1/1">
  <metadata>
    <name>${xmlEscape(openSurvey.name || 'Open Survey')}</name>
    <time>${nowIso}</time>
  </metadata>`;

        const openTargets = Array.isArray(openSurvey.targets) ? openSurvey.targets : [];

        // Split targets vs stakes (stake = vdi == -100)
        const isStakeTarget = (t) => String(t?.vdi).trim() === '-100';

        let wptCountTargets = 0;
        let wptCountStakes  = 0;

        const wptsTargets = (!exportTargets) ? '' : openTargets.map(t => {
            if (!t || isStakeTarget(t)) return ''; // targets export excludes stakes
            const ll = parseLatLon(t.coordinates);
            if (!ll) return '';

            wptCountTargets++;

            return makeWpt({
                lat: ll.lat,
                lon: ll.lon,
                name: (t.vdi || 'N/A'),
                desc: t.description || '',
                sym: SYM_TARGET,
                extensionsObj: {
                    kind: 'target',
                    color: COLOR_TARGETS,
                    vdi: t.vdi ?? '',
                    type: t.type ?? '',
                    status: t.status ?? '',
                    depth: t.depth ?? '',
                    accuracy: t.accuracy ?? '',
                    user: t.user ?? '',
                    detector: t.detector ?? '',
                    time: t.time ? new Date(t.time).toISOString() : '',
                    surveyId: openSurvey.id || ''
                }
            });
        }).filter(Boolean).join('');

        const wptsStakes = (!exportStakes) ? '' : openTargets.map(t => {
            if (!t || !isStakeTarget(t)) return '';
            const ll = parseLatLon(t.coordinates);
            if (!ll) return '';

            wptCountStakes++;

            return makeWpt({
                lat: ll.lat,
                lon: ll.lon,
                name: (t.description || 'STAKE'),
                desc: t.description || '',
                sym: SYM_STAKE,
                extensionsObj: {
                    kind: 'stake',
                    color: COLOR_STAKES,
                    vdi: t.vdi ?? '',
                    status: t.status ?? '',
                    accuracy: t.accuracy ?? '',
                    time: t.time ? new Date(t.time).toISOString() : '',
                    surveyId: openSurvey.id || ''
                }
            });
        }).filter(Boolean).join('');

        // Finds (conditional)
        const linkedFinds = (Array.isArray(finds) ? finds : []).filter(f => f && f.surveyId === openSurvey.id);
        let wptCountFinds = 0;

        const wptsFinds = (!exportFinds) ? '' : linkedFinds.map(f => {
            const ll = parseLatLon(f.coordinates);
            if (!ll) return '';

            wptCountFinds++;

            const name = f.description || f.name || (f.vdi ? `Find ${f.vdi}` : 'Find');
            const desc = f.description || '';

            return makeWpt({
                lat: ll.lat,
                lon: ll.lon,
                name,
                desc,
                sym: SYM_FIND,
                extensionsObj: {
                    kind: 'find',
                    color: COLOR_FINDS,
                    vdi: f.vdi ?? '',
                    type: f.type ?? '',
                    status: f.status ?? '',
                    depth: f.depth ?? '',
                    accuracy: f.accuracy ?? '',
                    user: f.user ?? '',
                    detector: f.detector ?? '',
                    time: f.time ? new Date(f.time).toISOString() : '',
                    surveyId: f.surveyId || ''
                }
            });
        }).filter(Boolean).join('');

        // Tracks (conditional)
        const surveyTracks = Array.isArray(openSurvey.tracks) ? openSurvey.tracks : [];
        let trkCount = 0;

        const trks = (!exportTracks) ? '' : surveyTracks.map(tr => {
            const xml = makeTrk(tr);
            if (xml) trkCount++;
            return xml;
        }).filter(Boolean).join('');

        const footer = `\n</gpx>\n`;

        const gpx = header + '\n' + wptsTargets + '\n' + wptsStakes + '\n' + wptsFinds + '\n' + trks + footer;

        // Filename helps Garmin infer collection name (no Garmin-only tags needed)
        const safeName = String(openSurvey.name || 'open-survey')
            .trim()
            .replace(/[^\w\- ]+/g, '')
            .replace(/\s+/g, '-')
            .slice(0, 60) || 'open-survey';

        const filename = `DigIt_${safeName}_${new Date().toISOString().slice(0,10)}.gpx`;

        const blob = new Blob([gpx], { type: 'application/gpx+xml;charset=utf-8' });
        const url = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        a.remove();

        setTimeout(() => URL.revokeObjectURL(url), 2000);

        log(`GPX exported: ${filename}`);
        log(exportTargets ? `Waypoints (targets): ${wptCountTargets}` : `Waypoints (targets): SKIPPED`);
        log(exportStakes  ? `Waypoints (stakes): ${wptCountStakes}`  : `Waypoints (stakes): SKIPPED`);
        log(exportFinds   ? `Waypoints (finds): ${wptCountFinds}`    : `Waypoints (finds): SKIPPED`);
        log(exportTracks  ? `Tracks: ${trkCount}`                    : `Tracks: SKIPPED`);

        showMessage('GPX export complete.', 'success');
    } catch (e) {
        console.error('GPX export failed:', e);
        log(`ERROR: ${e.message || 'Unknown error'}`);
        showMessage(`GPX export failed: ${e.message || 'Unknown error'}`, 'error');
    } finally {
        if (btn) {
            btn.disabled = false;
            btn.innerText = originalBtnText || 'Export Open Survey as GPX';
        }
    }
}

/** Renders the content for the new Export page. */
function renderExportPage() {
    const secondaryColor = 'rgb(var(--color-secondary))';

    // Show chosen folder name (if user already picked one this session)
    const chosenFolderName =
        (typeof photoGalleryExportRootHandle !== 'undefined' && photoGalleryExportRootHandle && photoGalleryExportRootHandle.name)
            ? photoGalleryExportRootHandle.name
            : '';

    return `
        <div class="p-4 space-y-6">
            <h2 class="text-3xl font-bold text-primary mb-6">Data Export & Import</h2>

            <!-- SURVEY REPORT (PDF) -->
            <div class="bg-white p-4 rounded-xl shadow-lg border-l-4 border-blue-500">
                <h4 class="text-lg font-semibold text-blue-700 mb-2">Survey Report (PDF)</h4>
                <p class="text-sm text-gray-600 mb-3">
                    Create a printable report for the currently open survey. Use your browser's Print dialog to save as <strong>PDF</strong>.
                </p>

                <button id="export-survey-report-pdf-btn"
                        type="button"
                        onclick="exportSurveyReportPdf()"
                        class="w-full bg-blue-600 text-white px-4 py-3 rounded-lg shadow-md hover:bg-blue-700 transition duration-150">
                    <i class="fas fa-file-pdf mr-1"></i> Export Survey Report (PDF)
                </button>

                <textarea id="export-survey-report-log"
                          rows="6"
                          readonly
                          class="w-full mt-3 p-2 border rounded bg-gray-50 text-xs"></textarea>
            </div>


            <!-- EXPORT OPEN SURVEY ZIP/JSON -->
            <div class="bg-white p-4 rounded-xl shadow-lg border-l-4 border-emerald-500">
                <h4 class="text-lg font-semibold text-emerald-700 mb-2">Export Open Survey (ZIP)</h4>
                <p class="text-sm text-gray-600 mb-3">
                    Export the currently open survey and its photos as a <strong>.zip</strong> file.
                </p>

                <button id="export-open-survey-with-photos-btn"
                        type="button"
                        onclick="exportOpenSurveyWithPhotos()"
                        class="w-full bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-emerald-700 transition duration-150">
                    <i class="fas fa-file-archive mr-1"></i> Export Open Survey as ZIP
                </button>

                <textarea id="export-open-survey-log"
                          rows="6"
                          readonly
                          placeholder="Export log will appear here."
                          class="w-full p-2 border border-emerald-500 rounded-md font-mono text-xs mt-3"></textarea>
            </div>

<div class="bg-white p-4 rounded-xl shadow-lg border-l-4 border-amber-500">
  <h4 class="text-lg font-semibold text-amber-700 mb-2">Export Photo Gallery (Download)</h4>
  <p class="text-sm text-gray-600 mb-3">
    Downloads gallery files to your device (no folder selection; works the same on laptop & phone).
  </p>

  <div class="mt-2 space-y-2 text-sm text-gray-700">
    <label class="flex items-center gap-2">
      <input id="gallery-dl-create-index" type="checkbox" class="h-4 w-4" checked>
      <span><strong>A)</strong> Create linking <code>index.html</code> (may overwrite)</span>
    </label>

    <label class="flex items-center gap-2">
      <input id="gallery-dl-export-open" type="checkbox" class="h-4 w-4" checked>
      <span><strong>B)</strong> Export Open Survey</span>
    </label>

    <label class="flex items-center gap-2">
      <input id="gallery-dl-export-other" type="checkbox" class="h-4 w-4">
      <span><strong>C)</strong> Export all other surveys (Closed/Archived)</span>
    </label>

    <hr class="my-2">

    <label class="flex items-center gap-2">
      <input id="gallery-dl-include-targets" type="checkbox" class="h-4 w-4" checked>
      <span><strong>D)</strong> Export Targets (include in gallery)</span>
    </label>

    <label class="flex items-center gap-2">
      <input id="gallery-dl-include-finds" type="checkbox" class="h-4 w-4" checked>
      <span><strong>E)</strong> Export Finds (include in gallery)</span>
    </label>

    <hr class="my-2">

    <label class="flex items-center gap-2">
      <input id="gallery-dl-write-target-jpgs" type="checkbox" class="h-4 w-4">
      <span><strong>F)</strong> Export Target JPGs (download files)</span>
    </label>

    <label class="flex items-center gap-2">
      <input id="gallery-dl-write-find-jpgs" type="checkbox" class="h-4 w-4">
      <span><strong>G)</strong> Export Find JPGs (download files)</span>
    </label>

    <p class="text-xs text-gray-500 mt-1">
      Note: Browsers download files individually. If you select JPG exports, you may get lots of downloads.
      (We can switch to ZIP later if you want one single download.)
    </p>
  </div>

  <button id="export-gallery-download-btn"
          type="button"
          onclick="exportPhotoGallery_Download()"
          class="w-full mt-4 bg-amber-600 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-amber-700 transition duration-150">
    <i class="fas fa-download mr-1"></i> Export Gallery to Downloads
  </button>

  <textarea id="export-photo-gallery-log"
            rows="7"
            readonly
            placeholder="Export log will appear here."
            class="w-full p-2 border border-amber-500 rounded-md font-mono text-xs mt-3"></textarea>
</div>

            <!-- Export Open Survey as GPX -->
            <div class="bg-white p-4 rounded-xl shadow-lg border-l-4 border-emerald-500">
                <h4 class="text-lg font-semibold text-emerald-700 mb-2">Export Open Survey as GPX</h4>
                <p class="text-sm text-gray-600 mb-3">
                    This creates a <strong>.GPX file</strong> containing the currently open survey, all its targets, and any finds linked to that survey.
                    This can be imported into many mapping apps.
                </p>

                <div class="mt-3 space-y-2 text-sm">
                    <label class="flex items-center gap-2">
                        <input id="gpx-export-targets" type="checkbox" checked class="h-4 w-4">
                        <span><strong>Export Targets</strong></span>
                    </label>

                    <label class="flex items-center gap-2">
                        <input id="gpx-export-stakes" type="checkbox" checked class="h-4 w-4">
                        <span><strong>Export Stakes</strong></span>
                    </label>

                    <label class="flex items-center gap-2">
                        <input id="gpx-export-finds" type="checkbox" checked class="h-4 w-4">
                        <span><strong>Export Finds</strong></span>
                    </label>

                    <label class="flex items-center gap-2">
                        <input id="gpx-export-tracks" type="checkbox" checked class="h-4 w-4">
                        <span><strong>Export Tracks</strong></span>
                    </label>
                </div>

                <button id="export-open-survey-gpx-btn"
                        type="button"
                        onclick="exportOpenSurveyAsGPX()"
                        class="w-full bg-sky-600 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-sky-700 transition duration-150 mt-3">
                    <i class="fas fa-map-marked-alt mr-1"></i> Export Open Survey as GPX
                </button>

                <textarea id="export-open-survey-gpx-log"
                          rows="6"
                          readonly
                          placeholder="GPX export log will appear here."
                          class="w-full p-2 border border-sky-500 rounded-md font-mono text-xs mt-2"></textarea>
            </div>

            <!-- IMPORT SURVEY ZIP/JSON -->
            <div class="bg-white p-4 rounded-xl shadow-lg border-l-4 border-emerald-500">
                <h4 class="text-lg font-semibold text-emerald-700 mb-2">Import Survey (ZIP or JSON)</h4>
                <p class="text-sm text-gray-600 mb-3">
                    Import a survey export file (<strong>.zip</strong> or <strong>.json</strong>).
                    The survey and its finds will be added to your existing local data.
                </p>
                <div class="mb-3">
                    <input type="file" id="import-survey-with-photos-input" accept=".zip,.json" class="hidden" onchange="handleSurveyWithPhotosImport(event)">
                    <button onclick="document.getElementById('import-survey-with-photos-input').click()"
                            class="w-full bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-emerald-700 transition">
                        <i class="fas fa-upload mr-1"></i> Select File & Import
                    </button>
                </div>
                <textarea id="import-survey-log" rows="6" readonly placeholder="Import log will appear here."
                          class="w-full p-2 border border-emerald-500 rounded-md font-mono text-xs mt-2"></textarea>
            </div>

            <!-- IMPORT GPX -->
            <div class="bg-white p-4 rounded-xl shadow-lg border-l-4 border-sky-500">
                <h4 class="text-lg font-semibold text-sky-700 mb-2">Import GPX</h4>
                <p class="text-sm text-gray-600 mb-3">
                    Import a <strong>.gpx</strong> file containing waypoints and/or tracks.
                </p>

                <label class="flex items-center gap-2 text-sm text-gray-700 mb-3">
                    <input id="import-gpx-create-new-cb" type="checkbox" class="h-4 w-4">
                    <span>
                        Close current Open survey and create a <strong>new</strong> survey from this GPX
                    </span>
                </label>

                <input type="file"
                       id="import-gpx-input"
                       accept=".gpx,application/gpx+xml,application/xml,text/xml"
                       class="hidden"
                       onchange="handleGpxImport(event)">

                <button type="button"
                        onclick="(function(){ const i=document.getElementById('import-gpx-input'); if(i){ i.value=''; i.click(); } })()"
                        class="w-full bg-sky-600 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-sky-700 transition">
                    <i class="fas fa-file-import mr-1"></i> Select GPX & Import
                </button>

                <textarea id="import-gpx-log" rows="6" readonly placeholder="GPX import log will appear here."
                          class="w-full p-2 border border-sky-500 rounded-md font-mono text-xs mt-3"></textarea>
            </div>

            <!-- Import Target via QR Code -->
            <div class="bg-white p-4 rounded-xl shadow-lg border border-gray-100 mt-4">
                <h3 class="text-xl font-bold text-primary mb-2">Import Target (QR Code)</h3>

                <p class="text-sm text-gray-600 mb-3">
                    Scan a QR code generated from a Target to import it into the currently open survey.
                </p>

                <button
                    id="scan-target-qr-btn"
                    class="px-4 py-2 rounded-lg text-white font-bold shadow hover:opacity-90"
                    style="background-color: ${secondaryColor};"
                    type="button">
                    Scan Target QR
                </button>
            </div>

        </div>
    `;
}

        
        function promptEditTrackMeta(trackId) {
    // Backwards-compatible wrapper: old callers now open the modal
    openEditTrackModal(trackId);
}

        
        function deleteTrack(trackId) {
    const found = findTrackById(trackId);
    if (!found) {
        showMessage('Track not found.', 'error');
        return;
    }

    const { survey, track } = found;
    const trackName = track.name || 'this track';

    const executeDelete = () => {
        // If deleting the currently active recording track, stop + clear state safely
        if (activeTrackId === track.id && activeTrackSurveyId === survey.id) {
            activeTrackId = null;
            activeTrackSurveyId = null;

            // Also stop tracking so user-location does not keep affecting the map
            isTrackingActive = false;
            if (typeof stopLiveMapLocationWatch === 'function') {
                stopLiveMapLocationWatch();
            }
        }

        // Remove it from the survey
        survey.tracks = (survey.tracks || []).filter(t => t.id !== track.id);

        saveSurveysToLocalStorage();
        showMessage(`Track deleted: ${trackName}.`, 'success');

        // Re-render if we're on Compass so the list + map update immediately
        if (currentPage === 'Compass') {
            render();
        }
    };

    showConfirmationModal(
        `Confirm Delete Track: ${trackName}`,
        `Are you sure you want to permanently delete <strong>${trackName}</strong>?<br>
         <span class="text-sm text-gray-600">This cannot be undone.</span>`,
        executeDelete
    );
}


        
function startTargetLocationWatch() {
    // 1. Get references to the HTML elements
    const coordsInput     = document.getElementById('target-coords');
    const accuracyInput   = document.getElementById('target-accuracy');

    const accuracyDisplayP = document.getElementById('gps-accuracy-display');
    const accuracyValueSpan = accuracyDisplayP
        ? accuracyDisplayP.querySelector('.font-semibold')
        : null;

    // This element is OPTIONAL – it may not exist
    const loadingIndicator = document.getElementById('gps-loading-indicator');

    // Local variable to track the best accuracy received so far
    let bestAccuracy = Infinity;

    // 2. Reset UI state for a new acquisition process
    if (coordsInput) {
        coordsInput.value = '';
        coordsInput.placeholder = 'Waiting for GPS lock...';
        coordsInput.disabled = true;
    }
    if (accuracyInput) {
        accuracyInput.value = '';
    }

    if (accuracyValueSpan) {
        accuracyValueSpan.textContent = 'N/A';
        accuracyValueSpan.className = 'font-semibold text-red-600';
    }
    if (accuracyDisplayP) {
        accuracyDisplayP.classList.add('hidden'); // Hide the visible P tag
    }
    if (loadingIndicator) {
        loadingIndicator.classList.remove('hidden'); // Only if it exists
    }

    if (!navigator.geolocation) {
        showMessage('Geolocation is not supported on this device.', 'error');
        if (coordsInput) {
            coordsInput.placeholder = 'Geolocation not supported';
            coordsInput.disabled = false;
        }
        return;
    }

    // 3. Start Watching (Stream)
    targetWatchId = navigator.geolocation.watchPosition(
        // Success Callback
        (position) => {
            const accuracy = Math.round(position.coords.accuracy*10) / 10;

            // Only update if this reading is more accurate
            if (accuracy < bestAccuracy) {
                bestAccuracy = accuracy;

                const lat = position.coords.latitude.toFixed(6);
                const lon = position.coords.longitude.toFixed(6);

                if (coordsInput) {
                    coordsInput.value = `${lat}, ${lon}`;
                    coordsInput.placeholder = 'GPS Locked';
                    coordsInput.disabled = false;
                }

                if (accuracyInput) {
                    accuracyInput.value = accuracy.toFixed(2);
                }

                if (accuracyValueSpan) {
                    accuracyValueSpan.textContent = `${accuracy.toFixed(1)} meters`;

                    if (accuracy < 5) {
                        accuracyValueSpan.className = 'font-semibold text-green-600';
                    } else if (accuracy < 15) {
                        accuracyValueSpan.className = 'font-semibold text-yellow-600';
                    } else {
                        accuracyValueSpan.className = 'font-semibold text-red-600';
                    }
                }

                console.log(`New Best Accuracy: ${accuracy.toFixed(1)}m`);
            }

            // Hide loading / show accuracy display
            if (loadingIndicator) {
                loadingIndicator.classList.add('hidden');
            }
            if (accuracyDisplayP) {
                accuracyDisplayP.classList.remove('hidden');
            }
        },

        // Error Callback
  (error) => {
    console.error('GPS Watch Error:', error);

    if (loadingIndicator) {
        loadingIndicator.classList.add('hidden');
    }
    if (accuracyDisplayP && accuracyValueSpan) {
        accuracyDisplayP.classList.remove('hidden');
        accuracyValueSpan.textContent = 'Error';
        accuracyValueSpan.className = "font-semibold text-red-600";
    }
    if (coordsInput) {
        coordsInput.placeholder = 'GPS Error (Type Manually)';
        coordsInput.disabled = false;
    }

    // Quiet the UI: no toast, just console + placeholder guidance
    // (User sees "GPS Error (Type Manually)" in the field itself.)
},

        // Options
        {
            enableHighAccuracy: true,
            timeout: 30000,
            maximumAge: 0
        }
    );
}
        
        function stopTargetLocationWatch() {
    if (targetWatchId !== null) {
        navigator.geolocation.clearWatch(targetWatchId);
        targetWatchId = null;
        console.log("Target GPS Watch stopped.");
    }
}
        
// --- LIVE MAP GPS WATCH FUNCTIONS (New/Modified Logic) ---

        /** Starts a continuous, high-accuracy GPS stream that only updates the state when a reading is more accurate. 
         * Also starts the 5-second rendering interval.
         */
/** Starts a continuous, high-accuracy GPS stream that only updates the state when a reading is more accurate. 
 * Also starts the 5-second rendering interval.
 */
/** Starts a continuous, high-accuracy GPS stream for the live map. */
// --- LIVE MAP GPS WATCH FUNCTIONS (New/Modified Logic) ---

/** Starts a continuous, high-accuracy GPS stream for the live map
 *  and starts the auto-refresh interval to redraw the map.
 */
function stopLiveMapLocationWatch() {
    if (liveMapWatchId) {
        navigator.geolocation.clearWatch(liveMapWatchId);
        liveMapWatchId = null;
        bestLiveAccuracy = Infinity;
    }

    // Clear all live-user map state so it cannot affect the bounding box
    currentUserCoords = null;
    currentUserAccuracy = null;
    smoothedUserCoords = null;
    movementHistory = [];
    bestLiveAccuracy = Infinity;
    smoothedUserCoords = null;
    movementHistory = [];
    hasRenderedFirstGpsFix = false;


    console.log("Live Map GPS Watch stopped and user map state cleared.");
}

    function startLiveMapLocationWatch() {
    if (!navigator.geolocation) {
        currentUserCoords = null;
        currentUserAccuracy = null;
        smoothedUserCoords = null;
        showMessage('Geolocation is not supported on this device.', 'error');
        return;
    }

  // Fresh run each time we arrive on the Compass page
bestLiveAccuracy = Infinity;
smoothedUserCoords = null;
movementHistory = [];

// Reset last-known user position to avoid stale data
currentUserCoords = null;
currentUserAccuracy = null;

// Ensure first GPS fix triggers a redraw
hasRenderedFirstGpsFix = false;

    // Start / restart the GPS watch
    if (liveMapWatchId !== null) {
        navigator.geolocation.clearWatch(liveMapWatchId);
        liveMapWatchId = null;
    }

liveMapWatchId = navigator.geolocation.watchPosition(
        (position) => {
            const accuracy = Math.round(position.coords.accuracy *10) / 10;

            // Raw latest reading
            currentUserCoords = {
                lat: position.coords.latitude,
                lon: position.coords.longitude
            };
            currentUserAccuracy = accuracy;

            // Update smoothed position used by the map
            updateSmoothedUserCoords(currentUserCoords.lat, currentUserCoords.lon);
            // Record this smoothed point into the movement history
            if (smoothedUserCoords) {
                recordMovementSample(smoothedUserCoords.lat, smoothedUserCoords.lon);   
            }
            // Faster UI updates: refresh on GPS fixes (throttled), still keyboard-safe
            const now = Date.now();
            if (currentPage === 'Compass' && (now - lastGpsUiRefreshMs) > 700) { // 0.7s throttle
                lastGpsUiRefreshMs = now;
                updateMapWithUserLocationAndRender();
            }

// If navigating, record a breadcrumb point (real walked path)
if (navSession && navSession.active && navigationTargetId && smoothedUserCoords) {
    if (!Array.isArray(navSession.path)) navSession.path = [];

    const lat = smoothedUserCoords.lat;
    const lon = smoothedUserCoords.lon;

    // Only add a point if we've moved ~2m or more (reduces jitter)
    if (navSession.lastLat === null || navSession.lastLon === null) {
        navSession.lastLat = lat;
        navSession.lastLon = lon;
        navSession.path.push({ lat, lon });
    } else {
        const d = distanceMeters(navSession.lastLat, navSession.lastLon, lat, lon);
        if (d >= 2) {
            navSession.lastLat = lat;
            navSession.lastLon = lon;
            navSession.path.push({ lat, lon });
        }
    }
}
            

        // Force a one-time redraw on first GPS fix so the user dot appears immediately
if (!hasRenderedFirstGpsFix && currentUserCoords && currentPage === 'Compass') {
    hasRenderedFirstGpsFix = true;

    // Re-render Compass safely without starting extra loops
    const appContent = document.getElementById('app-content');
    if (appContent) {
        appContent.innerHTML = renderCompassPage(true);
        attachPageEventListeners();
    }
}



            // NEW: if we’re recording a track, log a point using the smoothed location
            if (smoothedUserCoords && activeTrackId && activeTrackSurveyId) {
                logPointToActiveTrack(smoothedUserCoords.lat, smoothedUserCoords.lon, accuracy);
            }

            // Track best accuracy (for logging/info)
            if (accuracy < bestLiveAccuracy) {
                bestLiveAccuracy = accuracy;
            }

            // ... rest of your logging code stays the same ...

            console.log(
                `Live Map position (raw): ${currentUserCoords.lat.toFixed(6)}, ` +
                `${currentUserCoords.lon.toFixed(6)} (acc: ${accuracy.toFixed(1)}m, best: ${bestLiveAccuracy.toFixed(1)}m)`
            );

            if (smoothedUserCoords) {
                console.log(
                    `Live Map position (smoothed): ${smoothedUserCoords.lat.toFixed(6)}, ` +
                    `${smoothedUserCoords.lon.toFixed(6)}`
                );
            }
        },
        (error) => {
            currentUserCoords = null;
            currentUserAccuracy = null;
            smoothedUserCoords = null;
            console.error('Live Map GPS Watch Error:', error);
        },
        {
            enableHighAccuracy: true,
            maximumAge: 0
        }
    );

    // Start the auto-refresh interval (if not already running)
    if (autoRefreshIntervalId === null) {
        autoRefreshIntervalId = setInterval(() => {
            updateMapWithUserLocationAndRender();
        }, 1000); // 3 seconds
        console.log('Live Map GPS Watch and auto-refresh interval started.');
    }
}

/** Wrapper function to re-render Compass page for auto-refresh using the latest watched GPS data. */
function triggerImportSurvey() {
    importSurveyWithPhotosFromFile();
}

async function handleGpxImport(event) {
    const fileInput = event?.target;
    const file = fileInput?.files?.[0];

    const createNewCb = document.getElementById('import-gpx-create-new-cb');

    // Keep a buffer so we can restore the log even if render() re-builds the page
    let logBuffer = '';

    const appendLog = (msg) => {
        const line = String(msg);
        console.log('[GPX Import]', line);
        logBuffer += line + '\n';

        const logBoxNow = document.getElementById('import-gpx-log');
        if (logBoxNow) {
            logBoxNow.value = logBuffer;
            logBoxNow.scrollTop = logBoxNow.scrollHeight;
        }
    };

    const setLog = (text) => {
        logBuffer = String(text || '');
        const logBoxNow = document.getElementById('import-gpx-log');
        if (logBoxNow) {
            logBoxNow.value = logBuffer;
            logBoxNow.scrollTop = logBoxNow.scrollHeight;
        }
    };

    // Clear current log
    setLog('');

    if (!file) {
        showMessage('No GPX file selected.', 'error');
        return;
    }

    const wantNewSurvey = !!(createNewCb && createNewCb.checked);

    // Helper: show a longer toast if your toast supports it; otherwise fall back.
    const showMessageLong = (text, type = 'info', ms = 4500) => {
        try {
            // If you later extend showMessage to accept duration, this will just work.
            if (typeof showMessage === 'function') showMessage(text, type);
            // Also keep a visible console hint:
            console.log(`[Toast:${type}] ${text} (${ms}ms requested)`);
        } catch (_) {
            // no-op
        }
    };

    const doImport = async () => {
        try {
            showMessageLong('Importing GPX…', 'info', 2500);

            appendLog(`Selected file: ${file.name}`);
            appendLog('Reading file…');

            const gpxText = await file.text();

            appendLog('Parsing GPX…');
            const parsed = parseGpxToObjects_Loose(gpxText);

            const wptCount = parsed?.waypoints?.length || 0;
            const trkCount = parsed?.tracks?.length || 0;

            appendLog(`Detected: ${wptCount} waypoint(s), ${trkCount} track(s)`);

            if (!wptCount && !trkCount) {
                showMessageLong('No waypoints or tracks found in this GPX.', 'warning', 5000);
                appendLog('Nothing to import (no <wpt> and no <trkpt> found).');
                return;
            }

            const now = Date.now();

            // ---- choose destination survey ----
            let destSurvey = surveys.find(s => s.status === 'Open') || null;

            if (wantNewSurvey || !destSurvey) {

                // LIMITS: block creating a NEW survey from GPX if over limit / expired
                const rs = canCreate('surveys');
                if (!rs.ok) {
                    showMessage(rs.reason, 'error');
                    appendLog(`LIMIT: ${rs.reason}`);
                    return; // stop the whole import (because this mode needs a new survey)
                }

                // Close any open survey
                surveys.forEach(s => {
                    if (s.status === 'Open') {
                        s.status = 'Active';
                        s.dateLastChanged = now;
                    }
                });

                const baseName =
                    (parsed.metadataName && String(parsed.metadataName).trim()) ||
                    file.name.replace(/\.gpx$/i, '') ||
                    'Imported GPX';

                destSurvey = {
                    id: generateId(),
                    name: baseName,
                    description: `Imported from GPX: ${file.name}`,
                    status: 'Open',
                    creationDate: now,
                    dateLastChanged: now,
                    targets: [],
                    finds: [],
                    tracks: [],
                    surveyPhotoRef: '',
                    surveyPhotoData: ''
                };

                surveys.unshift(destSurvey);
                appendLog(`Created new survey: "${destSurvey.name}"`);
            } else {
                if (!Array.isArray(destSurvey.targets)) destSurvey.targets = [];
                if (!Array.isArray(destSurvey.tracks)) destSurvey.tracks = [];
                appendLog(`Merging into open survey: "${destSurvey.name}"`);
            }

            // ---- import waypoints -> targets ----
            let importedTargets = 0;
            let stoppedEarly = false;
            let stopReason = '';

            for (const w of (parsed.waypoints || [])) {

                // LIMITS: stop importing targets once limit/expiry is reached
                const r = canCreate('targets');
                if (!r.ok) {
                    stoppedEarly = true;
                    stopReason = r.reason || 'Limit reached.';
                    appendLog(`LIMIT: ${stopReason} Stopping target import.`);
                    break;
                }

                const coords = `${Number(w.lat).toFixed(6)}, ${Number(w.lon).toFixed(6)}`;

                const t = {
                    id: generateId(),
                    description: w.desc || w.name || 'Imported Target',
                    vdi: inferVdiFromName(w.name) || ((w.extensions && w.extensions.vdi) || 'N/A'),
                    depth: (w.extensions && w.extensions.depth) || '',
                    type: (w.extensions && w.extensions.type) || 'Unidentified',
                    status: (w.extensions && w.extensions.status) || 'Signal Detected',
                    time: (w.timeMs || now),
                    coordinates: coords,
                    accuracy: (w.extensions && w.extensions.accuracy) || '',
                    user: (w.extensions && w.extensions.user) || userProfile.name || '',
                    detector: (w.extensions && w.extensions.detector) || userProfile.detector || '',
                    centerOnMap: false,

                    photos: [],
                    targetPhotoRef: '',
                    targetPhotoData: ''
                };

                destSurvey.targets.unshift(t);
                importedTargets++;
            }

            // ---- import tracks ----
            let importedTracks = 0;

            for (const trk of (parsed.tracks || [])) {
                if (!trk.points || !trk.points.length) continue;

                const newTrack = {
                    id: generateId(),
                    name: trk.name || `Imported Track ${destSurvey.tracks.length + 1}`,
                    description: trk.desc || '',
                    createdAt: trk.points[0].timeMs || now,
                    isRecording: false,
                    isVisible: true,
                    color: pickTrackColor(destSurvey.tracks.length),
                    points: trk.points.map(p => ({
                        time: p.timeMs || now,
                        lat: p.lat,
                        lon: p.lon,
                        accuracy: (p.accuracy != null ? p.accuracy : null)
                    }))
                };

                destSurvey.tracks.push(newTrack);
                importedTracks++;
            }

            destSurvey.dateLastChanged = Date.now();
            saveSurveysToLocalStorage();

            appendLog('---');
            appendLog(`Imported targets: ${importedTargets}`);
            appendLog(`Imported tracks:  ${importedTracks}`);

            // Final message: success if full import, info + reason if stopped early
            const baseMsg = `GPX imported: ${importedTargets} targets, ${importedTracks} tracks.`;
            if (stoppedEarly) {
                appendLog(`NOTE: Import stopped early — ${stopReason}`);
                showMessageLong(`${baseMsg} (Stopped early: ${stopReason})`, 'info', 7000);
            } else {
                showMessageLong(baseMsg, 'success', 6000);
            }

            // IMPORTANT: Don't wipe the log by re-rendering the Export page.
            // If you're currently on the Export page, keep the UI as-is so the log stays visible.
            // If you're on some other page, a render refresh is useful.
            const isExportPageActive =
                (typeof currentPage === 'string' && currentPage.toLowerCase().includes('export')) ||
                document.getElementById('import-gpx-log'); // heuristic: export page has this textarea

            if (!isExportPageActive) {
                if (typeof render === 'function') render();
            } else {
                // ensure the log is visible even if something else refreshed parts of the DOM
                setLog(logBuffer);
            }

        } catch (e) {
            console.error('GPX import failed:', e);
            showMessageLong(`GPX import failed: ${e?.message || e}`, 'error', 8000);
            appendLog(`ERROR: ${e?.message || e}`);
        } finally {
            // allow selecting same file again
            try { fileInput.value = ''; } catch (_) {}
        }
    };

    if (wantNewSurvey) {
        const openSurvey = surveys.find(s => s.status === 'Open');
        const openName = openSurvey ? (openSurvey.name || 'Open survey') : '(none)';

        showConfirmationModal(
            'Import GPX as New Survey',
            `This will close the current Open survey (<strong>${openName}</strong>) and create a new survey from:<br><br>
             <strong>${file.name}</strong><br><br>
             Continue?`,
            doImport
        );
    } else {
        doImport();
    }
}
        
/**
 * GPX parser that is tolerant of namespaces and different exporters.
 * It does NOT require getElementsByTagNameNS; it matches by element.localName.
 */
function parseGpxToObjects_Loose(gpxText) {
    const parser = new DOMParser();
    const xml = parser.parseFromString(gpxText, 'application/xml');

    // Detect parse errors
    if (xml.getElementsByTagName('parsererror').length) {
        throw new Error('GPX XML parse error.');
    }

    const allElements = Array.from(xml.getElementsByTagName('*'));

    const firstChildText = (el, local) => {
        if (!el) return '';
        const child = Array.from(el.getElementsByTagName('*'))
            .find(n => (n.localName || n.nodeName) === local);
        return child && child.textContent ? child.textContent.trim() : '';
    };

    const parseExtensionsLoose = (el) => {
        const out = {};
        if (!el) return out;

        const ext = Array.from(el.getElementsByTagName('*'))
            .find(n => (n.localName || n.nodeName) === 'extensions');
        if (!ext) return out;

        Array.from(ext.children || []).forEach(ch => {
            const k = ch.localName || ch.nodeName;
            const v = (ch.textContent || '').trim();
            if (k && v) out[k] = v;
        });

        return out;
    };

    // metadata name
    const metadata = allElements.find(n => (n.localName || n.nodeName) === 'metadata') || null;
    const metadataName = metadata ? firstChildText(metadata, 'name') : '';

    // waypoints
    const wptEls = allElements.filter(n => (n.localName || n.nodeName) === 'wpt');
    const waypoints = wptEls.map(wpt => {
        const lat = Number(wpt.getAttribute('lat'));
        const lon = Number(wpt.getAttribute('lon'));
        if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;

        const name = firstChildText(wpt, 'name');
        const desc = firstChildText(wpt, 'desc');
        const timeStr = firstChildText(wpt, 'time');
        const timeMs = timeStr ? Date.parse(timeStr) : null;

        const extensions = parseExtensionsLoose(wpt);

        return {
            lat, lon,
            name, desc,
            timeMs: (timeMs && !isNaN(timeMs)) ? timeMs : null,
            extensions
        };
    }).filter(Boolean);

    // tracks + points
    const trkEls = allElements.filter(n => (n.localName || n.nodeName) === 'trk');
    const tracks = trkEls.map(trk => {
        const name = firstChildText(trk, 'name') || '';
        const desc = firstChildText(trk, 'desc') || '';

        const trkptEls = Array.from(trk.getElementsByTagName('*'))
            .filter(n => (n.localName || n.nodeName) === 'trkpt');

        const points = trkptEls.map(pt => {
            const lat = Number(pt.getAttribute('lat'));
            const lon = Number(pt.getAttribute('lon'));
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;

            const timeStr = firstChildText(pt, 'time');
            const timeMs = timeStr ? Date.parse(timeStr) : null;

            const ext = parseExtensionsLoose(pt);
            const acc = (ext.accuracy != null && String(ext.accuracy).trim() !== '')
                ? Number(ext.accuracy)
                : null;

            return {
                lat, lon,
                timeMs: (timeMs && !isNaN(timeMs)) ? timeMs : null,
                accuracy: (acc != null && !isNaN(acc)) ? acc : null
            };
        }).filter(Boolean);

        return { name, desc, points };
    });

    return { metadataName, waypoints, tracks };
}

function inferVdiFromName(name) {
    const s = String(name || '').trim();
    if (!s) return '';
    if (/^-?\d+(\.\d+)?$/.test(s)) return s;
    return '';
}

/** Parse GPX into waypoints + tracks (namespace-safe). */
function parseGpxToObjects(gpxText) {
    const parser = new DOMParser();
    const xml = parser.parseFromString(gpxText, 'application/xml');

    // Detect parse errors
    const pe = xml.getElementsByTagName('parsererror');
    if (pe && pe.length) {
        throw new Error('GPX XML parse error.');
    }

    const getFirstTextByLocal = (parent, localName) => {
        if (!parent) return '';
        const nodes = parent.getElementsByTagNameNS('*', localName);
        if (nodes && nodes[0] && nodes[0].textContent != null) return nodes[0].textContent.trim();
        return '';
    };

    const parseExtensions = (parent) => {
        const out = {};
        if (!parent) return out;

        const extNodes = parent.getElementsByTagNameNS('*', 'extensions');
        const ext = extNodes && extNodes[0] ? extNodes[0] : null;
        if (!ext) return out;

        for (const ch of Array.from(ext.childNodes || [])) {
            if (ch.nodeType !== 1) continue; // ELEMENT_NODE
            const k = ch.localName || ch.nodeName;
            const v = (ch.textContent || '').trim();
            if (k && v) out[k] = v;
        }
        return out;
    };

    // Metadata name (optional)
    const md = xml.getElementsByTagNameNS('*', 'metadata')[0] || null;
    const metadataName = md ? getFirstTextByLocal(md, 'name') : '';

    // Waypoints
    const wptNodes = Array.from(xml.getElementsByTagNameNS('*', 'wpt'));
    const waypoints = wptNodes.map(wpt => {
        const lat = Number(wpt.getAttribute('lat'));
        const lon = Number(wpt.getAttribute('lon'));
        const name = getFirstTextByLocal(wpt, 'name');
        const desc = getFirstTextByLocal(wpt, 'desc');
        const sym  = getFirstTextByLocal(wpt, 'sym');
        const extensions = parseExtensions(wpt);

        return {
            lat, lon,
            name, desc, sym,
            extensions
        };
    }).filter(w => Number.isFinite(w.lat) && Number.isFinite(w.lon));

    // Tracks
    const trkNodes = Array.from(xml.getElementsByTagNameNS('*', 'trk'));
    const tracks = trkNodes.map(trk => {
        const name = getFirstTextByLocal(trk, 'name') || '';
        const desc = getFirstTextByLocal(trk, 'desc') || '';

        const trkptNodes = Array.from(trk.getElementsByTagNameNS('*', 'trkpt'));
        const points = trkptNodes.map(pt => {
            const lat = Number(pt.getAttribute('lat'));
            const lon = Number(pt.getAttribute('lon'));
            if (!Number.isFinite(lat) || !Number.isFinite(lon)) return null;

            const timeStr = getFirstTextByLocal(pt, 'time');
            const t = timeStr ? Date.parse(timeStr) : null;

            const ext = parseExtensions(pt);
            const acc = (ext.accuracy != null && String(ext.accuracy).trim() !== '')
                ? Number(ext.accuracy)
                : null;

            return {
                lat, lon,
                time: (t && !isNaN(t)) ? t : null,
                accuracy: (acc != null && !isNaN(acc)) ? acc : null
            };
        }).filter(Boolean);

        return { name, desc, points };
    });

    return { metadataName, waypoints, tracks };
}

/** If a waypoint <name> looks like a VDI number, use it. */
function inferVdiFromName(name) {
    const s = String(name || '').trim();
    if (!s) return '';
    // allow "-7", "28", etc.
    if (/^-?\d+(\.\d+)?$/.test(s)) return s;
    return '';
}

function stopCompassAutoRefresh() {
    if (autoRefreshIntervalId) {
        clearInterval(autoRefreshIntervalId);
        autoRefreshIntervalId = null;
        console.log("Compass auto-refresh stopped.");
    }
    if (window._compassWatchId) {
        try {
            navigator.geolocation.clearWatch(window._compassWatchId);
        } catch (e) {}
        window._compassWatchId = null;
        console.log("Compass GPS watch stopped.");
    }
}

function startCompassAutoRefresh() {
    // Only run while actually on Compass
    if (currentPage !== 'Compass') return;

    // 1) Prefer GPS-driven updates (fast + responsive)
    // If you already start a watch elsewhere, this will just use it.
    if (!window._compassWatchId && navigator.geolocation) {
        try {
            window._compassWatchId = navigator.geolocation.watchPosition(
                () => {
                    // Each GPS update triggers an immediate refresh/render.
                    if (currentPage !== 'Compass') return;
                    updateMapWithUserLocationAndRender();
                },
                (err) => {
                    console.warn("Compass GPS watch error:", err);
                },
                {
                    enableHighAccuracy: true,
                    maximumAge: 0,   // don't reuse old locations
                    timeout: 10000
                }
            );
            console.log("Compass GPS watch started.");
        } catch (e) {
            console.warn("Compass GPS watch start failed:", e);
        }
    }

    // 2) Keep a light safety-net interval (in case GPS events pause)
    // Use a faster interval than 3000ms, but not crazy fast.
    if (!autoRefreshIntervalId) {
        autoRefreshIntervalId = setInterval(() => {
            if (currentPage !== 'Compass') return;
            updateMapWithUserLocationAndRender();
        }, 800); // was 3000; 800ms feels much more responsive
        console.log("Compass auto-refresh started/resumed (safety net).");
    }
}

/**
 * Refresh Compass while avoiding the mobile keyboard drop.
 * Rule: NEVER full re-render while the Target ID box is focused.
 * Otherwise, prefer a lightweight update to avoid jank.
 */
function updateMapWithUserLocationAndRender() {
    if (currentPage !== 'Compass') return;

    const ae = document.activeElement;
    const tag = ae ? (ae.tagName || '').toUpperCase() : '';
    const isFormControl = !!ae && (tag === 'INPUT' || tag === 'TEXTAREA' || tag === 'SELECT' || ae.isContentEditable);

    // The *real* keypad-drop risk: the quick Target ID box on Compass.
    const isTypingTargetId = !!ae && ae.id === 'compass-quick-target-vdi';

    // If user is typing the Target ID, do NOT refresh anything.
    if (isTypingTargetId) {
        // preserve draft
        compassQuickTargetIdDraft = ae.value || '';
        return;
    }

    // If some other form control is focused, avoid full DOM replacement,
    // but we can still do a light refresh (navigation panel / mini-map).
    const avoidFullRender = isFormControl;

    // -----------------------------------------
    // FAST PATH: update mini-map / nav area only
    // -----------------------------------------
    // These IDs are safe even if they don't exist yet (we just fall back).
    const navMiniMapHost = document.getElementById('nav-mini-map-host');
    const navStatusHost = document.getElementById('nav-status-host');

    // If you have an active navigation target, we can update the mini map cheaply.
    // We'll try to render ONLY that portion.
    if (navMiniMapHost && typeof renderNavigationMiniMapSimple === 'function' && navigationTargetId) {
        try {
            // You already have the target id; locate the target object.
            const openSurvey = surveys.find(s => s.status === 'Open');
            if (openSurvey) {
                const targets = getActiveTargets(openSurvey) || [];
                const target = targets.find(t => String(t.id) === String(navigationTargetId) || String(t.targetId) === String(navigationTargetId));
                if (target && target.coordinates && String(target.coordinates).includes(',')) {
                    const parts = String(target.coordinates).split(',');
                    const tLat = parseFloat(parts[0]);
                    const tLon = parseFloat(parts[1]);

                    // Use your existing user position variables if you have them,
                    // otherwise fall back to passed-in coords (renderCompassPage handles this anyway).
                    const uLat = (typeof liveUserLat === 'number') ? liveUserLat
                               : (typeof currentUserLat === 'number') ? currentUserLat
                               : (typeof userLat === 'number') ? userLat
                               : null;

                    const uLon = (typeof liveUserLon === 'number') ? liveUserLon
                               : (typeof currentUserLon === 'number') ? currentUserLon
                               : (typeof userLon === 'number') ? userLon
                               : null;

                    // If we can't find live coords here, just fall back to full render.
                    if (typeof uLat === 'number' && typeof uLon === 'number') {
                        const d = (typeof calculateDistanceMeters === 'function')
                            ? calculateDistanceMeters(uLat, uLon, tLat, tLon)
                            : distMeters;

                        const b = (typeof calculateBearingDegrees === 'function')
                            ? calculateBearingDegrees(uLat, uLon, tLat, tLon)
                            : bearingDeg;

                        navMiniMapHost.innerHTML = renderNavigationMiniMapSimple({
                            targetLat: tLat,
                            targetLon: tLon,
                            userLat: uLat,
                            userLon: uLon,
                            distMeters: (typeof d === 'number') ? d : distMeters,
                            bearingDeg: (typeof b === 'number') ? b : bearingDeg,
                            movementBearingDeg: (typeof window.movementBearingDeg === 'number') ? window.movementBearingDeg : movementBearingDeg
                        });

                        // Optional: update any simple text status if you have a host
                        if (navStatusHost) {
                            navStatusHost.textContent = '';
                        }

                        // If we're avoiding full render due to other focused input, stop here.
                        if (avoidFullRender) return;
                        // Otherwise, we *can* still do a full render occasionally,
                        // but no need right now—fast update already happened.
                        return;
                    }
                }
            }
        } catch (e) {
            // If anything goes wrong, fall through to full render.
            console.warn("Mini-map fast refresh failed:", e);
        }
    }

    // -----------------------------------------
    // FALLBACK: full re-render (safe when not typing Target ID)
    // -----------------------------------------
    if (avoidFullRender) {
        // User is focused in some other input; don't blow away the DOM.
        // Better to do nothing than destroy their interaction.
        return;
    }

    const appContent = document.getElementById('app-content');
    if (!appContent) return;

    appContent.innerHTML = renderCompassPage(true);
    attachPageEventListeners();
}
    /** Shows a temporary, highly visible notification toast (top-centre). */
function showMessage(message, type = 'info') {
    const toast = document.getElementById('message-toast');
    if (!toast) return;

    // Clear any old fade timers
    if (toast._hideTimer) {
        clearTimeout(toast._hideTimer);
        toast._hideTimer = null;
    }
    if (toast._removeTimer) {
        clearTimeout(toast._removeTimer);
        toast._removeTimer = null;
    }

    toast.textContent = message;

    // Strong background colours
    const bgColor =
        type === 'success' ? 'bg-green-600'
        : type === 'error' ? 'bg-red-700'
        : type === 'warning' ? 'bg-yellow-600'
        : 'bg-gray-900';

    toast.className = [
        'fixed',
        'top-20',
        'left-1/2',
        '-translate-x-1/2',
        'z-50',
        'px-5',
        'py-3',
        'rounded-xl',
        'text-white',
        'font-semibold',
        'shadow-2xl',
        'border',
        'border-white/30',
        'opacity-100',
        'transition-opacity',
        'duration-400'
    ].join(' ') + ' ' + bgColor;

    // Fade out after 2.5 seconds
    toast._hideTimer = setTimeout(() => {
        toast.classList.add('opacity-0');
    }, 2500);

    // Remove (display:none) after the fade finishes
    toast._removeTimer = setTimeout(() => {
        toast.style.display = 'none';
    }, 3000);

    // Ensure it's visible again on next message
    toast.style.display = 'block';
}

        
 /** Shows the generic confirmation modal (supports async callbacks safely). */
function showConfirmationModal(title, message, onConfirmCallback) {
    const modal = document.getElementById('confirmation-modal');
    const titleEl = document.getElementById('confirm-title');
    const msgEl = document.getElementById('confirm-message');

    const yesBtn = document.getElementById('confirm-yes-btn');
    const noBtn  = document.getElementById('confirm-no-btn');

    if (!modal || !titleEl || !msgEl || !yesBtn || !noBtn) return;

    titleEl.innerHTML = title;
    msgEl.innerHTML = message;

    // Reset any previous handlers
    yesBtn.onclick = null;
    noBtn.onclick  = null;

    const close = () => {
        modal.style.display = 'none';
        // Re-enable buttons in case we disabled them
        yesBtn.disabled = false;
        noBtn.disabled  = false;
        yesBtn.onclick = null;
        noBtn.onclick  = null;
    };

    noBtn.onclick = close;

    yesBtn.onclick = async () => {
        // Prevent double-taps
        yesBtn.disabled = true;
        noBtn.disabled  = true;

        try {
            // IMPORTANT: await the caller (so errors are caught here)
            await onConfirmCallback();
            close();
        } catch (e) {
            // Treat user-cancelled pickers as a normal “cancel”
            if (e && (e.name === 'AbortError' || String(e.message || '').toLowerCase().includes('aborted'))) {
                console.log('User cancelled the request:', e);
                if (typeof showMessage === 'function') showMessage('Cancelled.', 'info');
                close();
                return;
            }

            console.error('Confirmation action failed:', e);
            if (typeof showMessage === 'function') {
                showMessage(`Action failed: ${e.message || e}`, 'error');
            }
            close();
        }
    };

    modal.style.display = 'block';
}

        /** Closes the generic confirmation modal. */
        function closeConfirmationModal() {
            document.getElementById('confirmation-modal').style.display = 'none';
        }

    /** Shows the New Survey Modal and attaches the submit listener. */
function showNewSurveyModal() {
    // LIMITS: block opening the modal if over limit / expired
    const r = canCreate('surveys');
    if (!r.ok) {
        showMessage(r.reason, 'error');
        return;
    }

    // Reset the form whenever the modal is opened
    const form = document.getElementById('new-survey-form');
    if (form) form.reset();

    // Reset multi-photo buffer + preview
    window.currentNewSurveyPhotos = [];
    updateNewSurveyPhotoPreview();

    // Ensure file input is configured for multi-select + no forced camera
    const input = document.getElementById('new-survey-photo-input');
    if (input) {
        try { input.removeAttribute('capture'); } catch (e) {}
        input.multiple = true;
    }

    // Use shared helper to attach the submit listener safely
    attachFormSubmitHandler('new-survey-form', handleNewSurveySubmit);

    // Show the modal via shared helper
    openModal('new-survey-modal');
}

/** Closes the New Survey Modal. */
function closeNewSurveyModal() {
    closeModal('new-survey-modal');
}

async function handleNewSurveySubmit(event) {
    event.preventDefault();

    const form = event.target;
    const name = form['surveyName'].value.trim();
    const description = form['surveyDescription'].value.trim() || 'No description provided.';
    const now = Date.now();

    if (!name) {
        showMessage('Survey Name is required.', 'error');
        return;
    }

    // LIMITS: block creating new surveys if over limit / expired
    const r = canCreate('surveys');
    if (!r.ok) {
        showMessage(r.reason, 'error');
        return;
    }

    // ✅ CRITICAL: new survey must start "clean" (no leftover tracking/recording)
    resetLiveTrackingAndRecordingState();

    // --- Photos: parse JSON array (or single string) from hidden field ---
    let photosDataUrls = [];
    const rawPhotoField = form['surveyPhotoData']?.value;

    if (rawPhotoField) {
        try {
            const parsed = JSON.parse(rawPhotoField);
            if (Array.isArray(parsed)) {
                photosDataUrls = parsed.filter(p => typeof p === 'string' && p.length > 0);
            } else if (typeof parsed === 'string' && parsed.length > 0) {
                photosDataUrls = [parsed];
            }
        } catch (e) {
            // Not valid JSON? Treat as single data URL
            if (typeof rawPhotoField === 'string' && rawPhotoField.length > 0) {
                photosDataUrls = [rawPhotoField];
            }
        }
    }

    // Save these data URLs into IndexedDB and get back lightweight references
    let photoRefs = [];
    try {
        photoRefs = await saveDataUrlsAsPhotoRefs(photosDataUrls);
    } catch (e) {
        console.error('Error saving survey photos to IndexedDB:', e);
        photoRefs = [];
    }

    const primaryDataUrl = photosDataUrls[0] || '';
    const primaryRef     = photoRefs[0] || '';

    // 1. Close any currently open survey
    surveys.forEach(s => {
        if (s.status === 'Open') {
            s.status = 'Active';
            s.dateLastChanged = now;
        }
    });

    // 2. Create the new survey object
    
    // NEW: optional survey metadata fields (Sections 1–7)
    const permissionFrom = (document.getElementById('survey-permission-from')?.value || '').trim();
    const permissionType = (document.getElementById('survey-permission-type')?.value || '').trim();
    let permissionDateGranted = (document.getElementById('survey-permission-date-granted')?.value || '').trim();
    let permissionExpiry = (document.getElementById('survey-permission-expiry')?.value || '').trim();

    // Normalize permission dates to DD/MM/YY for storage
    permissionDateGranted = formatSurveyPermissionDate(permissionDateGranted);
    permissionExpiry      = formatSurveyPermissionDate(permissionExpiry);
const permissionNotes = (document.getElementById('survey-permission-notes')?.value || '').trim();

    const areaType = (document.getElementById('survey-area-type')?.value || '').trim();
    const landUseCurrent = (document.getElementById('survey-land-use-current')?.value || '').trim();

    const soilType = (document.getElementById('survey-soil-type')?.value || '').trim();
    const groundCondition = (document.getElementById('survey-ground-condition')?.value || '').trim();
    const mineralisationLevel = (document.getElementById('survey-mineralisation-level')?.value || '').trim();

    const weather = (document.getElementById('survey-weather')?.value || '').trim();
    const recentRain = (document.getElementById('survey-recent-rain')?.value || '').trim();
    const temperature = (document.getElementById('survey-temperature')?.value || '').trim();

    const purpose = Array.from(form.querySelectorAll('input[name="purpose"]:checked')).map(i => i.value);
    const expectedPeriod = (document.getElementById('survey-expected-period')?.value || '').trim();

    const accessNotes = (document.getElementById('survey-access-notes')?.value || '').trim();
    const hazards = Array.from(form.querySelectorAll('input[name="hazards"]:checked')).map(i => i.value);

    const overallProductivity = (document.getElementById('survey-overall-productivity')?.value || '').trim();
    const wouldDetectAgain = (document.getElementById('survey-would-detect-again')?.value || '').trim();
    const surveyObservations = (document.getElementById('survey-observations')?.value || '').trim();

    const newSurvey = {
        id: generateId(),
        name: name,
        description: description,
        status: 'Open',
        creationDate: now,
        dateLastChanged: now,

        // -----------------------------
        // NEW: Survey Details (optional)
        // Sections 1–7 (all optional)
        // -----------------------------

        // 1) Permission & Legality
        permissionFrom: permissionFrom,
        permissionType: permissionType,           // Written | Verbal | Club/Rally | Open access
        permissionDateGranted: permissionDateGranted,    // YYYY-MM-DD
        permissionExpiry: permissionExpiry,         // YYYY-MM-DD
        permissionNotes: permissionNotes,

        // 2) Area / Site Type
        areaType: areaType,                 // Field (Pasture) | Field (Ploughed) | Beach (Dry) | Beach (Wet/Tidal) | Woods | Park | Moor/Heath | Riverbank/Foreshore | Other
        landUseCurrent: landUseCurrent,           // Agricultural | Recreational | Woodland | Coastal | Urban fringe

        // 3) Soil & Ground
        soilType: soilType,                 // Clay | Loam | Sand | Chalk | Peat | Mixed/Unknown
        groundCondition: groundCondition,          // Dry | Damp | Wet | Waterlogged | Frozen
        mineralisationLevel: mineralisationLevel,      // Low | Medium | High | Unknown

        // 4) Environment
        weather: weather,                  // Sunny | Overcast | Rain | Windy | Mixed
        recentRain: recentRain,               // None | Light | Heavy (24–48h)
        temperature: temperature,              // free text / optional (e.g., "8C")

        // 5) Intent & Context
        purpose: purpose,                  // multi-select (strings)
        expectedPeriod: expectedPeriod,           // Roman | Medieval | Post-Medieval | Modern | Unknown/Mixed

        // 6) Access & Practical Notes
        accessNotes: accessNotes,
        hazards: hazards,                  // multi-select (strings)

        // 7) Outcome Summary
        overallProductivity: overallProductivity,      // Poor | Fair | Good | Excellent
        wouldDetectAgain: wouldDetectAgain,         // Yes | No | Maybe
        surveyObservations: surveyObservations,

        targets: [],
        finds: [],
        tracks: [],

        // NEW: multi-photo truth
        photos: photoRefs,

        // Back-compat single fields (first photo)
        surveyPhotoRef: primaryRef,
        surveyPhotoData: photoRefs.length > 0 ? '' : primaryDataUrl
    };

    // 3. Add the new survey to the start of the list
    surveys.unshift(newSurvey);

    // 4. Save and re-render
    saveSurveysToLocalStorage();

    // Clear temp buffer so it doesn't leak into next survey
    window.currentNewSurveyPhotos = [];

    closeNewSurveyModal();
    showMessage(`New Survey '${name}' created and is now OPEN!`, 'success');
    render();
}

async function showEditSurveyModal() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('There is no open survey to edit.', 'warning');
        return;
    }

    const form = document.getElementById('edit-survey-form');
    if (!form) return;

    // Populate fields
    form['surveyId'].value = openSurvey.id;
    form['surveyName'].value = openSurvey.name || '';
    form['surveyDescription'].value = openSurvey.description || '';

    // Populate NEW optional survey metadata fields (Sections 1–7)
    const setVal = (id, v) => {
        const el = document.getElementById(id);
        if (el) el.value = (v ?? '');
    };

    setVal('edit-survey-permission-from', openSurvey.permissionFrom || '');
    setVal('edit-survey-permission-type', openSurvey.permissionType || '');
    setVal('edit-survey-permission-date-granted', formatSurveyPermissionDate(openSurvey.permissionDateGranted));
    setVal('edit-survey-permission-expiry', formatSurveyPermissionDate(openSurvey.permissionExpiry));
    setVal('edit-survey-permission-notes', openSurvey.permissionNotes || '');

    setVal('edit-survey-area-type', openSurvey.areaType || '');
    setVal('edit-survey-land-use-current', openSurvey.landUseCurrent || '');

    setVal('edit-survey-soil-type', openSurvey.soilType || '');
    setVal('edit-survey-ground-condition', openSurvey.groundCondition || '');
    setVal('edit-survey-mineralisation-level', openSurvey.mineralisationLevel || '');

    setVal('edit-survey-weather', openSurvey.weather || '');
    setVal('edit-survey-recent-rain', openSurvey.recentRain || '');
    setVal('edit-survey-temperature', openSurvey.temperature || '');

    setVal('edit-survey-expected-period', openSurvey.expectedPeriod || '');
    setVal('edit-survey-access-notes', openSurvey.accessNotes || '');
    setVal('edit-survey-overall-productivity', openSurvey.overallProductivity || '');
    setVal('edit-survey-would-detect-again', openSurvey.wouldDetectAgain || '');
    setVal('edit-survey-observations', openSurvey.surveyObservations || '');

    // Purpose multi-select (checkboxes)
    const purposes = Array.isArray(openSurvey.purpose) ? openSurvey.purpose : [];
    form.querySelectorAll('input[name="purpose"]').forEach(cb => {
        cb.checked = purposes.includes(cb.value);
    });

    // Hazards multi-select (checkboxes)
    const hazardsArr = Array.isArray(openSurvey.hazards) ? openSurvey.hazards : [];
    form.querySelectorAll('input[name="hazards"]').forEach(cb => {
        cb.checked = hazardsArr.includes(cb.value);
    });

    // --- IMPORTANT: keep refs alongside preview URLs ---
    window.currentEditSurveyPhotos = [];
    window.currentEditSurveyPhotoRefs = []; // aligned by index to currentEditSurveyPhotos

    try {
        // Preferred new structure: openSurvey.photos = ["idb:..", ...]
        if (Array.isArray(openSurvey.photos) && openSurvey.photos.length) {
            const first = openSurvey.photos[0];

            if (typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(first)) {
                // Load blob URLs for preview, keep refs in parallel
                if (typeof loadPhotoUrlsFromRefs === 'function') {
                    const urls = await loadPhotoUrlsFromRefs(openSurvey.photos);
                    window.currentEditSurveyPhotos = Array.isArray(urls) ? urls : [];
                    window.currentEditSurveyPhotoRefs = openSurvey.photos.slice(0, window.currentEditSurveyPhotos.length);
                } else {
                    // Fallback: resolve one-by-one
                    const urls = [];
                    const refs = [];
                    for (const ref of openSurvey.photos) {
                        try {
                            const u = await getPhotoUrlFromRef(ref);
                            if (u) {
                                urls.push(u);
                                refs.push(ref);
                            }
                        } catch (e) {}
                    }
                    window.currentEditSurveyPhotos = urls;
                    window.currentEditSurveyPhotoRefs = refs;
                }
            } else {
                // Legacy: data URLs stored directly in openSurvey.photos
                window.currentEditSurveyPhotos = openSurvey.photos.slice();
                window.currentEditSurveyPhotoRefs = new Array(window.currentEditSurveyPhotos.length).fill(null);
            }
        }
        // Back-compat: single survey photo ref/data
        else if (openSurvey.surveyPhotoRef && typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(openSurvey.surveyPhotoRef)) {
            const u = await getPhotoUrlFromRef(openSurvey.surveyPhotoRef);
            if (u) {
                window.currentEditSurveyPhotos = [u];
                window.currentEditSurveyPhotoRefs = [openSurvey.surveyPhotoRef];
            }
        } else if (openSurvey.surveyPhotoData) {
            window.currentEditSurveyPhotos = [openSurvey.surveyPhotoData];
            window.currentEditSurveyPhotoRefs = [null];
        }
    } catch (e) {
        console.error('Error preparing edit survey photos:', e);
        window.currentEditSurveyPhotos = [];
        window.currentEditSurveyPhotoRefs = [];
    }

    // Update UI using your existing preview renderer (must be multi-photo version)
    updateEditSurveyPhotoPreview();

    // Ensure chooser offers camera
    const input = document.getElementById('edit-survey-photo-input');
    if (input) {
        try { input.removeAttribute('capture'); } catch (e) {}
        input.setAttribute('accept', 'image/*;capture=camera');
        input.multiple = true;
    }

    attachFormSubmitHandler('edit-survey-form', handleEditSurveySubmit);
    openModal('edit-survey-modal');
}

        function closeEditSurveyModal() {
    closeModal('edit-survey-modal');
}
async function handleEditSurveySubmit(event) {
    event.preventDefault();
    const form = event.target;

    const id = form['surveyId'].value;
    const survey = surveys.find(s => s.id === id);

    if (!survey || survey.status !== 'Open') {
        showMessage('Only the open survey can be edited.', 'error');
        closeEditSurveyModal();
        return;
    }

    const name = form['surveyName'].value.trim();
    if (!name) {
        showMessage('Survey Name is required.', 'error');
        return;
    }

    const description = form['surveyDescription'].value.trim() || 'No description provided.';


    // NEW: optional survey metadata fields (Sections 1–7)
    const permissionFrom = (document.getElementById('edit-survey-permission-from')?.value || '').trim();
    const permissionType = (document.getElementById('edit-survey-permission-type')?.value || '').trim();
    let permissionDateGranted = (document.getElementById('edit-survey-permission-date-granted')?.value || '').trim();
    let permissionExpiry = (document.getElementById('edit-survey-permission-expiry')?.value || '').trim();

    // Normalize permission dates to DD/MM/YY for storage
    permissionDateGranted = formatSurveyPermissionDate(permissionDateGranted);
    permissionExpiry      = formatSurveyPermissionDate(permissionExpiry);
const permissionNotes = (document.getElementById('edit-survey-permission-notes')?.value || '').trim();

    const areaType = (document.getElementById('edit-survey-area-type')?.value || '').trim();
    const landUseCurrent = (document.getElementById('edit-survey-land-use-current')?.value || '').trim();

    const soilType = (document.getElementById('edit-survey-soil-type')?.value || '').trim();
    const groundCondition = (document.getElementById('edit-survey-ground-condition')?.value || '').trim();
    const mineralisationLevel = (document.getElementById('edit-survey-mineralisation-level')?.value || '').trim();

    const weather = (document.getElementById('edit-survey-weather')?.value || '').trim();
    const recentRain = (document.getElementById('edit-survey-recent-rain')?.value || '').trim();
    const temperature = (document.getElementById('edit-survey-temperature')?.value || '').trim();

    const purpose = Array.from(form.querySelectorAll('input[name="purpose"]:checked')).map(i => i.value);
    const expectedPeriod = (document.getElementById('edit-survey-expected-period')?.value || '').trim();

    const accessNotes = (document.getElementById('edit-survey-access-notes')?.value || '').trim();
    const hazards = Array.from(form.querySelectorAll('input[name="hazards"]:checked')).map(i => i.value);

    const overallProductivity = (document.getElementById('edit-survey-overall-productivity')?.value || '').trim();
    const wouldDetectAgain = (document.getElementById('edit-survey-would-detect-again')?.value || '').trim();
    const surveyObservations = (document.getElementById('edit-survey-observations')?.value || '').trim();
    // Make sure arrays exist
    const photos = Array.isArray(window.currentEditSurveyPhotos) ? window.currentEditSurveyPhotos : [];
    const refsByIndex = Array.isArray(window.currentEditSurveyPhotoRefs) ? window.currentEditSurveyPhotoRefs : [];

    // 1) Keep existing refs that are still present
    const keptRefs = [];
    for (let i = 0; i < photos.length; i++) {
        const ref = refsByIndex[i];
        if (ref && typeof ref === 'string') {
            keptRefs.push(ref);
        }
    }

    // 2) Save NEW photos (data URLs) to IndexedDB and append their refs
    const newDataUrls = [];
    for (let i = 0; i < photos.length; i++) {
        const ref = refsByIndex[i];
        const p = photos[i];
        if (!ref && typeof p === 'string' && p.startsWith('data:image/')) {
            newDataUrls.push(p);
        }
    }

    let newRefs = [];
    if (newDataUrls.length) {
        try {
            newRefs = await saveDataUrlsAsPhotoRefs(newDataUrls);
        } catch (e) {
            console.error('Error saving new survey photos to IndexedDB:', e);
            newRefs = [];
        }
    }

    const finalRefs = keptRefs.concat(newRefs);

    // Back-compat first photo
    const primaryRef = finalRefs[0] || '';
    // Only keep base64 if we have no refs at all (very unlikely now)
    const primaryDataUrlFallback = (primaryRef ? '' : (photos.find(p => typeof p === 'string' && p.startsWith('data:image/')) || ''));

    survey.name = name;
    survey.description = description;

    // NEW: optional survey metadata fields (Sections 1–7)
    survey.permissionFrom = permissionFrom;
    survey.permissionType = permissionType;
    survey.permissionDateGranted = permissionDateGranted;
    survey.permissionExpiry = permissionExpiry;
    survey.permissionNotes = permissionNotes;

    survey.areaType = areaType;
    survey.landUseCurrent = landUseCurrent;

    survey.soilType = soilType;
    survey.groundCondition = groundCondition;
    survey.mineralisationLevel = mineralisationLevel;

    survey.weather = weather;
    survey.recentRain = recentRain;
    survey.temperature = temperature;

    survey.purpose = Array.isArray(purpose) ? purpose : [];
    survey.expectedPeriod = expectedPeriod;

    survey.accessNotes = accessNotes;
    survey.hazards = Array.isArray(hazards) ? hazards : [];

    survey.overallProductivity = overallProductivity;
    survey.wouldDetectAgain = wouldDetectAgain;
    survey.surveyObservations = surveyObservations;

    // ✅ NEW truth
    survey.photos = finalRefs;

    // ✅ Back-compat single photo fields
    survey.surveyPhotoRef  = primaryRef;
    survey.surveyPhotoData = primaryRef ? '' : primaryDataUrlFallback;

    survey.dateLastChanged = Date.now();

    saveSurveysToLocalStorage();
    closeEditSurveyModal();

    // tidy
    window.currentEditSurveyPhotos = [];
    window.currentEditSurveyPhotoRefs = [];

    showMessage('Open survey updated.', 'success');
    render();
}
/** Shows the New Target Modal. */
function showNewTargetModal() {

    // LIMITS: block opening the modal if over limit / expired
    const r = canCreate('targets');
    if (!r.ok) {
        showMessage(r.reason, 'error');
        return;
    }

    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        return showMessage(
            'Cannot log target. Please open a survey first on the Home page.',
            'warning'
        );
    }

    // 1. Set survey name + id in the modal
    const headerSpan = document.getElementById('current-target-survey-name');
    if (headerSpan) {
        headerSpan.textContent = openSurvey.name;
    }
    const surveyIdHidden = document.getElementById('new-target-survey-id');
    if (surveyIdHidden) {
        surveyIdHidden.value = openSurvey.id;
    }

    // 2. Reset the form
    const form = document.getElementById('new-target-form');
    if (form) {
        form.reset();
    }

    // 3. Reset NEW TARGET photo state + UI (IMPORTANT!)
    currentNewTargetPhotos = [];

    const statusSpan  = document.getElementById('new-target-photo-status');
    const wrapper     = document.getElementById('new-target-photo-preview-wrapper');
    const hiddenField = document.getElementById('target-photo-data');
    const fileInput   = document.getElementById('new-target-photo-input');

    if (statusSpan) {
        statusSpan.textContent = 'No photo captured yet.';
    }
    if (wrapper) {
        wrapper.classList.add('hidden');
        wrapper.innerHTML = ''; // clear any old thumbnails
    }
    if (hiddenField) {
        // store an empty array, ready for JSON.parse
        hiddenField.value = '[]';
    }
    if (fileInput) {
        fileInput.value = ''; // clear any previous selection
    }

    // 4. Request GPS location
    startTargetLocationWatch();

    // 5. Attach the submit listener via shared helper
    attachFormSubmitHandler('new-target-form', handleNewTargetSubmit);

    // 6. Display modal via shared helper
    openModal('new-target-modal');
}

/** Closes the New Target Modal. */
function closeNewTargetModal() {
    stopTargetLocationWatch();
    closeModal('new-target-modal');
}

// NOTE: now async because we talk to IndexedDB
async function handleNewTargetSubmit(event) {
    event.preventDefault();
    const form = event.target;

    // Which survey are we saving to?
    const surveyId = form['targetSurveyId']?.value;
    const survey = surveys.find(s => s.id === surveyId);

    if (!survey) {
        showMessage('Error: Survey not found for this target.', 'error');
        return;
    }

        // LIMITS: block creating new targets if over limit / expired
    const r = canCreate('targets');
    if (!r.ok) {
        showMessage(r.reason, 'error');
        return;
    }


    const newDescription = form['targetDescription'].value.trim();
    const newVDI         = form['targetVDI'].value.trim() || 'N/A';
    const newDepth       = form['targetDepth'].value.trim() || 'Unknown';
    const newType        = form['targetType'].value;
    const newCoords      = form['targetCoords'].value.trim() || 'No GPS logged';
    const newAccuracy    = form['targetAccuracy'].value.trim() || 'N/A';

    if (!newDescription) {
        showMessage('Description / Find Name is required.', 'error');
        return;
    }

    // Centre on Map radios may or may not exist
    let centerOnMap = false;
    const centerField = form['targetCenterOnMap'];
    if (centerField) {
        const centerOnMapValue = centerField.value;
        centerOnMap = (centerOnMapValue === 'Yes');
    }

    // --- PHOTO HANDLING (Step 1: still uses data URLs in memory) ---

    // Hidden field currently stores JSON.stringify(currentNewTargetPhotos)
    let photosDataUrls = [];
    const rawPhotoField = form['targetPhotoData']?.value;

    if (rawPhotoField) {
        try {
            const parsed = JSON.parse(rawPhotoField);
            if (Array.isArray(parsed)) {
                photosDataUrls = parsed.filter(p => typeof p === 'string' && p.length > 0);
            } else if (typeof parsed === 'string' && parsed.length > 0) {
                photosDataUrls = [parsed];
            }
        } catch (e) {
            // Not valid JSON? Treat as single data URL
            if (typeof rawPhotoField === 'string' && rawPhotoField.length > 0) {
                photosDataUrls = [rawPhotoField];
            }
        }
    }

    // Save these data URLs into IndexedDB and get back lightweight references
    let photoRefs = [];
    try {
        photoRefs = await saveDataUrlsAsPhotoRefs(photosDataUrls);
    } catch (e) {
        console.error('Error saving photos to IndexedDB:', e);
        // We can still proceed, just without IDB refs.
        photoRefs = [];
    }

 const primaryDataUrl = photosDataUrls[0] || '';
const primaryRef     = photoRefs[0] || '';

const newTarget = {
    id: generateId(),
    description: newDescription,
    vdi: newVDI,
    depth: newDepth,
    type: newType,
    status: 'Not dug',
    time: Date.now(),
    coordinates: newCoords,
    accuracy: newAccuracy,
    user: userProfile.name,
    detector: userProfile.detector,
    centerOnMap,

    // Photos: use IndexedDB refs as the truth
    photos: photoRefs,
    targetPhotoRef: primaryRef,

    // IMPORTANT:
    // If we successfully saved to IndexedDB (photoRefs.length > 0),
    // DO NOT keep a base64 copy in localStorage.
    // Only keep base64 if IDB save failed.
    targetPhotoData: photoRefs.length > 0 ? '' : primaryDataUrl
};
  
    if (!Array.isArray(survey.targets)) {
        survey.targets = [];
    }
    survey.targets.unshift(newTarget);
    survey.dateLastChanged = Date.now();

    // Clear temp buffer so it doesn't leak into the next target
    currentNewTargetPhotos = [];

    saveSurveysToLocalStorage();
    closeNewTargetModal();

    // Make sure we land back on the Targets screen
    currentPage = 'Targets';
    showMessage(`New Target (${newDescription}) logged successfully!`, 'success');
    render();
}

        
// Now async, so it can talk to IndexedDB
async function openTargetPhotoGallery(targetId, surveyId) {
    const survey = surveys.find(s => s.id === surveyId);
    if (!survey) {
        showMessage('Survey not found for this target.', 'error');
        return;
    }

    const target = survey.targets.find(t => t.id === targetId);
    if (!target) {
        showMessage('Target not found.', 'error');
        return;
    }

    let photos = [];

    if (Array.isArray(target.photos) && target.photos.length) {
        const first = target.photos[0];

        // NEW: if these are IndexedDB refs ("idb:..."), load blobs and make real URLs
        if (isIndexedDbPhotoRef(first)) {
            try {
                photos = await loadPhotoUrlsFromRefs(target.photos);
            } catch (e) {
                console.error('Error loading target photos from IndexedDB:', e);
                photos = [];
            }
        } else {
            // Old style: already data URLs, just copy them
            photos = target.photos.slice();
        }
    } else if (target.targetPhotoData || target.photoDataUrl) {
        const basePhoto = target.targetPhotoData || target.photoDataUrl;
        if (basePhoto) {
            photos = [basePhoto];
        }
    }

    if (!photos.length) {
        showMessage('This target has no photos yet.', 'info');
        return;
    }

    openPhotoGallery(photos, 0);
}
// Also async, to be ready for IndexedDB-backed find photos
async function openFindPhotoGallery(findId) {
    const find = finds.find(f => f.id === findId);
    if (!find) {
        showMessage('Find not found.', 'error');
        return;
    }

    let photos = [];

    if (Array.isArray(find.photos) && find.photos.length) {
        const first = find.photos[0];

        if (isIndexedDbPhotoRef(first)) {
            try {
                photos = await loadPhotoUrlsFromRefs(find.photos);
            } catch (e) {
                console.error('Error loading find photos from IndexedDB:', e);
                photos = [];
            }
        } else {
            // Old style: direct data URLs
            photos = find.photos.slice();
        }
    } else if (find.targetPhotoData || find.photoData) {
        const basePhoto = find.targetPhotoData || find.photoData;
        if (basePhoto) {
            photos = [basePhoto];
        }
    }

    if (!photos.length) {
        showMessage('This find has no photos yet.', 'info');
        return;
    }

    openPhotoGallery(photos, 0);
}
function openPhotoGallery(photos, startIndex) {
    if (!Array.isArray(photos) || !photos.length) return;

    currentGalleryPhotos = photos.slice();
    currentGalleryIndex = Math.max(0, Math.min(startIndex || 0, currentGalleryPhotos.length - 1));

    const modal   = document.getElementById('photo-gallery-modal');
    const img     = document.getElementById('photo-gallery-image');
    const caption = document.getElementById('photo-gallery-caption');

    if (!modal || !img || !caption) return;

    // Ensure swipe handlers are attached
    ensureGallerySwipeHandlers();

    // Update the displayed image
    img.src = currentGalleryPhotos[currentGalleryIndex];
    caption.textContent = `${currentGalleryIndex + 1} of ${currentGalleryPhotos.length}`;

    openModal('photo-gallery-modal');
}

function showGalleryPhoto(delta) {
    if (!currentGalleryPhotos.length) return;
    if (typeof delta !== 'number' || delta === 0) return;

    const nextIndex = (currentGalleryIndex + delta + currentGalleryPhotos.length) % currentGalleryPhotos.length;
    currentGalleryIndex = nextIndex;

    const img     = document.getElementById('photo-gallery-image');
    const caption = document.getElementById('photo-gallery-caption');
    if (!img || !caption) return;

    img.src = currentGalleryPhotos[currentGalleryIndex];
    caption.textContent = `${currentGalleryIndex + 1} of ${currentGalleryPhotos.length}`;
}

function closePhotoGallery() {
    closeModal('photo-gallery-modal');
}

function ensureGallerySwipeHandlers() {
    if (gallerySwipeInitialized) return;

    const wrapper = document.getElementById('photo-gallery-image-wrapper');
    if (!wrapper) return;

    wrapper.addEventListener('touchstart', (e) => {
        if (!e.touches || !e.touches.length) return;
        galleryTouchStartX = e.touches[0].clientX;
    });

    wrapper.addEventListener('touchend', (e) => {
        if (galleryTouchStartX === null || !e.changedTouches || !e.changedTouches.length) return;
        const dx = e.changedTouches[0].clientX - galleryTouchStartX;
        galleryTouchStartX = null;

        if (Math.abs(dx) > 40) {
            // Swipe left => next, swipe right => previous
            showGalleryPhoto(dx < 0 ? 1 : -1);
        }
    });

    gallerySwipeInitialized = true;
}

// --- SHARED PHOTO HELPERS ---
// ======================================
// SHARED PHOTO-UI INITIALISER
// ======================================
function initPhotoUI(photoData, {
    statusId,
    wrapperId,
    imgId,
    hiddenId
}, messages = {}) {
    const statusSpan     = statusId   ? document.getElementById(statusId)   : null;
    const previewWrapper = wrapperId  ? document.getElementById(wrapperId)  : null;
    const previewImg     = imgId      ? document.getElementById(imgId)      : null;
    const hiddenField    = hiddenId   ? document.getElementById(hiddenId)   : null;

    const existingMessage = messages.existing || 'Existing photo loaded. Tap "Take / Choose Photo" to replace.';
    const emptyMessage    = messages.empty    || 'No photo captured yet.';

    // Valid Base64 data URLs are usually fairly long strings
    const hasValidPhoto = photoData && typeof photoData === 'string' && photoData.length > 50;

    if (hasValidPhoto) {
        if (hiddenField)    hiddenField.value = photoData;
        if (previewImg)     previewImg.src = photoData;
        if (previewWrapper) previewWrapper.classList.remove('hidden');
        if (statusSpan)     statusSpan.textContent = existingMessage;
    } else {
        if (hiddenField)    hiddenField.value = '';
        if (previewImg)     previewImg.src = '';
        if (previewWrapper) previewWrapper.classList.add('hidden');
        if (statusSpan)     statusSpan.textContent = emptyMessage;
    }
}

    // ======================================
// CARD THUMBNAIL INITIALISER (Targets & Finds)
// ======================================
async function initialiseCardThumbnails() {
    const thumbImgs = document.querySelectorAll('img[data-photo-ref]');
    if (!thumbImgs.length) return;

    thumbImgs.forEach(async (img) => {
        const ref = img.getAttribute('data-photo-ref');
        if (!ref) return;

        try {
            let url = '';

            // New style: an IndexedDB reference like "idb:123"
            if (typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(ref)) {
                if (typeof getPhotoUrlFromRef === 'function') {
                    url = await getPhotoUrlFromRef(ref);
                }
            } else {
                // Legacy: direct data URL or normal URL
                url = ref;
            }

            if (url) {
                img.src = url;
            } else {
                // If we couldn't resolve anything, hide the broken image
                const container = img.closest('.mt-3');
                if (container) {
                    container.classList.add('hidden');
                }
            }
        } catch (e) {
            console.error('Error resolving thumbnail for ref', ref, e);
        }
    });
}

/**
 * Generic helper to trigger a hidden file input by ID.
 * Clears any previous selection before opening.
 */
function triggerPhotoInput(inputId) {
    const fileInput = document.getElementById(inputId);
    if (!fileInput) return;

    fileInput.value = '';   // clear previous selection
    fileInput.click();      // open camera / gallery
}

async function handlePhotoSelected(event, {
    statusId,
    wrapperId,
    imgId,
    hiddenId
}) {
    const fileInput = event.target;
    const file = fileInput.files && fileInput.files[0];

    const statusSpan  = statusId  ? document.getElementById(statusId)  : null;
    const wrapper     = wrapperId ? document.getElementById(wrapperId) : null;
    const img         = imgId     ? document.getElementById(imgId)     : null;
    const hiddenField = hiddenId  ? document.getElementById(hiddenId)  : null;

    if (!file) return;

    try {
        if (statusSpan) statusSpan.textContent = 'Processing photo...';

        const resizedDataUrl = await fileToResizedDataUrl(file);

        if (hiddenField) hiddenField.value = resizedDataUrl || '';
        if (img) img.src = resizedDataUrl || '';
        if (wrapper) wrapper.classList.toggle('hidden', !resizedDataUrl);

        if (statusSpan) {
            const mw = getMaxPhotoWidth();
            statusSpan.textContent = resizedDataUrl
                ? (mw ? `Photo ready (max width ${mw}px).` : 'Photo ready (no resize).')
                : 'No photo captured yet.';
        }
    } catch (e) {
        console.error('Error processing photo:', e);
        if (statusSpan) statusSpan.textContent = 'Photo failed to load.';
        showMessage('Could not process that photo.', 'error');
    } finally {
        // allow selecting the same file again later
        try { fileInput.value = ''; } catch (e) {}
    }
}

// --- EDIT SURVEY PHOTO HELPERS (match Edit Target behaviour) ---

// ---------- EDIT SURVEY PHOTO HELPERS ----------

function triggerEditSurveyPhotoInput() {
    const input = document.getElementById('edit-survey-photo-input');
    if (!input) return;

    try { input.removeAttribute('capture'); } catch (e) {}
    input.setAttribute('accept', 'image/*;capture=camera');
    input.multiple = true;

    triggerPhotoInput('edit-survey-photo-input');
}

function updateEditSurveyPhotoPreview() {
    const statusSpan  = document.getElementById('edit-survey-photo-status');
    const wrapper     = document.getElementById('edit-survey-photo-preview-wrapper');
    const hiddenField = document.getElementById('edit-survey-photo-data');

    if (!statusSpan || !wrapper || !hiddenField) return;

    const photos = window.currentEditSurveyPhotos || [];

    // Store JSON array in hidden field
    hiddenField.value = JSON.stringify(photos);

    if (!photos.length) {
        statusSpan.textContent = 'No photo captured yet.';
        wrapper.classList.add('hidden');
        wrapper.innerHTML = '';
        return;
    }

    statusSpan.textContent = photos.length === 1
        ? '1 photo selected.'
        : `${photos.length} photos selected.`;

    const thumbsHtml = photos.map((src, index) => `
        <div class="relative mb-2 flex justify-center">
            <img
                src="${src}"
                alt="Survey photo ${index + 1}"
                class="w-11/12 max-h-64 object-cover rounded-lg border border-gray-300 cursor-pointer"
                onclick="openEditSurveyPhotoGallery(${index})"
            />
            <button
                type="button"
                class="absolute top-2 right-6 bg-black bg-opacity-60 text-white rounded-full w-7 h-7 flex items-center justify-center text-xs"
                onclick="event.stopPropagation(); removeEditSurveyPhoto(${index});"
                title="Delete photo"
            >
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
    `).join('');

    wrapper.innerHTML = `<div class="flex flex-col items-center w-full">${thumbsHtml}</div>`;
    wrapper.classList.remove('hidden');
}


async function handleEditSurveyPhotoSelected(event) {
    const files = Array.from(event.target.files || []);
    if (!files.length) return;

    // Allow selecting the same file again later
    event.target.value = '';

    try {
        for (const file of files) {
            const resized = await fileToResizedDataUrl(file);
            if (typeof resized === 'string' && resized.startsWith('data:image/')) {
                window.currentEditSurveyPhotos.push(resized);
            }
        }
    } catch (e) {
        console.error('Error reading/resizing survey photo file:', e);
        showMessage('One or more photos could not be processed.', 'error');
    }

    updateEditSurveyPhotoPreview();
}

        

function openEditSurveyPhotoGallery(startIndex) {
    const photos = window.currentEditSurveyPhotos || [];
    if (!photos.length) return;
    openPhotoGallery(photos, startIndex || 0);
}


function removeEditSurveyPhoto(index) {
    if (!Array.isArray(window.currentEditSurveyPhotos)) return;

    window.currentEditSurveyPhotos.splice(index, 1);

    // keep refs aligned with photos
    if (Array.isArray(window.currentEditSurveyPhotoRefs)) {
        window.currentEditSurveyPhotoRefs.splice(index, 1);
    }

    updateEditSurveyPhotoPreview();
}

async function handleEditSurveyPhotoSelected(event) {
    const files = Array.from(event.target.files || []);
    if (!files.length) return;

    // Allow selecting the same file again later
    event.target.value = '';

    // Ensure arrays exist
    window.currentEditSurveyPhotos = window.currentEditSurveyPhotos || [];
    window.currentEditSurveyPhotoRefs = window.currentEditSurveyPhotoRefs || [];

    try {
        for (const file of files) {
            const resized = await fileToResizedDataUrl(file);
            if (typeof resized === 'string' && resized.startsWith('data:image/')) {
                // New photos are data URLs and have no ref yet
                window.currentEditSurveyPhotos.push(resized);
                window.currentEditSurveyPhotoRefs.push(null);
            }
        }
    } catch (e) {
        console.error('Error reading/resizing survey photo file:', e);
        showMessage('One or more photos could not be processed.', 'error');
    }

    updateEditSurveyPhotoPreview();
}

// --- NEW: MULTI-PHOTO SUPPORT FOR NEW TARGET MODAL ---

function updateNewTargetPhotoPreview() {
    const statusSpan  = document.getElementById('new-target-photo-status');
    const wrapper     = document.getElementById('new-target-photo-preview-wrapper');
    const hiddenField = document.getElementById('target-photo-data');

    if (!statusSpan || !wrapper || !hiddenField) return;

    const photos = currentNewTargetPhotos || [];

    // Store as JSON in the hidden field
    hiddenField.value = JSON.stringify(photos);

    if (!photos.length) {
        statusSpan.textContent = 'No photo captured yet.';
        wrapper.classList.add('hidden');
        wrapper.innerHTML = '';
        return;
    }

    statusSpan.textContent = photos.length === 1
        ? '1 photo selected.'
        : `${photos.length} photos selected.`;

    const thumbsHtml = photos.map((src, index) => `
        <div class="relative mb-2 flex justify-center">
            <img
                src="${src}"
                alt="Target photo ${index + 1}"
                class="w-11/12 max-h-64 object-cover rounded-lg border border-gray-300 cursor-pointer"
                onclick="openNewTargetPhotoGallery(${index})"
            />
            <button
                type="button"
                class="absolute top-2 right-6 bg-black bg-opacity-60 text-white rounded-full w-7 h-7 flex items-center justify-center text-xs"
                onclick="event.stopPropagation(); removeNewTargetPhoto(${index});"
            >
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
    `).join('');

    wrapper.innerHTML = `
        <div class="flex flex-col items-center w-full">
            ${thumbsHtml}
        </div>
    `;
    wrapper.classList.remove('hidden');
}

async function handleNewTargetPhotoSelected(event) {
    const files = Array.from(event.target.files || []);
    if (!files.length) return;

    // Allow selecting the same file again later
    event.target.value = '';

    try {
        for (const file of files) {
            const resized = await fileToResizedDataUrl(file);
            if (typeof resized === 'string' && resized.startsWith('data:image/')) {
                currentNewTargetPhotos.push(resized);
            }
        }
    } catch (e) {
        console.error('Error reading/resizing target photo file:', e);
        showMessage('One or more photos could not be processed.', 'error');
    }

    updateNewTargetPhotoPreview();
}

function removeNewTargetPhoto(index) {
    if (!Array.isArray(currentNewTargetPhotos)) return;
    currentNewTargetPhotos.splice(index, 1);
    updateNewTargetPhotoPreview();
}

// --- CREATE TARGET PHOTO HELPERS (match Edit Target behaviour) ---

function triggerNewTargetPhotoInput() {
    const fileInput = document.getElementById('new-target-photo-input');
    if (!fileInput) return;

    // Remove any forced camera-only behaviour
    fileInput.removeAttribute('capture');

    // Let the browser offer camera OR file picker (same idea as Edit Target)
    fileInput.setAttribute('accept', 'image/*;capture=camera');

    // IMPORTANT: your handler supports multiple photos + resizing
    fileInput.multiple = true;

    triggerPhotoInput('new-target-photo-input');
}

        function openNewTargetPhotoGallery(startIndex) {
    if (!currentNewTargetPhotos.length) return;
    openPhotoGallery(currentNewTargetPhotos, startIndex || 0);
}

// --- NEW: MULTI-PHOTO SUPPORT FOR EDIT TARGET MODAL ---

function updateEditTargetPhotoPreview() {
    const statusSpan  = document.getElementById('edit-target-photo-status');
    const wrapper     = document.getElementById('edit-target-photo-preview-wrapper');
    const hiddenField = document.getElementById('edit-target-photo-data');

    if (!statusSpan || !wrapper || !hiddenField) return;

    const photos = currentEditTargetPhotos || [];
    hiddenField.value = JSON.stringify(photos);

    if (!photos.length) {
        statusSpan.textContent = 'No photo captured yet.';
        wrapper.classList.add('hidden');
        wrapper.innerHTML = '';
        return;
    }

    statusSpan.textContent = photos.length === 1
        ? '1 photo selected.'
        : `${photos.length} photos selected.`;

    const thumbsHtml = photos.map((src, index) => `
        <div class="relative mb-2 flex justify-center">
            <img
                src="${src}"
                alt="Target photo ${index + 1}"
                class="w-11/12 max-h-64 object-cover rounded-lg border border-gray-300 cursor-pointer"
                onclick="openEditTargetPhotoGallery(${index})"
            />
            <button
                type="button"
                class="absolute top-2 right-6 bg-black bg-opacity-60 text-white rounded-full w-7 h-7 flex items-center justify-center text-xs"
                onclick="event.stopPropagation(); removeEditTargetPhoto(${index});"
            >
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
    `).join('');

    wrapper.innerHTML = `
        <div class="flex flex-col items-center w-full">
            ${thumbsHtml}
        </div>
    `;
    wrapper.classList.remove('hidden');
}

async function handleEditTargetPhotoSelected(event) {
    const files = Array.from(event.target.files || []);
    if (!files.length) return;

    // Allow selecting the same file again later
    event.target.value = '';

    try {
        for (const file of files) {
            const resized = await fileToResizedDataUrl(file); // uses Max Photo Width setting
            if (typeof resized === 'string' && resized.startsWith('data:image/')) {
                currentEditTargetPhotos.push(resized);
            }
        }
    } catch (e) {
        console.error('Error reading/resizing target photo file:', e);
        showMessage('One or more photos could not be processed.', 'error');
    }

    // Refresh the thumbnails/gallery in the Edit Target modal
    if (typeof updateEditTargetPhotoPreview === 'function') {
        updateEditTargetPhotoPreview();
    }
}

function removeEditTargetPhoto(index) {
    if (!Array.isArray(currentEditTargetPhotos)) return;
    currentEditTargetPhotos.splice(index, 1);
    updateEditTargetPhotoPreview();
}

// Called from button in the Edit Target form
function triggerEditTargetPhotoInput() {
    triggerPhotoInput('edit-target-photo-input');
}

function openEditTargetPhotoGallery(startIndex) {
    if (!currentEditTargetPhotos.length) return;
    openPhotoGallery(currentEditTargetPhotos, startIndex || 0);
}

// --- EDIT FIND PHOTO HELPERS ---

function triggerEditFindPhotoInput() {
    triggerPhotoInput('edit-find-photo-input');
}

function removeEditFindPhoto(index) {
    if (!Array.isArray(currentEditFindPhotos)) return;
    currentEditFindPhotos.splice(index, 1);
    updateEditFindPhotoPreview();
}

function openEditFindPhotoGallery(startIndex) {
    if (!currentEditFindPhotos.length) return;
    openPhotoGallery(currentEditFindPhotos, startIndex || 0);
}

        
// === MULTI-PHOTO SUPPORT FOR EDIT FIND MODAL ===

function updateEditFindPhotoPreview() {
    const statusSpan  = document.getElementById('edit-find-photo-status');
    const wrapper     = document.getElementById('edit-find-photo-preview-wrapper');
    const hiddenField = document.getElementById('edit-find-photo-data');

    if (!statusSpan || !wrapper || !hiddenField) return;

    const photos = currentEditFindPhotos || [];

    // Store the array as JSON in the hidden field
    hiddenField.value = JSON.stringify(photos);

    if (!photos.length) {
        statusSpan.textContent = 'No photo captured yet.';
        wrapper.classList.add('hidden');
        wrapper.innerHTML = '';
        return;
    }

    statusSpan.textContent = photos.length === 1
        ? '1 photo selected.'
        : `${photos.length} photos selected.`;

    const thumbsHtml = photos.map((src, index) => `
        <div class="relative mb-2 flex justify-center">
            <img
                src="${src}"
                alt="Find photo ${index + 1}"
                class="w-11/12 max-h-64 object-cover rounded-lg border border-gray-300 cursor-pointer"
                onclick="openEditFindPhotoGallery(${index})"
            />
            <button
                type="button"
                class="absolute top-2 right-6 bg-black bg-opacity-60 text-white rounded-full w-7 h-7 flex items-center justify-center text-xs"
                onclick="event.stopPropagation(); removeEditFindPhoto(${index});"
                title="Delete photo"
            >
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
    `).join('');

    wrapper.innerHTML = `
        <div class="flex flex-col items-center w-full">
            ${thumbsHtml}
        </div>
    `;
    wrapper.classList.remove('hidden');
}

        // --- NEW SURVEY PHOTO HELPERS ---
// ================================
// SURVEY MULTI-PHOTO SUPPORT
// (mirrors Targets/Finds approach)
// ================================

// Ensure globals exist (avoid redeclare errors)
window.currentNewSurveyPhotos  = window.currentNewSurveyPhotos  || []; // array of data URLs (in-memory)
window.currentEditSurveyPhotos = window.currentEditSurveyPhotos || []; // array of URLs (blob: or data:) for preview/edit


// ---------- NEW SURVEY PHOTO HELPERS ----------

function triggerNewSurveyPhotoInput() {
    const input = document.getElementById('new-survey-photo-input');
    if (!input) return;

    // Make it behave like Edit Target: camera OR chooser
    // (capture attribute can force camera-only on some devices, so remove it)
    try { input.removeAttribute('capture'); } catch (e) {}

    // This is the key bit that enables camera choice on many devices
    input.setAttribute('accept', 'image/*;capture=camera');

    // Surveys now allow multiple photos
    input.multiple = true;

    triggerPhotoInput('new-survey-photo-input');
}

    
function removeNewSurveyPhoto(index) {
    if (!Array.isArray(window.currentNewSurveyPhotos)) return;
    window.currentNewSurveyPhotos.splice(index, 1);
    updateNewSurveyPhotoPreview();
}


function openNewSurveyPhotoGallery(startIndex) {
    const photos = window.currentNewSurveyPhotos || [];
    if (!photos.length) return;
    openPhotoGallery(photos, startIndex || 0);
}

function updateNewSurveyPhotoPreview() {
    const statusSpan  = document.getElementById('new-survey-photo-status');
    const wrapper     = document.getElementById('new-survey-photo-preview-wrapper');
    const hiddenField = document.getElementById('new-survey-photo-data');

    if (!statusSpan || !wrapper || !hiddenField) return;

    const photos = window.currentNewSurveyPhotos || [];

    // Store JSON array in hidden field (like targets/finds)
    hiddenField.value = JSON.stringify(photos);

    if (!photos.length) {
        statusSpan.textContent = 'No photo captured yet.';
        wrapper.classList.add('hidden');
        wrapper.innerHTML = '';
        return;
    }

    statusSpan.textContent = photos.length === 1
        ? '1 photo selected.'
        : `${photos.length} photos selected.`;

    const thumbsHtml = photos.map((src, index) => `
        <div class="relative mb-2 flex justify-center">
            <img
                src="${src}"
                alt="Survey photo ${index + 1}"
                class="w-11/12 max-h-64 object-cover rounded-lg border border-gray-300 cursor-pointer"
                onclick="openNewSurveyPhotoGallery(${index})"
            />
            <button
                type="button"
                class="absolute top-2 right-6 bg-black bg-opacity-60 text-white rounded-full w-7 h-7 flex items-center justify-center text-xs"
                onclick="event.stopPropagation(); removeNewSurveyPhoto(${index});"
                title="Delete photo"
            >
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
    `).join('');

    wrapper.innerHTML = `<div class="flex flex-col items-center w-full">${thumbsHtml}</div>`;
    wrapper.classList.remove('hidden');
}



async function handleNewSurveyPhotoSelected(event) {
    const files = Array.from(event.target.files || []);
    if (!files.length) return;

    // Allow selecting the same file again later
    event.target.value = '';

    try {
        for (const file of files) {
            const resized = await fileToResizedDataUrl(file);
            if (typeof resized === 'string' && resized.startsWith('data:image/')) {
                window.currentNewSurveyPhotos.push(resized);
            }
        }
    } catch (e) {
        console.error('Error reading/resizing survey photo file:', e);
        showMessage('One or more photos could not be processed.', 'error');
    }

    updateNewSurveyPhotoPreview();
}

async function handleEditFindPhotoSelected(event) {
    const files = Array.from(event.target.files || []);
    if (!files.length) return;

    // Allow selecting the same file again later
    event.target.value = '';

    try {
        for (const file of files) {
            const resized = await fileToResizedDataUrl(file);
            if (typeof resized === 'string' && resized.startsWith('data:image/')) {
                currentEditFindPhotos.push(resized);
            }
        }
    } catch (e) {
        console.error('Error reading/resizing find photo file:', e);
        showMessage('One or more photos could not be processed.', 'error');
    }

    updateEditFindPhotoPreview();
}
        
async function showEditTargetModal(targetId, surveyId) {
    const survey = surveys.find(s => s.id === surveyId);
    if (!survey) {
        showMessage('Error: Survey not found.', 'error');
        return;
    }

    const target = survey.targets.find(t => t.id === targetId);
    if (!target) {
        showMessage('Error: Target not found.', 'error');
        return;
    }

    // 1. Populate the form fields
    document.getElementById('edit-target-id').value = target.id;
    document.getElementById('edit-survey-id').value = survey.id;
    document.getElementById('current-edit-survey-name').textContent = survey.name;

    document.getElementById('edit-target-description').value =
        typeof target.description === 'string' ? target.description : '';

    document.getElementById('edit-target-vdi').value =
        target.vdi === 'N/A' || target.vdi == null ? '' : String(target.vdi);

    document.getElementById('edit-target-depth').value =
        target.depth === 'Unknown' || target.depth == null ? '' : String(target.depth);

    document.getElementById('edit-target-type').value = target.type || 'Coin';

    document.getElementById('edit-target-coords').value =
        target.coordinates === 'No GPS logged' || !target.coordinates
            ? ''
            : String(target.coordinates);

    // Accuracy
    document.getElementById('edit-target-accuracy').value =
        target.accuracy === 'N/A' || target.accuracy == null ? '' : String(target.accuracy);

    // Centre on map radios
    const shouldCenterOnMap = target.centerOnMap === true;
    const yesRadio = document.getElementById('edit-target-center-yes');
    const noRadio  = document.getElementById('edit-target-center-no');

    if (yesRadio && noRadio) {
        yesRadio.checked = shouldCenterOnMap;
        noRadio.checked  = !shouldCenterOnMap;
    }

    // 2. Photos: convert stored data into displayable thumbnails
    try {
        if (Array.isArray(target.photos) && target.photos.length > 0) {
            const first = target.photos[0];

            if (isIndexedDbPhotoRef(first)) {
                // NEW: load from IndexedDB, get object URLs
                currentEditTargetPhotos = await loadPhotoUrlsFromRefs(target.photos);
            } else {
                // Old style: already data URLs
                currentEditTargetPhotos = target.photos.slice();
            }
        } else if (target.targetPhotoData) {
            currentEditTargetPhotos = [target.targetPhotoData];
        } else if (target.photoDataUrl) {
            currentEditTargetPhotos = [target.photoDataUrl];
        } else {
            currentEditTargetPhotos = [];
        }
    } catch (e) {
        console.error('Error preparing edit target photos:', e);
        currentEditTargetPhotos = [];
    }

    updateEditTargetPhotoPreview();

    // 3. Attach the submit listener (via your shared helper)
    attachFormSubmitHandler('edit-target-form', handleEditTargetSubmit);

    // 4. Show the modal
    openModal('edit-target-modal');
}
        
function closeEditTargetModal() {
    closeModal('edit-target-modal');
}
        /** Handles the submission of the Edit Target form. */
/** Handles the submission of the Edit Target form. */
/** Handles the submission of the Edit Target form. */
async function handleEditTargetSubmit(event) {
    event.preventDefault();

    // Always grab the real form element by ID (more robust on mobile)
    const form = document.getElementById('edit-target-form');
    if (!form) {
        showMessage('Error: Edit Target form not found.', 'error');
        console.error('Edit Target form not found in DOM.');
        return;
    }

    // Read IDs directly from the hidden inputs
    const targetIdInput = document.getElementById('edit-target-id');
    const surveyIdInput = document.getElementById('edit-survey-id');

    const targetId = targetIdInput?.value;
    const surveyId = surveyIdInput?.value;

    if (!targetId || !surveyId) {
        console.error('Missing targetId or surveyId in edit form.', {
            targetId,
            surveyId,
            targetIdInput,
            surveyIdInput
        });
        showMessage('Error: Target or Survey not found (missing IDs in form).', 'error');
        return;
    }

    const newDescription = form['targetDescription'].value.trim();
    if (!newDescription) {
        showMessage('Description / Find Name is required.', 'error');
        return;
    }

    const newVDI      = form['targetVDI'].value.trim() || 'N/A';
    const newDepth    = form['targetDepth'].value.trim() || 'Unknown';
    const newType     = form['targetType'].value;
    const newCoords   = form['targetCoords'].value.trim() || 'No GPS logged';
    const newAccuracy = form['targetAccuracy'].value.trim() || 'N/A';

    // --- Photos: parse JSON array (or single string) from hidden field ---
    let photosDataUrls = [];
    const rawPhotoField = form['targetPhotoData']?.value;

    if (rawPhotoField) {
        try {
            const parsed = JSON.parse(rawPhotoField);
            if (Array.isArray(parsed)) {
                photosDataUrls = parsed.filter(p => typeof p === 'string' && p.length > 0);
            } else if (typeof parsed === 'string' && parsed.length > 0) {
                photosDataUrls = [parsed];
            }
        } catch (e) {
            // Not valid JSON? Treat it as a single URL (data: or blob:)
            if (typeof rawPhotoField === 'string' && rawPhotoField.length > 0) {
                photosDataUrls = [rawPhotoField];
            }
        }
    }

    // Save these URLs into IndexedDB and get back lightweight references
    let photoRefs = [];
    try {
        photoRefs = await saveDataUrlsAsPhotoRefs(photosDataUrls);
    } catch (e) {
        console.error('Error saving edited target photos to IndexedDB:', e);
        // We can still proceed, but with no IDB refs
        photoRefs = [];
    }

    const primaryDataUrl = photosDataUrls[0] || '';
    const primaryRef     = photoRefs[0] || '';

    // Look up survey + target
    const survey = surveys.find(s => s.id === surveyId);
    if (!survey) {
        showMessage('Error: Survey not found.', 'error');
        return;
    }

    const target = survey.targets.find(t => t.id === targetId);
    if (!target) {
        showMessage('Error: Target not found.', 'error');
        return;
    }

    // Update core fields
    target.description = newDescription;
    target.vdi         = newVDI;
    target.depth       = newDepth;
    target.type        = newType;
    target.coordinates = newCoords;
    target.accuracy    = newAccuracy;

    // Update photos (new IndexedDB-backed structure)
    target.photos          = photoRefs;
    target.targetPhotoRef  = primaryRef;
    target.targetPhotoData = photoRefs.length > 0 ? '' : primaryDataUrl;

    // Centre-on-map handling (only one per survey)
    const yesRadio = document.getElementById('edit-target-center-yes');
    const noRadio  = document.getElementById('edit-target-center-no');

    if (yesRadio && noRadio) {
        const centerOnMap = !!yesRadio.checked;

        if (centerOnMap) {
            // Ensure only this target is centred in this survey
            survey.targets.forEach(t => {
                if (t.id !== targetId) {
                    t.centerOnMap = false;
                }
            });
        }

        target.centerOnMap = centerOnMap;
    }
    // If radios are missing, we leave target.centerOnMap unchanged

    survey.dateLastChanged = Date.now();
    saveSurveysToLocalStorage();
    closeEditTargetModal();
    showMessage(`Target ${target.description} updated successfully.`, 'success');
    render();
}

        /** Shows the Edit Profile Modal and loads current data. */
        function showEditProfileModal() {
            const modal = document.getElementById('edit-profile-modal');
            // Pre-fill the form with current profile data
            document.getElementById('profile-name').value = userProfile.name;
            document.getElementById('profile-detector').value = userProfile.detector;
            document.getElementById('profile-ncmd-number').value = userProfile.ncmdNumber || '';

            modal.style.display = 'block';

            // Attach the submit listener
            const form = document.getElementById('edit-profile-form');
            form.removeEventListener('submit', handleEditProfileSubmit); 
            form.addEventListener('submit', handleEditProfileSubmit); 
            showMessage("Edit Profile modal opened. Please enter your name and detector and click 'Save Changes'.", 'info');
        }

        /** Closes the Edit Profile Modal. */
        function closeEditProfileModal() {
            document.getElementById('edit-profile-modal').style.display = 'none';
        }

        /** Handles the submission of the Edit Profile form. */
function handleEditProfileSubmit(event) {
    event.preventDefault();

    const form = event.target;

    // Capture old values BEFORE changing anything (used only for updating target.user)
    const oldName = userProfile.name;

    // All fields are OPTIONAL
    const newName = (form['profileName']?.value || '').trim();
    const newDetector = (form['profileDetector']?.value || '').trim();
    const newNcmdNumber = (form['profileNcmdNumber']?.value || '').trim();

    // Update global state (allow blanks)
    userProfile.name = newName;
    userProfile.detector = newDetector;
    userProfile.ncmdNumber = newNcmdNumber;

    // Update ONLY the user name in existing targets (do NOT update detector)
    // Only do this if the old name was non-empty and it actually changed.
    if (oldName && newName && newName !== oldName) {
        surveys.forEach(survey => {
            survey.targets.forEach(target => {
                if (target.user === oldName) {
                    target.user = newName;
                }
            });
        });
    }

    // Save and re-render
    saveSurveysToLocalStorage();
    closeEditProfileModal();
    showMessage(`Profile updated successfully!`, 'success');
    render();
}


// --- SURVEY & TARGET LOGIC (Action Handlers) ---


// ============================================================
// SURVEY CARD BUTTON FIX / STANDARDIZATION HELPERS
// Survey cards may call openSurvey(id)/closeSurvey(id)/editSurvey(id).
// These wrappers delegate into handleSurveyAction() so behaviour is consistent.
// ============================================================

async function openSurvey(id) {
    const survey = (Array.isArray(surveys) ? surveys : []).find(s => String(s.id) === String(id));
    if (!survey) return;

    return await handleSurveyAction({
        dataset: { id: String(survey.id), action: 'open', name: survey.name || '' }
    });
}

async function closeSurvey(id) {
    const survey = (Array.isArray(surveys) ? surveys : []).find(s => String(s.id) === String(id));
    if (!survey) return;

    return await handleSurveyAction({
        dataset: { id: String(survey.id), action: 'close', name: survey.name || '' }
    });
}

async function editSurvey(id) {
    await openSurvey(id);
    setTimeout(() => {
        if (typeof showEditSurveyModal === 'function') showEditSurveyModal();
    }, 50);
}

async function handleSurveyAction(button) {
    const id = button.dataset.id;
    const action = button.dataset.action;
    const name = button.dataset.name;

    const survey = surveys.find(s => s.id === id);
    if (!survey) return;

    const executeAction = async () => {
        const now = Date.now();

        switch (action) {
            case 'open':
                // ✅ Opening a survey must start "clean"
                resetLiveTrackingAndRecordingState();

                // Close any currently open survey
                surveys.forEach(s => {
                    if (s.status === 'Open') {
                        s.status = 'Active';
                        s.dateLastChanged = now;
                    }
                });

                // Open the selected survey
                survey.status = 'Open';
                survey.dateLastChanged = now;

                saveSurveysToLocalStorage();
                showMessage(`Survey '${name}' is now OPEN.`, 'success');
                render();
                break;

            case 'close':
                survey.status = 'Active';
                survey.dateLastChanged = now;
                saveSurveysToLocalStorage();
                showMessage(`Survey '${name}' is now CLOSED (Active).`, 'info');
                render();
                break;

            case 'archive':
                survey.status = 'Archived';
                survey.dateLastChanged = now;
                saveSurveysToLocalStorage();
                showMessage(`Survey '${name}' has been Archived.`, 'info');
                render();
                break;

            case 'restore':
                survey.status = 'Active';
                survey.dateLastChanged = now;
                saveSurveysToLocalStorage();
                showMessage(`Survey '${name}' Restored to Active.`, 'success');
                render();
                break;

            case 'delete': {
                // NEW: cascading delete (survey + targets + finds + IndexedDB photos)
                const ok = await deleteSurveyAndAllAssociatedData(id);
                if (ok) {
                    showMessage(`Survey '${name}' deleted (including targets, finds, and photos).`, 'success');
                } else {
                    showMessage(`Could not delete survey '${name}'.`, 'error');
                }
                render();
                break;
            }
case 'edit': {
    // Ensure the survey is opened first (edit operates on the currently open survey)
    await handleSurveyAction({
        dataset: { id: String(id), action: 'open', name: name || '' }
    });
    setTimeout(() => {
        if (typeof showEditSurveyModal === 'function') showEditSurveyModal();
    }, 50);
    return;
}



            default:
                console.warn("Unknown survey action:", action);
        }
    };

    // Confirm dangerous actions
    if (action === 'delete') {
        showConfirmationModal(
            `Delete: ${name}`,
            `Are you sure you want to delete this survey?<br>
             <span class="text-sm text-gray-600">This will also delete its targets, its finds, and any IndexedDB photos linked to it. This cannot be undone.</span>`,
            executeAction
        );
    } else if (action === 'archive') {
        showConfirmationModal(
            `Archive: ${name}`,
            `Are you sure you want to Archive this survey?`,
            executeAction
        );
    } else {
        await executeAction();
    }
}
    
    function handleMapTargetClick(event, targetId) {
    // Don’t let this click bubble up to the map container,
    // so it does NOT trigger toggleMapFullscreen().
    event.stopPropagation();

    if (!targetId) {
        console.warn('Map target click without a valid targetId');
        return;
    }

    // Save the selected target ID for navigation
    navigationTargetId = targetId;
    console.log('Navigation target selected from map:', navigationTargetId);

    // Start a fresh navigation session (breadcrumbs)
    if (!navSession) {
        navSession = {};
    }
    navSession.active = true;
    navSession.path = [];
    navSession.startLat = null;
    navSession.startLon = null;
    navSession.lastLat = null;
    navSession.lastLon = null;
    navSession.smoothedViewRadiusM = null;


    // IMPORTANT: do NOT try to set startLat/startLon here.
    // If GPS isn't ready yet, we initialise startLat/startLon later in renderNavigationPanel()
    // when effectiveUser becomes available.

    showMessage('Navigation target selected on map.', 'info');

    // If we're on the Compass page, re-render it so the panel updates
    if (currentPage === 'Compass') {
        const appContent = document.getElementById('app-content');
        if (appContent) {
            appContent.innerHTML = renderCompassPage(true);
            attachPageEventListeners();
        }
    }
}
// ------------------------------------------------------
// Target QR helpers
// ------------------------------------------------------

/**
 * Build a compact JSON string representing a single target
 * plus minimal survey + profile info.
 */
function buildTargetQrPayload(target, survey) {
    const payload = {
        kind: 'geoFind-target',
        version: 1,

        surveyId: survey.id,
        surveyName: survey.name || '',
        surveyDescription: survey.description || '',

        targetId: target.id,
        description: target.description || '',
        type: target.type || '',
        vdi: target.vdi || '',
        depth: target.depth || '',
        coordinates: target.coordinates || '',
        accuracy: target.accuracy || '',
        status: target.status || '',
        createdAt: target.createdAt || target.timestamp || null,

        user: (userProfile && userProfile.name) ? userProfile.name : '',
        detector: (userProfile && userProfile.detector) ? userProfile.detector : ''
    };

    // Keep it compact for QR efficiency
    return JSON.stringify(payload);
}

/**
 * Given a target + survey, populate and show the QR modal.
 */
function showTargetQrModalFor(target, survey) {
    const modal        = document.getElementById('target-qr-modal');
    const titleEl      = document.getElementById('target-qr-title');
    const codeContainer = document.getElementById('target-qr-code-container');
    const textArea     = document.getElementById('target-qr-raw-text');

    if (!modal || !titleEl || !codeContainer) {
        console.error('Target QR modal elements not found.');
        showMessage('QR modal not found in page.', 'error');
        return;
    }

    const qrText = buildTargetQrPayload(target, survey);

    // Title
    titleEl.textContent = `Target QR: ${target.description || 'Unnamed target'}`;

    // Raw JSON text (for debugging / copy-paste)
    if (textArea) {
        textArea.value = qrText;
    }

    // Clear any previous QR code
    codeContainer.innerHTML = '';

    // Use the QRCode library if available
    if (typeof QRCode === 'function') {
        try {
            new QRCode(codeContainer, {
                text: qrText,
                width: 256,
                height: 256,
                correctLevel: QRCode.CorrectLevel.M
            });
        } catch (e) {
            console.error('Error creating QR code:', e);
            codeContainer.innerHTML =
                '<p class="text-xs text-red-600">Could not generate QR code.</p>';
        }
    } else {
        // Fallback if library not loaded
        codeContainer.innerHTML =
            '<p class="text-xs text-red-600">QR library not loaded. The raw text below can be copied manually.</p>';
    }

    openModal('target-qr-modal');
}

function closeTargetQrModal() {
    closeModal('target-qr-modal');
}
// ------------------------------------------------------
// Target QR SCAN helpers (import into OPEN survey)
// ------------------------------------------------------

let qrScanStream = null;
let qrScanAnimationFrameId = null;
let qrScanActive = false;

/**
 * Open the scan modal and start the camera.
 * Imports into the currently OPEN survey only.
 */
function openTargetQrScanModal() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('Please open a survey first before importing a target via QR.', 'warning');
        return;
    }

    const statusEl = document.getElementById('target-qr-scan-status');
    if (statusEl) {
        statusEl.textContent = 'Initialising camera…';
    }

    openModal('target-qr-scan-modal');
    startTargetQrScan();
}

/** Close the scan modal and stop the camera. */
function closeTargetQrScanModal() {
    stopTargetQrScan();
    closeModal('target-qr-scan-modal');
}

/** Start camera and begin scanning frames for a QR code. */
async function startTargetQrScan() {
    const video   = document.getElementById('target-qr-scan-video');
    const canvas  = document.getElementById('target-qr-scan-canvas');
    const statusEl = document.getElementById('target-qr-scan-status');

    if (!video || !canvas) {
        console.error('QR scan elements not found.');
        if (statusEl) statusEl.textContent = 'QR scan not available on this page.';
        return;
    }

    // Stop any previous scan, just in case
    stopTargetQrScan();

    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        if (statusEl) {
            statusEl.textContent = 'Camera is not available in this browser.';
        }
        return;
    }

    try {
        const constraints = {
            video: {
                facingMode: 'environment'   // Prefer rear camera on phones
            }
        };

        qrScanActive = true;
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        qrScanStream = stream;

        video.srcObject = stream;

        if (statusEl) {
            statusEl.textContent = 'Point your camera at a GeoFind Target QR code…';
        }

        const ctx = canvas.getContext('2d');

        const tick = () => {
            if (!qrScanActive) return;

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                const width  = video.videoWidth;
                const height = video.videoHeight;

                if (width && height) {
                    canvas.width  = width;
                    canvas.height = height;
                    ctx.drawImage(video, 0, 0, width, height);
                    const imageData = ctx.getImageData(0, 0, width, height);

                    if (typeof jsQR === 'function') {
                        const qrResult = jsQR(
                            imageData.data,
                            width,
                            height,
                            { inversionAttempts: 'dontInvert' }
                        );

                        if (qrResult && qrResult.data) {
                            // We found a QR code – handle it
                            handleTargetQrScanned(qrResult.data);
                            return; // Stop scanning
                        }
                    }
                }
            }

            // Keep scanning
            qrScanAnimationFrameId = requestAnimationFrame(tick);
        };

        qrScanAnimationFrameId = requestAnimationFrame(tick);
    } catch (err) {
        console.error('Error starting QR scan:', err);
        if (statusEl) {
            statusEl.textContent = 'Could not access camera: ' + (err.message || 'unknown error');
        }
    }
}

/** Stop any active QR scan and release the camera. */
function stopTargetQrScan() {
    qrScanActive = false;

    if (qrScanAnimationFrameId != null) {
        cancelAnimationFrame(qrScanAnimationFrameId);
        qrScanAnimationFrameId = null;
    }

    if (qrScanStream) {
        qrScanStream.getTracks().forEach(track => track.stop());
        qrScanStream = null;
    }
}

/**
 * Called when a QR code has been successfully decoded.
 * Parses payload and imports as a NEW target into the OPEN survey.
 */
function handleTargetQrScanned(text) {
    qrScanActive = false;
    stopTargetQrScan();
    closeTargetQrScanModal();

    let payload;
    try {
        payload = JSON.parse(text);
    } catch (e) {
        console.error('Scanned QR is not valid JSON:', e);
        showMessage('Scanned QR is not a valid GeoFind target.', 'error');
        return;
    }

    if (!payload || payload.kind !== 'geoFind-target') {
        showMessage('The QR code is not a GeoFind Target QR.', 'error');
        return;
    }

    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('No open survey found to import into.', 'error');
        return;
    }

    const description = payload.description || 'Imported target';

    const confirmTitle = 'Import Target from QR';
    const confirmMessage = `
        Import this target into the currently open survey?<br><br>
        <strong>${description}</strong><br>
        <span class="text-sm text-gray-600">
            Survey: ${openSurvey.name || 'Untitled survey'}
        </span>
    `;

    const doImport = () => {

        // LIMITS: block QR target import if over limit / expired
const r = canCreate('targets');
if (!r.ok) {
    showMessage(r.reason, 'error');
    return;
}

        const now = Date.now();

        const newTarget = {
            id: generateId(),

            description: payload.description || 'Imported target',
            vdi: payload.vdi || 'N/A',
            depth: payload.depth || 'Unknown',
            type: payload.type || 'Unidentified',

            status: payload.status || 'Hole Dug',
            time: now,

            coordinates: payload.coordinates || 'No GPS logged',
            accuracy: payload.accuracy || 'N/A',

            user: payload.user || userProfile.name || '',
            detector: payload.detector || userProfile.detector || '',

            centerOnMap: false,

            // No photos via QR – you can add them later
            photos: [],
            targetPhotoRef: '',
            targetPhotoData: ''
        };

        if (!Array.isArray(openSurvey.targets)) {
            openSurvey.targets = [];
        }
        openSurvey.targets.unshift(newTarget);
        openSurvey.dateLastChanged = now;

        saveSurveysToLocalStorage();

        showMessage(`Imported target "${newTarget.description}" into open survey.`, 'success');
        render();   // Re-render current page (likely Settings)
    };

    // Use your existing generic confirmation modal
    showConfirmationModal(confirmTitle, confirmMessage, doImport);
}


function handleTargetAction(element) {
    let action = element.dataset.action || '';
    const targetId = element.dataset.id || '';
    let surveyId = element.dataset.surveyId || element.dataset.surveyID || '';

    // --- Normalise alternative action names (keeps old markup working) ---
    if (action === 'edit-target') action = 'edit';
    if (action === 'copyToFinds') action = 'saveFind';
    if (action === 'show-qr') action = 'showQr';

    // Find survey: prefer explicit surveyId, otherwise fall back to OPEN survey
    let survey = null;
    if (surveyId) {
        survey = surveys.find(s => s.id === surveyId) || null;
    }
    if (!survey) {
        survey = surveys.find(s => s.status === 'Open') || null;
        if (survey) surveyId = survey.id;
    }
    if (!survey) return;

    const target = (survey.targets || []).find(t => t.id === targetId);
    if (!target) return;

    // Special case: open the edit modal
    if (action === 'edit') {
        showEditTargetModal(targetId, surveyId);
        return;
    }

    const executeAction = () => {
        switch (action) {
            case 'setStatus': {
                const newStatus = element.dataset.status || element.dataset.value || '';
                if (!newStatus) {
                    console.warn('setStatus clicked but no data-status or data-value on button', element);
                    return;
                }
                target.status = newStatus;
                showMessage(`Target status updated to: ${newStatus}`, 'success');
                break;
            }

            case 'saveFind': {
                // 1) Create the Find snapshot
                target.isFind = true;
                const created = createFindFromTarget(target, survey);

                // If creation was blocked (limits/expiry), do NOT delete the target
                if (!created) return;

                // 2) Now delete the original target (user request)
                // IMPORTANT: we do NOT delete IndexedDB photos here because the Find references them.
                const maybePromise = deleteTargetPermanently(surveyId, targetId);

                // Support both sync + async implementations of deleteTargetPermanently
                if (maybePromise && typeof maybePromise.then === 'function') {
                    maybePromise.then((ok) => {
                        if (ok && navigationTargetId === targetId) navigationTargetId = null;
                        showMessage('Copied to Finds and removed from Targets.', 'success');
                        render();
                    }).catch((e) => {
                        console.error('Error deleting target after saving find:', e);
                        showMessage('Find saved, but failed to remove the target.', 'warning');
                        render();
                    });
                    return; // we’ll finish in the promise handlers
                } else {
                    const ok = !!maybePromise;
                    if (ok && navigationTargetId === targetId) navigationTargetId = null;
                    showMessage('Copied to Finds and removed from Targets.', 'success');
                }

                break;
            }

            case 'navigate': {
                navigationTargetId = targetId;
                showMessage(`Navigation target set: "${target.description}".`, 'success');
                currentPage = 'Compass';
                break;
            }

            case 'centerOnMap': {
                (survey.targets || []).forEach(t => {
                    t.centerOnMap = (t.id === targetId);
                });
                currentPage = 'Compass';
                showMessage('Centre on map updated for this target.', 'success');
                break;
            }

            case 'showQr': {
                showTargetQrModalFor(target, survey);
                break;
            }

            case 'delete': {
                // ✅ HARD DELETE (no deleted flag)
                const maybePromise = deleteTargetPermanently(surveyId, targetId);

                if (maybePromise && typeof maybePromise.then === 'function') {
                    maybePromise.then((ok) => {
                        if (ok && navigationTargetId === targetId) navigationTargetId = null;
                        render();
                    });
                    return; // IMPORTANT: stop further processing
                } else {
                    const ok = !!maybePromise;
                    if (ok && navigationTargetId === targetId) navigationTargetId = null;
                    render(); // target is gone; re-render immediately
                    return;   // IMPORTANT: stop further processing
                }
            }

            default:
                console.warn('Unknown target action:', action);
                return;
        }

        survey.dateLastChanged = Date.now();
        saveSurveysToLocalStorage();
        render();
    };

    // Confirm significant actions
    if (action === 'delete') {
        showConfirmationModal(
            `Confirm Delete Target: ${target.description}`,
            `Are you sure you want to permanently delete this target?`,
            executeAction
        );
    } else if (action === 'saveFind') {
        showConfirmationModal(
            'Copy to Finds',
            `Copy <strong>${target.description}</strong> to your Finds library?<br>
             <span class="text-sm text-gray-600">
               The original target will then be <strong>removed from Targets</strong>.
             </span>`,
            executeAction
        );
    } else {
        executeAction();
    }
}

function renderHomePage() {
    const totals = getAppTotals();

    const openSurvey = surveys.find(s => s.status === 'Open');
    const activeSurveys = surveys.filter(s => s.status === 'Active');
    const archivedSurveys = surveys.filter(s => s.status === 'Archived');

    // --- NEW: compute Tracks + Photos totals safely (without changing getAppTotals) ---
    const allSurveys = Array.isArray(surveys) ? surveys : [];

    const totalTracks = allSurveys.reduce((sum, s) => {
        const arr = Array.isArray(s?.tracks) ? s.tracks : [];
        // count only truthy + not-deleted (in case older builds used a deleted flag)
        return sum + arr.filter(tr => tr && tr.deleted !== true).length;
    }, 0);

    const totalPhotos = (() => {
        let n = 0;

        // Survey photos + Target photos (includes stakes too)
        for (const s of allSurveys) {
            // Survey photos (multi-photo aware)
            if (Array.isArray(s?.photos) && s.photos.length) {
                n += s.photos.filter(p => !!p).length;
            } else if (s?.surveyPhotoRef) {
                n += 1;
            } else if (s?.surveyPhotoData) {
                n += 1; // legacy
            }

            // Target photos (targets + stakes are both in survey.targets)
            const targetsArr = Array.isArray(s?.targets) ? s.targets : [];
            for (const t of targetsArr) {
                if (!t || t.deleted) continue;

                if (Array.isArray(t.photos) && t.photos.length) {
                    n += t.photos.length;
                } else if (t.targetPhotoRef || t.targetPhotoData || t.photoDataUrl) {
                    n += 1;
                }
            }
        }

        // Finds photos (global finds library)
        const findsArr = Array.isArray(finds) ? finds : [];
        for (const f of findsArr) {
            if (!f || f.deleted) continue;

            if (Array.isArray(f.photos) && f.photos.length) {
                n += f.photos.length;
            } else if (f.findPhotoRef || f.targetPhotoData || f.photoData) {
                n += 1;
            }
        }

        return n;
    })();

    const renderSurveyList = (list) => {
        if (list.length === 0) {
            return `<p class="text-gray-500 italic p-4">No surveys in this section.</p>`;
        }
        // Pass the openSurvey ID to highlight the currently open survey card in the list
        return list
            .map(s => renderSurveyCard(s, s.id === (openSurvey ? openSurvey.id : null)))
            .join('');
    };

    return `
<div class="p-4">

    <!-- App hero image -->
    <div class="mb-6 flex justify-center">
        <div class="home-hero">
            <img src="assets/dig-it-hero.png" alt="Detekta metal detecting">
        </div>
    </div>

    <h2 class="text-3xl font-bold text-primary mb-6">Survey Dashboard</h2>

    <!-- Totals -->
    <div class="bg-white p-4 rounded-xl shadow-lg mb-6 border-l-4 border-indigo-500">
        <h3 class="text-lg font-bold text-indigo-700 mb-3">Totals (All Surveys)</h3>

        <!-- NEW layout: 2 rows x 3 columns -->
        <div class="grid grid-cols-3 gap-3">
            <!-- Row 1: Surveys / Targets / Finds -->
            <div class="p-3 rounded-lg bg-gray-50 border border-gray-200 text-center">
                <div class="text-xs uppercase tracking-wide text-gray-500">Surveys</div>
                <div class="text-2xl font-bold text-gray-800">${totals.totalSurveys}</div>
            </div>

            <div class="p-3 rounded-lg bg-gray-50 border border-gray-200 text-center">
                <div class="text-xs uppercase tracking-wide text-gray-500">Targets</div>
                <div class="text-2xl font-bold text-gray-800">${totals.totalTargets}</div>
            </div>

            <div class="p-3 rounded-lg bg-gray-50 border border-gray-200 text-center">
                <div class="text-xs uppercase tracking-wide text-gray-500">Finds</div>
                <div class="text-2xl font-bold text-gray-800">${totals.totalFinds}</div>
            </div>

            <!-- Row 2: Tracks / Stakes / Photos -->
            <div class="p-3 rounded-lg bg-gray-50 border border-gray-200 text-center">
                <div class="text-xs uppercase tracking-wide text-gray-500">Tracks</div>
                <div class="text-2xl font-bold text-gray-800">${totalTracks}</div>
            </div>

            <div class="p-3 rounded-lg bg-gray-50 border border-gray-200 text-center">
                <div class="text-xs uppercase tracking-wide text-gray-500">Stakes</div>
                <div class="text-2xl font-bold text-gray-800">${totals.totalStakes}</div>
            </div>

            <div class="p-3 rounded-lg bg-gray-50 border border-gray-200 text-center">
                <div class="text-xs uppercase tracking-wide text-gray-500">Photos</div>
                <div class="text-2xl font-bold text-gray-800">${totalPhotos}</div>
            </div>

            <!-- Row 3: Storage (browser-managed) -->
            <div class="p-3 rounded-lg bg-gray-50 border border-gray-200 text-center">
                <div class="text-xs uppercase tracking-wide text-gray-500">Storage Used</div>
                <div id="home-storage-used" class="text-2xl font-bold text-gray-800">—</div>
            </div>

            <div class="p-3 rounded-lg bg-gray-50 border border-gray-200 text-center">
                <div class="text-xs uppercase tracking-wide text-gray-500">Storage Free</div>
                <div id="home-storage-free" class="text-2xl font-bold text-gray-800">—</div>
            </div>

            <!-- Spacer to keep the 3-column grid aligned -->
            <div class="p-3 rounded-lg bg-transparent border border-transparent text-center"></div>
        </div>
    </div>

    <!-- Open Survey (rendered like any other card, just highlighted) -->
    ${openSurvey
        ? `
        <div class="mb-6">
            ${renderSurveyCard(openSurvey, true)}
        </div>
        `
        : `
        <div class="bg-white p-4 rounded-xl shadow-lg mb-6 border-l-4 border-yellow-500">
            <p class="text-gray-600">
                You must open or create a survey to log new targets.
            </p>
        </div>
        `
    }

    <!-- Create Survey -->
    <button id="new-survey-btn"
        class="w-full text-center text-white font-bold py-3 px-4 rounded-lg shadow-md hover:opacity-90 transition duration-150 mb-6"
        style="background-color: rgb(var(--color-secondary));">
        <i class="fas fa-plus-circle mr-2"></i> Create New Survey
    </button>

    <!-- Active / Closed Surveys -->
    <h3 class="text-2xl font-bold text-gray-700 mb-3">
        Active / Closed Surveys (${activeSurveys.length})
    </h3>

    <div id="active-surveys-list" class="space-y-4 mb-8">
        ${renderSurveyList(activeSurveys)}
    </div>

  
</div>
`;
}

function renderSurveyCard(survey, isOpen = false) {
    let actions = '';
    let statusBadge = '';
    const secondaryColor = 'rgb(var(--color-secondary))';

    // Local, safe UK date formatter: DD/MM/YY (avoids locale flipping + "Invalid Date")
    const formatDateDMY = (timestamp) => {
        if (timestamp === null || timestamp === undefined || timestamp === '') return '';
        const d = new Date(timestamp);
        if (Number.isNaN(d.getTime())) return '';
        const dd = String(d.getDate()).padStart(2, '0');
        const mm = String(d.getMonth() + 1).padStart(2, '0');
        const yy = String(d.getFullYear()).slice(-2);
        return `${dd}/${mm}/${yy}`;
    };

    // --- Survey extra details summary (optional fields, shown only when populated) ---
    const details = [];
    const addDetail = (label, value) => {
        if (value === undefined || value === null) return;
        if (Array.isArray(value)) {
            const joined = value
                .map(v => String(v ?? '').trim())
                .filter(v => v)
                .join(', ');
            if (!joined) return;
            details.push({ label, value: joined });
            return;
        }
        const s = String(value).trim();
        if (!s) return;
        details.push({ label, value: s });
    };

    // Section 1: Permission & Legality
    addDetail('Permission from', survey.permissionFrom);
    addDetail('Permission type', survey.permissionType);
    addDetail('Permission granted', survey.permissionDateGranted);
    addDetail('Permission expiry', survey.permissionExpiry);
    addDetail('Permission notes', survey.permissionNotes);

    // Section 2: Area / Site Type
    addDetail('Area type', survey.areaType);
    addDetail('Land use', survey.landUseCurrent);

    // Section 3: Soil & Ground
    addDetail('Soil type', survey.soilType);
    addDetail('Ground condition', survey.groundCondition);
    addDetail('Mineralisation', survey.mineralisationLevel);

    // Section 4: Environment
    addDetail('Weather', survey.weather);
    addDetail('Recent rain', survey.recentRain);
    addDetail('Temperature', survey.temperature);

    // Section 5: Intent & Context
    addDetail('Purpose', survey.purpose);
    addDetail('Expected period', survey.expectedPeriod);

    // Section 6: Access & Practical
    addDetail('Access notes', survey.accessNotes);
    addDetail('Hazards', survey.hazards);

    // Section 7: Outcome Summary
    addDetail('Productivity', survey.overallProductivity);
    addDetail('Would detect again', survey.wouldDetectAgain);
    addDetail('Observations', survey.surveyObservations);

    const detailsHtml = details.length
        ? `
            <div class="mt-3 bg-gray-50 border border-gray-200 rounded-lg p-3">
                <h5 class="text-sm font-bold text-gray-700 mb-2">Survey details</h5>
                <div class="space-y-1">
                    ${details.map(d => `
                        <div class="text-sm">
                            <span class="text-gray-500 font-semibold">${d.label}:</span>
                            <span class="text-gray-800"> ${d.value}</span>
                        </div>
                    `).join('')}
                </div>
            </div>
          `
        : '';

    // Status badge
    if (survey.status === 'Open') {
        statusBadge = `<span class="inline-block mr-2 px-2 py-1 rounded-lg text-xs font-bold bg-yellow-100 text-yellow-800">OPEN</span>`;
    } else if (survey.status === 'Active') {
        statusBadge = `<span class="inline-block mr-2 px-2 py-1 rounded-lg text-xs font-bold" style="background:${secondaryColor}; color:white;">ACTIVE</span>`;
    } else if (survey.status === 'Archived') {
        statusBadge = `<span class="inline-block mr-2 px-2 py-1 rounded-lg text-xs font-bold bg-gray-200 text-gray-700">ARCHIVED</span>`;
    } else if (survey.status === 'Closed') {
        statusBadge = `<span class="inline-block mr-2 px-2 py-1 rounded-lg text-xs font-bold bg-red-100 text-red-800">CLOSED</span>`;
    }

    // Actions
    switch (survey.status) {
        case 'Open':
            actions = `
                <div class="flex gap-2 mt-4">
                    <button
                        class="flex-1 bg-blue-600 text-white font-bold py-2 rounded-lg shadow hover:bg-blue-700 transition"
                        onclick="handleSurveyAction(this)" data-action="edit" data-id="${survey.id}" data-name="${survey.name || ''}"
                    >
                        <i class="fas fa-edit mr-1"></i> Edit
                    </button>
                    <button
                        class="flex-1 bg-red-600 text-white font-bold py-2 rounded-lg shadow hover:bg-red-700 transition"
                        onclick="handleSurveyAction(this)" data-action="close" data-id="${survey.id}" data-name="${survey.name || ''}"
                    >
                        <i class="fas fa-times-circle mr-1"></i> Close
                    </button>
                </div>
            `;
            break;

        case 'Active':
            actions = `
                <div class="flex gap-2 mt-4">
                    <button
                        class="flex-1 bg-emerald-600 text-white font-bold py-2 rounded-lg shadow hover:bg-emerald-700 transition"
                        onclick="handleSurveyAction(this)"
                        data-id="${survey.id}"
                        data-action="open"
                        data-name="${survey.name || ''}"
                    >
                        <i class="fas fa-folder-open mr-1"></i> Open
                    </button>
</div>
                <div class="flex gap-2 mt-2">
                    <button
                        class="flex-1 bg-blue-600 text-white font-bold py-2 rounded-lg shadow hover:bg-blue-700 transition"
                        onclick="handleSurveyAction(this)" data-action="edit" data-id="${survey.id}" data-name="${survey.name || ''}"
                    >
                        <i class="fas fa-edit mr-1"></i> Edit
                    </button>
                    <button
                        class="flex-1 bg-red-600 text-white font-bold py-2 rounded-lg shadow hover:bg-red-700 transition"
                        onclick="handleSurveyAction(this)"
                        data-id="${survey.id}"
                        data-action="delete"
                        data-name="${survey.name}"
                    >
                        <i class="fas fa-trash mr-1"></i> Delete
                    </button>
                </div>
            `;
            break;

        case 'Archived':
        case 'Closed':
            actions = `
                <div class="flex gap-2 mt-4">
                    <button
                        class="flex-1 bg-blue-600 text-white font-bold py-2 rounded-lg shadow hover:bg-blue-700 transition"
                        onclick="handleSurveyAction(this)" data-action="edit" data-id="${survey.id}" data-name="${survey.name || ''}"
                    >
                        <i class="fas fa-edit mr-1"></i> Edit
                    </button>
                    <button
                        class="flex-1 bg-red-600 text-white font-bold py-2 rounded-lg shadow hover:bg-red-700 transition"
                        onclick="handleSurveyAction(this)"
                        data-id="${survey.id}"
                        data-action="delete"
                        data-name="${survey.name}"
                    >
                        <i class="fas fa-trash mr-1"></i> Delete
                    </button>
               </div>
            `;
            break;
    }

    // --- Survey thumbnail + photo count (same pattern as Finds/Targets) ---
    let thumbRef = '';
    let photosCount = 0;

    if (Array.isArray(survey.photos) && survey.photos.length) {
        thumbRef = survey.photos[0];
        photosCount = survey.photos.length;
    } else if (survey.surveyPhotoRef) {
        thumbRef = survey.surveyPhotoRef;
        photosCount = 1;
    } else if (survey.surveyPhotoData) {
        thumbRef = survey.surveyPhotoData;
        photosCount = 1;
    }

    const photoHtml = thumbRef
        ? `
            <div class="mt-3">
                <div class="flex justify-center">
                    <img
                        src=""
                        data-photo-ref="${thumbRef}"
                        data-photo-kind="survey"
                        data-survey-id="${survey.id}"
                        alt="Survey photo"
                        class="w-11/12 object-contain rounded-lg border border-gray-200 cursor-pointer"
                        onclick="openSurveyPhotoGallery('${survey.id}')"
                    />
                </div>
                ${
                    photosCount > 1
                        ? `<p class="mt-1 text-xs text-gray-600 text-center">
                               ${photosCount} photos — tap to view gallery.
                           </p>`
                        : ''
                }
            </div>
          `
        : '';

    const createdStr = formatDateDMY(survey.creationDate);
    const changedStr = formatDateDMY(survey.dateLastChanged);

    // Counts (safe)
    const allPins = Array.isArray(survey.targets) ? survey.targets.filter(t => t && !t.deleted) : [];
    const isStake = (t) => !!(t && (t.type === 'Stake' || (typeof isStakeTarget === 'function' && isStakeTarget(t))));
    const stakesCount  = allPins.filter(isStake).length;
    const targetsCount = allPins.filter(t => !isStake(t)).length;
    const findsCount   = Array.isArray(finds) ? finds.filter(f => f && f.surveyId === survey.id).length : 0;

    return `
        <div class="bg-white p-4 rounded-xl shadow-lg border-l-4 ${isOpen ? 'border-yellow-500' : 'border-primary'}">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-xl font-bold text-primary">${survey.name || 'Unnamed Survey'}</h3>
                <div class="text-right">
                    ${statusBadge}
                </div>
            </div>

            <p class="text-sm text-gray-700">${survey.description || ''}</p>

            ${photoHtml}

            ${detailsHtml}

            <div class="mt-3 overflow-x-auto">
                <table class="w-full text-sm">
                    <tbody>
                        <tr>
                            <td class="p-2 text-gray-500 font-semibold">Created</td>
                            <td class="p-2 font-bold">${createdStr}</td>
                        </tr>
                        <tr>
                            <td class="p-2 text-gray-500 font-semibold">Targets</td>
                            <td class="p-2 font-bold">${targetsCount}</td>
                        </tr>
                        <tr>
                            <td class="p-2 text-gray-500 font-semibold">Stakes</td>
                            <td class="p-2 font-bold">${stakesCount}</td>
                        </tr>
                        <tr>
                            <td class="p-2 text-gray-500 font-semibold">Finds</td>
                            <td class="p-2 font-bold">${findsCount}</td>
                        </tr>
                        <tr>
                            <td class="p-2 text-gray-500 font-semibold">Last change</td>
                            <td class="p-2 font-bold">${changedStr}</td>
                        </tr>
                    </tbody>
                </table>
            </div>

            ${actions}
        </div>
    `;
}
        /** Renders the content for the Targets page. */
        function renderTargetsPage() {
            const openSurvey = surveys.find(s => s.status === 'Open');

            if (!openSurvey) {
                return `
                    <div class="p-4">
                        <h2 class="text-3xl font-bold text-primary mb-6">Survey Targets</h2>
                        <div class="bg-white p-6 rounded-xl shadow-lg border-l-4 border-red-500">
                            <h3 class="text-xl font-bold text-red-600 mb-3">No Open Survey</h3>
                            <p class="text-gray-700">Please open a survey on the **Home** page to view or log targets.</p>
                        </div>
                    </div>
                `;
            }

let targets = openSurvey.targets.filter(t => !t.deleted);

if (targetSortMode === 'id') {
    targets.sort((a, b) => {
        const av = Number(a.vdi ?? -Infinity);
        const bv = Number(b.vdi ?? -Infinity);
        return bv - av; // highest VDI first
    });
} else {
    // Sort by most recent first
    targets.sort((a, b) => (b.dateCreated || 0) - (a.dateCreated || 0));
}


            return `
                <div class="p-4">
                    <h2 class="text-3xl font-bold text-primary mb-6">Targets: ${openSurvey.name}</h2>
                    
                    <button id="add-target-btn" class="w-full text-center text-white font-bold py-3 px-4 rounded-lg shadow-md hover:opacity-90 transition duration-150 mb-6" style="background-color: rgb(var(--color-secondary));">
                        <i class="fas fa-crosshairs mr-2"></i> Log New Target
                    </button>

<!-- Sort buttons -->
<div class="mt-3 flex gap-3">
    <button
        id="sort-target-id-btn"
        class="flex-1 px-3 py-2 rounded-md bg-gray-200 text-gray-800 font-semibold hover:bg-gray-300"
    >
        Sort by Target ID
    </button>

    <button
        id="sort-target-date-btn"
        class="flex-1 px-3 py-2 rounded-md bg-gray-200 text-gray-800 font-semibold hover:bg-gray-300"
    >
        Sort by Date
    </button>
</div>

        
                    <h3 class="text-2xl font-bold text-gray-700 mb-3">Target Log (${targets.length})</h3>
                    <div id="targets-list" class="space-y-4">
                        ${targets.length === 0 ? 
                            '<p class="text-gray-500 italic p-4 bg-white rounded-xl shadow-lg">No targets logged in this survey yet.</p>' : 
                            targets.map(t => renderTargetCard(t, openSurvey.id)).join('')}
                    </div>
                </div>
            `;
        }

function renderFindsPage() {
    const hasFinds = Array.isArray(finds) && finds.length > 0;

    // Build distinct Type options
    const typeSet = new Set();
    finds.forEach(f => {
        if (f.type) typeSet.add(f.type);
    });
    const typeOptions = Array.from(typeSet).sort();

    // Build distinct Survey options (by ID)
    const surveyMap = new Map();
    finds.forEach(f => {
        const id   = f.surveyId   || 'unknown';
        const name = f.surveyName || 'Unknown survey';
        if (!surveyMap.has(id)) {
            surveyMap.set(id, name);
        }
    });
    const surveyOptions = Array.from(surveyMap.entries())
        .map(([id, name]) => ({ id, name }))
        .sort((a, b) => a.name.localeCompare(b.name));

    // Build distinct Logged Date options (based on find.dateCreated/time/createdAt/dateLastChanged)
    const dateMap = new Map(); // key: YYYY-MM-DD, value: DD/MM/YY
    const getFindTimestamp = (f) => {
        const t = f?.dateCreated ?? f?.createdAt ?? f?.time ?? f?.dateLastChanged ?? 0;
        return (typeof t === 'number' && isFinite(t) && t > 0) ? t : 0;
    };
    const toDateKeyLocal = (ts) => {
        if (!ts) return '';
        const d = new Date(ts);
        if (!isFinite(d)) return '';
        const y = d.getFullYear();
        const m = String(d.getMonth() + 1).padStart(2, '0');
        const day = String(d.getDate()).padStart(2, '0');
        return `${y}-${m}-${day}`;
    };
    const toDateLabelGb = (ts) => {
        if (!ts) return '';
        try {
            return new Date(ts).toLocaleDateString('en-GB', { day: '2-digit', month: '2-digit', year: '2-digit' });
        } catch {
            return '';
        }
    };

    finds.forEach(f => {
        const ts = getFindTimestamp(f);
        const key = toDateKeyLocal(ts);
        if (!key) return;
        if (!dateMap.has(key)) {
            const label = toDateLabelGb(ts) || key;
            dateMap.set(key, label);
        }
    });

    const dateOptions = Array.from(dateMap.entries())
        .map(([key, label]) => ({ key, label }))
        .sort((a, b) => (a.key < b.key ? 1 : -1)); // newest first

    // Apply filters
    const filteredFinds = finds.filter(f => {
        // Text search (in several fields)
        if (findsFilter.query) {
            const q = findsFilter.query.toLowerCase();
            const haystack = [
                f.description,
                f.vdi,
                f.depth,
                f.type,
                f.surveyName,
                f.surveyDescription
            ]
                .filter(Boolean)
                .join(' ')
                .toLowerCase();

            if (!haystack.includes(q)) return false;
        }

        // Type filter
        if (findsFilter.type !== 'All') {
            const t = f.type || 'Unknown';
            if (t !== findsFilter.type) return false;
        }

        // Survey filter
        if (findsFilter.surveyId !== 'All') {
            const id = f.surveyId || 'unknown';
            if (id !== findsFilter.surveyId) return false;
        }


        // Date filter (Logged date)
        if (findsFilter.date && findsFilter.date !== 'All') {
            const ts = (f?.dateCreated ?? f?.createdAt ?? f?.time ?? f?.dateLastChanged ?? 0);
            const key = (typeof ts === 'number' && isFinite(ts) && ts > 0)
                ? (() => { const d = new Date(ts); const y=d.getFullYear(); const m=String(d.getMonth()+1).padStart(2,'0'); const day=String(d.getDate()).padStart(2,'0'); return `${y}-${m}-${day}`; })()
                : '';
            if (!key || key !== findsFilter.date) return false;
        }
        return true;
    });

    const totalCount    = finds.length;
    const filteredCount = filteredFinds.length;

    const cardsHtml = filteredFinds.map(find => {
        const tsRaw = (find.dateCreated ?? find.createdAt ?? find.time ?? find.dateLastChanged ?? null);
        let ts = null;
        if (typeof tsRaw === 'number') {
            ts = tsRaw;
        } else if (typeof tsRaw === 'string' && tsRaw.trim()) {
            const parsed = Date.parse(tsRaw);
            if (!Number.isNaN(parsed)) ts = parsed;
        }

        const dateText = ts
            ? new Date(ts).toLocaleString('en-GB', {
                day: '2-digit',
                month: '2-digit',
                year: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
              })
            : 'Not recorded';
        const typeLabel = find.type || 'Unknown';

        // --- Thumbnail + photo count (IndexedDB-aware, like Targets) ---
        let thumbRef    = '';
        let photosCount = 0;

        if (Array.isArray(find.photos) && find.photos.length) {
            // New style: array of refs or data URLs
            thumbRef    = find.photos[0];
            photosCount = find.photos.length;
        } else if (find.targetPhotoData || find.photoData) {
            // Legacy / fallback
            thumbRef    = find.targetPhotoData || find.photoData;
            photosCount = thumbRef ? 1 : 0;
        }

        const photoHtml = thumbRef
            ? `
                <div class="mt-3">
                    <div class="flex justify-center">
                        <img
                            src=""
                            data-photo-ref="${thumbRef}"
                            data-photo-kind="find"
                            data-find-id="${find.id}"
                            alt="Find photo"
                            class="w-11/12 h-auto object-contain rounded-lg border border-gray-200 cursor-pointer"
                            onclick="openFindPhotoGallery('${find.id}')"
                        />
                    </div>
                    ${
                        photosCount > 1
                            ? `<p class="mt-1 text-xs text-gray-600 text-center">
                                   ${photosCount} photos — tap to view gallery.
                               </p>`
                            : ''
                    }
                </div>
              `
            : '';

        const coordsText = find.coordinates || 'No GPS logged';
        const accText    = find.accuracy   || 'N/A';

        const extraLines = [];
        if (find.identification) extraLines.push(`<div><span class="font-semibold">ID:</span> ${escapeHtml(find.identification)}</div>`);
        if (find.material) extraLines.push(`<div><span class="font-semibold">Material:</span> ${escapeHtml(find.material)}</div>`);
        if (find.condition) extraLines.push(`<div><span class="font-semibold">Condition:</span> ${escapeHtml(find.condition)}</div>`);
        if (find.period) extraLines.push(`<div><span class="font-semibold">Period:</span> ${escapeHtml(find.period)}</div>`);
        if (find.weightG) extraLines.push(`<div><span class="font-semibold">Weight:</span> ${escapeHtml(find.weightG)} g</div>`);
        if (find.dimensionsMm) extraLines.push(`<div><span class="font-semibold">Size:</span> ${escapeHtml(find.dimensionsMm)}</div>`);
        if (find.whereKept) extraLines.push(`<div><span class="font-semibold">Kept:</span> ${escapeHtml(find.whereKept)}</div>`);
        if (find.possibleTreasure) extraLines.push(`<div><span class="font-semibold">Possible treasure:</span> Yes</div>`);
        if (find.disposition) extraLines.push(`<div><span class="font-semibold">Disposition:</span> ${escapeHtml(find.disposition)}</div>`);
        const extraHtml = extraLines.length ? `<div class="mt-3 text-xs text-gray-700 space-y-1">${extraLines.join('')}</div>` : '';

        return `
            <div class="bg-white rounded-xl shadow-md p-4 mb-4 border border-gray-100">
                <div class="flex items-start justify-between">
                    <div>
                        <h3 class="text-lg font-bold text-primary">
                            ${find.description || 'Unnamed Find'}
                        </h3>
                        <p class="text-xs text-gray-500 mt-1">
                            ${find.surveyName || 'Unknown survey'}
                        </p>
                        <p class="text-xs text-gray-500 mt-1">Logged: ${dateText}</p>
                    </div>
                    <span class="inline-flex items-center px-2 py-1 text-xs font-semibold rounded-full bg-gray-100 text-gray-800">
                        ${typeLabel}
                    </span>
                </div>

                ${photoHtml}

                ${extraHtml}

                <div class="mt-3 grid grid-cols-2 gap-2 text-xs text-gray-700">
                    <div>
                        <span class="font-semibold">VDI:</span> ${find.vdi || '—'}
                    </div>
                    <div>
                        <span class="font-semibold">Depth:</span> ${find.depth || '—'}
                    </div>
                    <div>
                        <span class="font-semibold">Coords:</span>
                        <span class="break-all">${coordsText}</span>
                    </div>
                    <div>
                        <span class="font-semibold">Accuracy:</span> ${accText}
                    </div>
                </div>

                <!-- Actions row: Edit / Delete (same style language as Targets) -->
                <div class="mt-4 grid grid-cols-2 gap-2">
                    <button
                        type="button"
                        class="find-card-edit-btn w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-purple-100 text-purple-800 hover:bg-purple-200
                               border border-purple-300
                               text-xs sm:text-sm font-semibold"
                        data-find-id="${find.id}">
                        Edit details
                    </button>

                    <button
                        type="button"
                        class="find-card-delete-btn w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-red-600 text-white hover:bg-red-700
                               text-xs sm:text-sm font-semibold"
                        data-find-id="${find.id}">
                        Delete Find
                    </button>
                </div>
            </div>
        `;
    }).join('');

    const typesOptionsHtml = [
        '<option value="All">All Types</option>',
        ...typeOptions.map(t =>
            `<option value="${t}" ${findsFilter.type === t ? 'selected' : ''}>${t}</option>`
        )
    ].join('');

    const surveyOptionsHtml = [
        '<option value="All">All Surveys</option>',
        ...surveyOptions.map(({ id, name }) =>
            `<option value="${id}" ${findsFilter.surveyId === id ? 'selected' : ''}>${name}</option>`
        )
    ].join('');

    const dateOptionsHtml = [
        '<option value="All">All Dates</option>',
        ...dateOptions.map(d =>
            `<option value="${d.key}" ${findsFilter.date === d.key ? 'selected' : ''}>${d.label}</option>`
        )
    ].join('');

    return `
        <div class="p-4">
            <h2 class="text-3xl font-bold text-primary mb-2">Finds Library</h2>
            <p class="text-sm text-gray-600 mb-4">
             ${
                 hasFinds
                ? `Showing ${filteredCount} of ${totalCount} finds.`
                : 'No finds have been saved yet.'
                }

            </p>

            <div class="mb-4 bg-white rounded-xl shadow-sm border border-gray-100 p-3">
                <div class="flex flex-col gap-2 sm:flex-row sm:items-center">
                    <div class="flex-1">
                        <label class="block text-xs font-semibold text-gray-600 mb-1" for="finds-search-input">
                            Search description / notes
                        </label>
                        <input
                            id="finds-search-input"
                            type="text"
                            class="w-full px-3 py-2 rounded-lg border border-gray-300 text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary"
                            placeholder="Search finds..."
                            value="${findsFilter.query || ''}"
                        />
                    </div>
                    <div class="flex-1">
                        <label class="block text-xs font-semibold text-gray-600 mb-1" for="finds-type-select">
                            Filter by type
                        </label>
                        <select
                            id="finds-type-select"
                            class="w-full px-3 py-2 rounded-lg border border-gray-300 text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary"
                        >
                            ${typesOptionsHtml}
                        </select>
                    </div>
                    <div class="flex-1">
                        <label class="block text-xs font-semibold text-gray-600 mb-1" for="finds-survey-select">
                            Filter by survey
                        </label>
                        <select
                            id="finds-survey-select"
                            class="w-full px-3 py-2 rounded-lg border border-gray-300 text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary"
                        >
                            ${surveyOptionsHtml}
                        </select>
                    <div class="flex-1">
                        <label class="block text-xs font-semibold text-gray-600 mb-1" for="finds-date-select">
                            Filter by date
                        </label>
                        <select
                            id="finds-date-select"
                            class="w-full px-3 py-2 rounded-lg border border-gray-300 text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary"
                        >
                            ${dateOptionsHtml}
                        </select>
                    </div>

                    </div>
                </div>
                <div class="mt-3 flex justify-end">
                    <button
                        id="clear-finds-filters-btn"
                        type="button"
                        class="px-3 py-1 rounded-lg text-xs font-semibold border border-gray-300 text-gray-700 hover:bg-gray-100"
                    >
                        Clear filters
                    </button>
                </div>
            </div>

            <div id="finds-list">
                ${
                    cardsHtml
                        || (hasFinds
                            ? '<p class="text-sm text-gray-600">No finds match your filters.</p>'
                            : ''
                           )
                }
            </div>
        </div>
    `;
}
        
/** Renders a single target card. */
function renderTargetCard(target, surveyId) {
    // --- Type icon & colour chip ---
    let typeColor = 'bg-primary';
    let typeIcon  = 'fas fa-gem';

 switch (target.type) {
    case 'Button':
        typeColor = 'bg-amber-500';
        typeIcon  = 'fas fa-dot-circle';
        break;
    case 'Coin':
        typeColor = 'bg-yellow-500';
        typeIcon  = 'fas fa-coins';
        break;
    case 'Relic':
        typeColor = 'bg-red-500';
        typeIcon  = 'fas fa-shield-alt';
        break;
    case 'Jewelry':
        typeColor = 'bg-pink-500';
        typeIcon  = 'fas fa-ring';
        break;
    case 'Modern Junk':
        typeColor = 'bg-gray-500';
        typeIcon  = 'fas fa-trash';
        break;
    case 'Iron Junk':
        typeColor = 'bg-gray-700';
        typeIcon  = 'fas fa-magnet';
        break;
    case 'Unidentified':
        typeColor = 'bg-purple-500';
        typeIcon  = 'fas fa-question';
        break;
}


   // --- Status badge styling ---
let statusClass = 'bg-blue-100 text-blue-800';
let statusIcon  = `
  <svg class="w-4 h-4 mr-1 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24"
       xmlns="http://www.w3.org/2000/svg">
    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
          d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
  </svg>`;

const s = target.status || 'Not dug';

switch (s) {
    case 'Not dug':
        statusClass = 'bg-blue-100 text-blue-800';
        break;

    case 'Dug':
        statusClass = 'bg-amber-100 text-amber-800';
        statusIcon  = `
          <svg class="w-4 h-4 mr-1 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24"
               xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M4 6h16M4 10h16M4 14h10"></path>
          </svg>`;
        break;

    case 'Refilled':
        statusClass = 'bg-green-100 text-green-800';
        statusIcon  = `
          <svg class="w-4 h-4 mr-1 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24"
               xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M5 13l4 4L19 7"></path>
          </svg>`;
        break;

    case 'Ignore':
        statusClass = 'bg-gray-100 text-gray-800';
        statusIcon  = `
          <svg class="w-4 h-4 mr-1 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24"
               xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M6 18L18 6M6 6l12 12"></path>
          </svg>`;
        break;
}

    // --- Photo thumbnail block (IndexedDB-aware) ---
    let thumbRef    = '';
    let photosCount = 0;

    // Prefer the new structure: an array of refs or data URLs
    if (Array.isArray(target.photos) && target.photos.length) {
        thumbRef    = target.photos[0];
        photosCount = target.photos.length;
    } else if (target.targetPhotoRef) {
        // Single ref field
        thumbRef    = target.targetPhotoRef;
        photosCount = 1;
    } else if (target.targetPhotoData || target.photoDataUrl) {
        // Legacy base64 / URL fallback
        thumbRef    = target.targetPhotoData || target.photoDataUrl;
        photosCount = thumbRef ? 1 : 0;
    }

    let photoHtml = '';
    if (thumbRef) {
        const captionHtml = photosCount > 1
            ? `<p class="mt-1 text-xs text-gray-600 text-center">
                    ${photosCount} photos — tap to view gallery.
               </p>`
            : '';

        photoHtml = `
            <div class="mt-3">
                <div class="flex justify-center">
                    <img
                        src=""
                        data-photo-ref="${thumbRef}"
                        data-photo-kind="target"
                        data-target-id="${target.id}"
                        data-survey-id="${surveyId}"
                        alt="Target photo"
                        class="w-11/12 h-auto object-contain rounded-lg border border-gray-200 cursor-pointer"
                        onclick="openTargetPhotoGallery('${target.id}', '${surveyId}')"
                    />
                </div>
                ${captionHtml}
            </div>
        `;
    }

    const vdiText   = target.vdi ?? 'N/A';
    const depthText = target.depth ?? 'Unknown';

    const coordsText = target.coordinates && target.coordinates !== 'No GPS logged'
        ? target.coordinates
        : 'No GPS logged';

    const accuracyText = target.accuracy && target.accuracy !== 'N/A'
        ? `${target.accuracy} m`
        : 'N/A';

    return `
        <div class="bg-white rounded-xl shadow-md p-4 border border-gray-100">
            <div class="flex items-start justify-between mb-2">
                <div class="flex items-center space-x-2">
                    <span class="inline-flex items-center justify-center w-9 h-9 rounded-full ${typeColor} text-white">
                        <i class="${typeIcon} text-lg"></i>
                    </span>
                    <div>
                        <h3 class="text-lg font-bold text-gray-800">
                            ${target.description || 'Unnamed Target'}
                        </h3>
                        <p class="text-xs text-gray-500">
                            VDI: <span class="font-semibold">${vdiText}</span> ·
                            Depth: <span class="font-semibold">${depthText}</span>
                        </p>
                    </div>
                </div>

                <span class="inline-flex items-center px-2 py-1 text-xs font-semibold rounded-full ${statusClass}">
                    ${statusIcon}
                   <span>${target.status || 'Not dug'}</span>

                </span>
            </div>

            ${photoHtml}

            <div class="mt-3 grid grid-cols-2 gap-2 text-xs text-gray-600">
                <div>
                    <p class="font-semibold">Coordinates</p>
                    <p class="break-words">${coordsText}</p>
                </div>
                <div>
                    <p class="font-semibold">Accuracy</p>
                    <p>${accuracyText}</p>
                </div>
            </div>

            <div class="mt-3 text-xs text-gray-500 flex justify-between">
                <span>Logged: ${formatDate(target.time)}</span>
                <span>${target.user || userProfile.name} · ${target.detector || userProfile.detector}</span>
            </div>

            <!-- Actions -->
            <div class="mt-4 space-y-2">
  <!-- Row 1: Hole status buttons -->
<div class="grid grid-cols-4 gap-2 mt-3">

  <button
    type="button"
    data-action="setStatus"
    data-id="${target.id}"
    data-survey-id="${surveyId}"
    data-value="Not dug"
    class="w-full py-2 text-xs rounded font-bold shadow-sm transition-colors ${target.status === 'Not dug' ? 'bg-blue-500 text-white' : 'bg-gray-200 text-gray-700'}">
    Not dug
  </button>

  <button
    type="button"
    data-action="setStatus"
    data-id="${target.id}"
    data-survey-id="${surveyId}"
    data-value="Dug"
    class="w-full py-2 text-xs rounded font-bold shadow-sm transition-colors ${target.status === 'Dug' ? 'bg-amber-500 text-white' : 'bg-gray-200 text-gray-700'}">
    Dug
  </button>

  <button
    type="button"
    data-action="setStatus"
    data-id="${target.id}"
    data-survey-id="${surveyId}"
    data-value="Refilled"
    class="w-full py-2 text-xs rounded font-bold shadow-sm transition-colors ${target.status === 'Refilled' ? 'bg-green-500 text-white' : 'bg-gray-200 text-gray-700'}">
    Refilled
  </button>

  <button
    type="button"
    data-action="setStatus"
    data-id="${target.id}"
    data-survey-id="${surveyId}"
    data-value="Ignore"
    class="w-full py-2 text-xs rounded font-bold shadow-sm transition-colors ${target.status === 'Ignore' ? 'bg-gray-500 text-white' : 'bg-gray-200 text-gray-700'}">
    Ignore
  </button>

</div>

                <!-- Row 2: Navigation -->
                     <!-- Row 2: QR + Navigation -->
                <div class="grid grid-cols-3 gap-2">
                    <button data-action="showQr" 
                    data-id="${target.id}"      
                    data-survey-id="${surveyId}"
                    class="w-full py-2 mb-2 bg-gray-100 rounded-lg text-sm font-bold text-primary border border-gray-200 active:bg-gray-200">
    <i class="fas fa-qrcode mr-2"></i> Show QR
</button>

<button type="button" 
            data-action="navigate" data-id="${target.id}" data-survey-id="${surveyId}"
            class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md bg-emerald-600 text-white hover:bg-emerald-700 text-xs sm:text-sm font-semibold">
        Navigate
    </button>
    <button type="button" 
            data-action="centerOnMap" data-id="${target.id}" data-survey-id="${surveyId}"
            class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md bg-sky-600 text-white hover:bg-sky-700 text-xs sm:text-sm font-semibold">
        Centre Map
    </button>                </div>

                <!-- Row 3: Edit / Copy / Delete -->
                <div class="grid grid-cols-3 gap-2">
  <button type="button" 
            data-action="edit" data-id="${target.id}" data-survey-id="${surveyId}"
            class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md bg-blue-600 text-white hover:bg-blue-700 text-xs sm:text-sm font-semibold">
        Edit details
    </button>
    <button type="button" 
            data-action="saveFind" data-id="${target.id}" data-survey-id="${surveyId}"
            class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md bg-amber-500 text-white hover:bg-amber-600 text-xs sm:text-sm font-semibold">
        Copy to finds
    </button>
    <button type="button" 
            data-action="delete" data-id="${target.id}" data-survey-id="${surveyId}"
            class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md bg-red-600 text-white hover:bg-red-700 text-xs sm:text-sm font-semibold">
        Delete
    </button>              </div>
            </div>
        </div>
    `;
}

        
            // --- MAP ZOOM & PAN STATE ---

let mapZoom = 1;
let mapOffsetX = 0; // in %
let mapOffsetY = 0; // in %

const MAP_ZOOM_MIN = 0.5;
const MAP_ZOOM_MAX = 6;
const MAP_ZOOM_STEP = 0.25;

let isMapDragging = false;
let mapDragStartX = 0;
let mapDragStartY = 0;
let mapDragStartOffsetX = 0;
let mapDragStartOffsetY = 0;

/** Re-render the Compass page if it is the active page. */
function rerenderCompassIfActive() {
    if (typeof currentPage !== 'undefined' && currentPage === 'Compass') {
        const appContent = document.getElementById('app-content');
        if (appContent && typeof renderCompassPage === 'function') {
            appContent.innerHTML = renderCompassPage(true);
            if (typeof attachPageEventListeners === 'function') {
                attachPageEventListeners();
            }
        }
    }
}

function zoomMapIn(event) {
    if (event) { event.preventDefault(); event.stopPropagation(); }
    mapZoom = Math.min(MAP_ZOOM_MAX, mapZoom + MAP_ZOOM_STEP);
    rerenderCompassIfActive();
}

function zoomMapOut(event) {
    if (event) { event.preventDefault(); event.stopPropagation(); }
    mapZoom = Math.max(MAP_ZOOM_MIN, mapZoom - MAP_ZOOM_STEP);
    rerenderCompassIfActive();
}

function resetMapView(event) {
    if (event) { event.preventDefault(); event.stopPropagation(); }

    // Reset zoom + pan
    mapZoom = 1;
    mapOffsetX = 0;
    mapOffsetY = 0;


    // Also ensure fullscreen is exited (prevents 'stuck tall map')
    if (typeof isMapFullscreen !== 'undefined') {
        isMapFullscreen = false;
    }
    // Clear any "centre on map" target flag (open survey only)
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (openSurvey && Array.isArray(openSurvey.targets)) {
        openSurvey.targets.forEach(t => { t.centerOnMap = false; });
        saveSurveysToLocalStorage();
    }

    render();
    showMessage('Map view reset (centre target cleared).', 'success');
}

/** Start dragging the map to pan it. */
function startMapDrag(event) {
    // Don't start a drag when clicking on zoom controls or a pin
    if (
        event.target.closest &&
        (event.target.closest('.map-zoom-controls') ||
         event.target.closest('.map-pin'))
    ) {
        return;
    }

    const e = event.touches ? event.touches[0] : event;
    event.preventDefault();

    isMapDragging = true;
    mapDragStartX = e.clientX;
    mapDragStartY = e.clientY;
    mapDragStartOffsetX = mapOffsetX;
    mapDragStartOffsetY = mapOffsetY;

    document.addEventListener('mousemove', onMapDrag, { passive: false });
    document.addEventListener('mouseup', endMapDrag);
    document.addEventListener('touchmove', onMapDrag, { passive: false });
    document.addEventListener('touchend', endMapDrag);
}

function onMapDrag(event) {
    if (!isMapDragging) return;

    const e = event.touches ? event.touches[0] : event;
    event.preventDefault();

    const container = document.getElementById('target-map-container');
    if (!container) return;

    const rect = container.getBoundingClientRect();
    if (!rect.width || !rect.height) return;

    const dx = e.clientX - mapDragStartX;
    const dy = e.clientY - mapDragStartY;

    const dxPercent = (dx / rect.width) * 100;
    const dyPercent = (dy / rect.height) * 100;

    mapOffsetX = mapDragStartOffsetX + dxPercent;
    mapOffsetY = mapDragStartOffsetY + dyPercent;

    // Update transform live without a full re-render
    const inner = container.querySelector('.map-inner-layer');
    if (inner) {
        inner.style.transform =
            `translate(${mapOffsetX}%, ${mapOffsetY}%) scale(${mapZoom})`;
    }
}

function endMapDrag() {
    if (!isMapDragging) return;
    isMapDragging = false;

    document.removeEventListener('mousemove', onMapDrag);
    document.removeEventListener('mouseup', endMapDrag);
    document.removeEventListener('touchmove', onMapDrag);
    document.removeEventListener('touchend', endMapDrag);
}
        
function renderTargetPlot(targets, userCoordsOrNull = null) {
    // Haversine approximation constants
    const M_PER_DEG_LAT = 110574; // meters per degree latitude (relatively constant)
    const M_PER_DEG_LON_AT_EQUATOR = 111320; // meters per degree longitude (at equator)

    // Current zoom (global), and inverse zoom for "keep-size-constant" overlays
    const invZoom = 1 / (mapZoom || 1);

    // Label rules for map pins:
    // - Finds: show Find Type
    // - Targets: if description is 'STAKE' => no label; else if description present => use description; else fallback to VDI
 const getMapPinLabelText = (t) => {
    const isFind = (t && (t.isFind || String(t.type || '').toLowerCase() === 'find'));
    if (isFind) {
        return String(t.findType || t.findCategory || t.type || 'Find');
    }

    // Stakes: keep your existing behaviour (no label)
    const desc = String(t.description || '').trim();
    if (desc && desc.toUpperCase() === 'STAKE') return '';

    // Get VDI / Target ID (prefer t.vdi)
    const v = (t.vdi !== undefined && t.vdi !== null && String(t.vdi).trim() !== '')
        ? t.vdi
        : (t.targetVdi || t.targetVDI || t.targetId || t.targetID || '');

    const vdiStr = String(v || '').trim();

    // For non-stake targets: show "VDI, Description" (or just VDI if no description)
    if (vdiStr && desc) return `${vdiStr}, ${desc}`;
    if (vdiStr) return vdiStr;

    // Fallback: if no VDI, at least show description (keeps current behaviour)
    if (desc) return desc;

    return '';
};


    // ✅ CRITICAL FIX:
    // This function MUST respect the caller's intent.
    // If "Hide My Position" is active, the caller should pass null, and we must not use any global GPS coords.
    const effectiveUserCoords = userCoordsOrNull;

    // ✅ Only treat user GPS as present if the caller provided coords
    const hasUserGPS =
        !!effectiveUserCoords &&
        typeof effectiveUserCoords.lat === 'number' &&
        typeof effectiveUserCoords.lon === 'number' &&
        !isNaN(effectiveUserCoords.lat) &&
        !isNaN(effectiveUserCoords.lon);

    const userAccuracy = (typeof currentUserAccuracy === 'number') ? currentUserAccuracy : 0;
    const diameterInMeters = userAccuracy * 2;
    const bufferPercentage = 0.05; // 5% buffer around the entire calculated area

    // 1. Parse targets and prepare for Bounding Box calculation
    const parsedCoords = (targets || []).map(t => {
        const coordsStr = (t && t.coordinates) ? String(t.coordinates) : '';
        const parts = coordsStr.split(',').map(c => parseFloat(String(c).trim()));
        return {
            id: t.id,
            lat: parts[0],
            lon: parts[1],
            description: t.description,
            type: t.type,
            findType: t.findType,
            findCategory: t.findCategory,
            vdi: t.vdi,
            status: t.status,
            accuracy: parseFloat(t.accuracy) || 0,
            centerOnMap: !!t.centerOnMap,
            isFind: !!t.isFind || (String(t.type || '').toLowerCase() === 'find'),
            isUser: false
        };
    }).filter(c => typeof c.lat === 'number' && typeof c.lon === 'number' && !isNaN(c.lat) && !isNaN(c.lon));

    let allCoords = [...parsedCoords];
    let userCoord = null;

    // Visible tracks from open survey (for bounding box + drawing)
    let visibleTracks = [];
    const openSurveyForMap = surveys.find(s => s.status === 'Open');
    if (openSurveyForMap && Array.isArray(openSurveyForMap.tracks)) {
        visibleTracks = openSurveyForMap.tracks.filter(t =>
            t && t.isVisible !== false && Array.isArray(t.points) && t.points.length > 1
        );

        // Add track points into bounding box calculation
        visibleTracks.forEach(track => {
            track.points.forEach(p => {
                if (p && typeof p.lat === 'number' && typeof p.lon === 'number' && !isNaN(p.lat) && !isNaN(p.lon)) {
                    allCoords.push({
                        id: track.id,
                        lat: p.lat,
                        lon: p.lon,
                        description: track.name || 'Track',
                        type: 'Track',
                        vdi: '',
                        status: '',
                        accuracy: p.accuracy || 0,
                        centerOnMap: false,
                        isFind: false,
                        isUser: false
                    });
                }
            });
        });
    }

    // Add user position ONLY if caller provided coords
    if (hasUserGPS) {
        userCoord = {
            id: 'user',
            lat: effectiveUserCoords.lat,
            lon: effectiveUserCoords.lon,
            description: 'You',
            type: 'User',
            vdi: '',
            status: '',
            accuracy: userAccuracy,
            centerOnMap: false,
            isFind: false,
            isUser: true
        };
        allCoords.push(userCoord);
    }

    // If nothing to plot, show message
    if (!allCoords.length) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-gray-200">
                <p class="text-sm text-gray-600">No valid target coordinates to plot.</p>
            </div>
        `;
    }


// Apply user toggle for drawing tracks only (bounds still calculated from visibleTracks)
const drawTracks = showMapTracks ? visibleTracks : [];


    // 2. Convert lat/lon to metres for local mapping
    const centerLat = allCoords.reduce((sum, c) => sum + c.lat, 0) / allCoords.length;
    const mPerDegLon = M_PER_DEG_LON_AT_EQUATOR * Math.cos(centerLat * Math.PI / 180);

    const coordsMeters = allCoords.map(c => ({
        ...c,
        x: c.lon * mPerDegLon,
        y: c.lat * M_PER_DEG_LAT
    }));

    // 3. Determine bounding box in metres
    let minX = Math.min(...coordsMeters.map(c => c.x));
    let maxX = Math.max(...coordsMeters.map(c => c.x));
    let minY = Math.min(...coordsMeters.map(c => c.y));
    let maxY = Math.max(...coordsMeters.map(c => c.y));

    let mapWidthMeters = maxX - minX;
    let mapHeightMeters = maxY - minY;

    // Include user accuracy diameter (if user shown)
    if (hasUserGPS && diameterInMeters > 0) {
        mapWidthMeters = Math.max(mapWidthMeters, diameterInMeters);
        mapHeightMeters = Math.max(mapHeightMeters, diameterInMeters);
    }

    if (mapWidthMeters === 0) mapWidthMeters = 1;
    if (mapHeightMeters === 0) mapHeightMeters = 1;

    // Add buffer
    minX -= mapWidthMeters * bufferPercentage;
    maxX += mapWidthMeters * bufferPercentage;
    minY -= mapHeightMeters * bufferPercentage;
    maxY += mapHeightMeters * bufferPercentage;

    mapWidthMeters = maxX - minX;
    mapHeightMeters = maxY - minY;

    // Helper: map metres -> percent
    const toPercent = (x, y) => {
        const xPct = ((x - minX) / mapWidthMeters) * 100;
        const yPct = (1 - ((y - minY) / mapHeightMeters)) * 100; // invert Y
        return { xPct, yPct };
    };
    // Auto-centre map on a target flagged "centre on map" (works even when user position is hidden)
    try {
        const centerTarget = (targets || []).find(t => t && t.centerOnMap === true && t.deleted !== true);
        if (centerTarget) {
            const focus = coordsMeters.find(c => c && c.id === centerTarget.id);
            if (focus) {
                const p = toPercent(focus.x, focus.y);
                // Reset zoom/pan to a sensible centred view
                mapZoom = 1;
                mapOffsetX = (50 - p.xPct);
                mapOffsetY = (50 - p.yPct);
            }
        }
    } catch (e) {
        console.warn('Centre-on-map: unable to compute focus point', e);
    }



    // 4. Build pin HTML (targets + finds)
    const pinsHtml = coordsMeters
        .filter(t => {
    if (!t) return false;
    if (t.isUser) return false;
    if (t.type === 'Track') return false;
    // draw-only toggles (bounds still includes all coords)
    if (t.isFind) return !!showMapFinds;
    if (isStakeTarget(t)) return !!showMapStakes;
    return !!showMapTargets;
}) // only pins here
        .map(t => {
            const { xPct, yPct } = toPercent(t.x, t.y);

            // pin style (STATUS-based) + Finds
            const isFind = !!t.isFind || (String(t.type || '').toLowerCase() === 'find');
            const st = (t.status || (isFind ? 'find' : 'Not dug')).toLowerCase();

            // Default = targets
            let pinColor = 'bg-blue-500';      // Not dug
            if (st === 'dug')      pinColor = 'bg-amber-500';
            if (st === 'refilled') pinColor = 'bg-green-500';
            if (st === 'ignore')   pinColor = 'bg-gray-500';

            // Finds get their own colour
            if (isFind || st === 'find') pinColor = 'bg-purple-600';

            const isStake = (!isFind) && (String(t.vdi).trim() === '-100');
            const pinSize = 'w-4 h-4';

            // Accuracy ring (optional)
            let extraRing = '';
            if (typeof t.accuracy === 'number' && t.accuracy > 0 && mapWidthMeters && mapHeightMeters) {
                const scaleFactor = Math.max(mapWidthMeters, mapHeightMeters) / 100;
                const rPct = (t.accuracy / (scaleFactor || 1));
                extraRing = `
                    <div class="absolute rounded-full border border-blue-600/40 bg-blue-400/10 pointer-events-none"
                         style="width:${(rPct * 2).toFixed(2)}%; height:${(rPct * 2).toFixed(2)}%; left:50%; top:50%; transform:translate(-50%,-50%);">
                    </div>
                `;
            }

            return `
                <div
                    class="absolute map-pin"
                    style="left:${xPct.toFixed(2)}%; top:${yPct.toFixed(2)}%; transform: translate(-50%, -50%); z-index: 10;"
                    title="${(t.description || '').replace(/"/g,'&quot;')} (${(t.type || '').toLowerCase()==='find' || t.isFind ? 'Find' : 'Target'} ID: ${t.vdi || ''})"
                    onclick="handleMapTargetClick(event, '${t.id || ''}')"
                >
                    <div class="relative">
                        ${extraRing}
                        <div
                          class="
                          ${pinSize}
                          ${isStake ? 'bg-black' : pinColor}
                          ${isStake ? 'rounded-none' : 'rounded-full'}
                          border-2
                          ${isStake ? 'border-black' : 'border-primary'}
                          shadow-lg
                          cursor-pointer
                          "
                          style="
                          transform: scale(${invZoom});
                          transform-origin: center;
                          "
                          title="${isStake ? 'Stake marker' : ''}"
                          ></div>
                    </div>

                    <!-- Label: counter-scale so it stays the same size while zooming -->
                    ${(() => {
                        const lbl = getMapPinLabelText(t);
                        if (!lbl) return '';
                        const safe = String(lbl).replace(/</g,'&lt;').replace(/>/g,'&gt;');
                        return `
                    <span
                        class="absolute whitespace-nowrap text-xs font-semibold text-gray-800 bg-white p-1 rounded-sm shadow border border-gray-300"
                        style="
                            left: 100%;
                            top: 50%;
                            transform: translate(6px, -50%) scale(${invZoom});
                            transform-origin: left center;
                            z-index: 12;
                        "
                    >${safe}</span>`;
                    })()}
                </div>
            `;
        })
        .join('');

    // 5. User marker
    let userHtml = '';
    if (userCoord) {
        const userMeters = { x: userCoord.lon * mPerDegLon, y: userCoord.lat * M_PER_DEG_LAT };
        const { xPct, yPct } = toPercent(userMeters.x, userMeters.y);

        userHtml = `
            <div
                class="absolute"
                style="left:${xPct.toFixed(2)}%; top:${yPct.toFixed(2)}%; transform: translate(-50%, -50%); z-index: 20;"
                title="You"
            >
                <div
                    class="w-5 h-5 bg-red-500 rounded-full border-2 border-white shadow-lg"
                    style="transform: scale(${invZoom}); transform-origin: center;"
                ></div>
            </div>
        `;
    }

    // 6. Track SVG (if any)
    let trackSvgHtml = '';
    if (drawTracks.length) {
        const polylines = drawTracks.map(track => {
            const pts = track.points
                .filter(p => p && typeof p.lat === 'number' && typeof p.lon === 'number')
                .map(p => {
                    const meters = { x: p.lon * mPerDegLon, y: p.lat * M_PER_DEG_LAT };
                    const pct = toPercent(meters.x, meters.y);
                    return `${pct.xPct.toFixed(3)},${pct.yPct.toFixed(3)}`;
                })
                .join(' ');

            const stroke = track.color || '#2563eb';
            return `<polyline fill="none" stroke="${stroke}" stroke-width="0.7" points="${pts}" />`;
        }).join('');

        trackSvgHtml = `
            <svg
                class="absolute inset-0 w-full h-full pointer-events-none"
                viewBox="0 0 100 100"
                preserveAspectRatio="none"
                style="z-index: 6;"
            >
                ${polylines}
            </svg>
        `;
    }

    // 7. Navigation line (ONLY if userCoord exists!)
    let navLineHtml = '';

    // Need nav target percentages if nav target exists
    let navTargetXPercent = null;
    let navTargetYPercent = null;
    let navTargetLat = null;
    let navTargetLon = null;
    let navTargetAccuracy = null;

    if (navigationTargetId) {
        const navTarget = parsedCoords.find(t => t.id === navigationTargetId);
        if (navTarget) {
            navTargetLat = navTarget.lat;
            navTargetLon = navTarget.lon;
            navTargetAccuracy = navTarget.accuracy;

            const navMeters = { x: navTargetLon * mPerDegLon, y: navTargetLat * M_PER_DEG_LAT };
            const navPct = toPercent(navMeters.x, navMeters.y);
            navTargetXPercent = navPct.xPct;
            navTargetYPercent = navPct.yPct;
        }
    }

    if (
        navigationTargetId &&
        userCoord &&
        navTargetXPercent !== null &&
        navTargetYPercent !== null
    ) {
        const userMeters = { x: userCoord.lon * mPerDegLon, y: userCoord.lat * M_PER_DEG_LAT };
        const userPct = toPercent(userMeters.x, userMeters.y);

        navLineHtml = `
            <svg class="absolute inset-0 w-full h-full pointer-events-none" style="z-index: 15;">
                <line
                    x1="${userPct.xPct.toFixed(2)}%"
                    y1="${userPct.yPct.toFixed(2)}%"
                    x2="${navTargetXPercent.toFixed(2)}%"
                    y2="${navTargetYPercent.toFixed(2)}%"
                    stroke="rgba(239, 68, 68, 0.9)"
                    stroke-width="2"
                />
            </svg>
        `;
    }

    // 8. Map HTML
    const transformStyle = `
        transform: translate(${mapOffsetX}%, ${mapOffsetY}%) scale(${mapZoom});
        transform-origin: center center;
    `;

    const heightStyle = isMapFullscreen ? 'calc(100vh - 140px)' : '320px';

    return `
        <div class="relative w-full bg-gray-50 rounded-xl border border-gray-200 overflow-hidden"
             style="height: ${heightStyle};"
             onclick="toggleMapFullscreen(event)"
             id="target-map-container"
             onmousedown="startMapDrag(event)"
             ontouchstart="startMapDrag(event)"
        >
            <div class="map-inner-layer absolute inset-0" style="${transformStyle}">
                ${trackSvgHtml}
                ${navLineHtml}
                ${pinsHtml}
                ${userHtml}
            </div>
</div>

            



            <!-- Zoom controls -->
            <div class="map-zoom-controls mt-2 mb-2 flex gap-2 justify-center">
                <button
                    type="button"
                    class="px-5 py-2 rounded-xl bg-gray-200 hover:bg-gray-300 font-extrabold text-lg shadow"
                    onclick="zoomMapIn(event)"
                >+</button>

                <button
                    type="button"
                    class="px-5 py-2 rounded-xl bg-gray-200 hover:bg-gray-300 font-extrabold text-lg shadow"
                    onclick="zoomMapOut(event)"
                >−</button>

                <button
                    type="button"
                    class="px-5 py-2 rounded-xl bg-gray-200 hover:bg-gray-300 font-bold text-base shadow"
                    onclick="resetMapView(event)"
                >Reset</button>

                <button
                    id="toggle-gps-btn"
                    type="button"
                    class="px-5 py-2 rounded-xl font-bold text-white shadow hover:opacity-90 text-base"
                    style="background-color: rgb(var(--color-secondary));"
                >${showUserPosition ? 'Hide' : 'Show'}</button>
</div>
        
<!-- Map layer toggles (draw only; bounds still include all) -->
<div class="mt-3 bg-white border border-gray-200 rounded-xl p-3 shadow-sm">
    <div class="text-sm font-semibold text-gray-700 mb-2">Map layers</div>
    <div class="flex flex-wrap gap-4 text-sm">
        <label class="flex items-center gap-2 select-none">
            <input id="map-show-targets-cb" type="checkbox" class="h-4 w-4" ${showMapTargets ? 'checked' : ''}>
            <span>Show Targets</span>
        </label>
        <label class="flex items-center gap-2 select-none">
            <input id="map-show-stakes-cb" type="checkbox" class="h-4 w-4" ${showMapStakes ? 'checked' : ''}>
            <span>Show Stakes</span>
        </label>
        <label class="flex items-center gap-2 select-none">
            <input id="map-show-finds-cb" type="checkbox" class="h-4 w-4" ${showMapFinds ? 'checked' : ''}>
            <span>Show Finds</span>
        </label>
        <label class="flex items-center gap-2 select-none">
            <input id="map-show-tracks-cb" type="checkbox" class="h-4 w-4" ${showMapTracks ? 'checked' : ''}>
            <span>Show Tracks</span>
        </label>
    </div>
</div>


    `;
}
        
    /** Toggles the map state and re-renders immediately. *${(t.isFind
                        ? String(t.findType || t.findCategory || t.type || 'Find')
                        : String(
                            (t.vdi !== undefined && t.vdi !== null && String(t.vdi).trim() !== '')
                                ? t.vdi
                                : (t.targetVdi || t.targetVDI || '')
                        )
                    ).replace(/</g,'&lt;').replace(/>/g,'&gt;')}</span>
                </div>
            `;
        })
        .join('');

    // 5. User marker
    let userHtml = '';
    if (userCoord) {
        const userMeters = { x: userCoord.lon * mPerDegLon, y: userCoord.lat * M_PER_DEG_LAT };
        const { xPct, yPct } = toPercent(userMeters.x, userMeters.y);

        userHtml = `
            <div
                class="absolute"
                style="left:${xPct.toFixed(2)}%; top:${yPct.toFixed(2)}%; transform: translate(-50%, -50%); z-index: 20;"
                title="You"
            >
                <div
                    class="w-5 h-5 bg-red-500 rounded-full border-2 border-white shadow-lg"
                    style="transform: scale(${invZoom}); transform-origin: center;"
                ></div>
            </div>
        `;
    }

    // 6. Track SVG (if any)
    let trackSvgHtml = '';
    if (drawTracks.length) {
        const polylines = drawTracks.map(track => {
            const pts = track.points
                .filter(p => p && typeof p.lat === 'number' && typeof p.lon === 'number')
                .map(p => {
                    const meters = { x: p.lon * mPerDegLon, y: p.lat * M_PER_DEG_LAT };
                    const pct = toPercent(meters.x, meters.y);
                    return `${pct.xPct.toFixed(3)},${pct.yPct.toFixed(3)}`;
                })
                .join(' ');

            const stroke = track.color || '#2563eb';
            return `<polyline fill="none" stroke="${stroke}" stroke-width="0.7" points="${pts}" />`;
        }).join('');

        trackSvgHtml = `
            <svg
                class="absolute inset-0 w-full h-full pointer-events-none"
                viewBox="0 0 100 100"
                preserveAspectRatio="none"
                style="z-index: 6;"
            >
                ${polylines}
            </svg>
        `;
    }

    // 7. Navigation line (ONLY if userCoord exists!)
    let navLineHtml = '';

    // Need nav target percentages if nav target exists
    let navTargetXPercent = null;
    let navTargetYPercent = null;
    let navTargetLat = null;
    let navTargetLon = null;
    let navTargetAccuracy = null;

    if (navigationTargetId) {
        const navTarget = parsedCoords.find(t => t.id === navigationTargetId);
        if (navTarget) {
            navTargetLat = navTarget.lat;
            navTargetLon = navTarget.lon;
            navTargetAccuracy = navTarget.accuracy;

            const navMeters = { x: navTargetLon * mPerDegLon, y: navTargetLat * M_PER_DEG_LAT };
            const navPct = toPercent(navMeters.x, navMeters.y);
            navTargetXPercent = navPct.xPct;
            navTargetYPercent = navPct.yPct;
        }
    }

    if (
        navigationTargetId &&
        userCoord &&
        navTargetXPercent !== null &&
        navTargetYPercent !== null
    ) {
        const userMeters = { x: userCoord.lon * mPerDegLon, y: userCoord.lat * M_PER_DEG_LAT };
        const userPct = toPercent(userMeters.x, userMeters.y);

        navLineHtml = `
            <svg class="absolute inset-0 w-full h-full pointer-events-none" style="z-index: 15;">
                <line
                    x1="${userPct.xPct.toFixed(2)}%"
                    y1="${userPct.yPct.toFixed(2)}%"
                    x2="${navTargetXPercent.toFixed(2)}%"
                    y2="${navTargetYPercent.toFixed(2)}%"
                    stroke="rgba(239, 68, 68, 0.9)"
                    stroke-width="2"
                />
            </svg>
        `;
    }

    // 8. Map HTML
    const transformStyle = `
        transform: translate(${mapOffsetX}%, ${mapOffsetY}%) scale(${mapZoom});
        transform-origin: center center;
    `;

    const heightStyle = isMapFullscreen ? 'calc(100vh - 140px)' : '320px';

    return `
        <div class="relative w-full bg-gray-50 rounded-xl border border-gray-200 overflow-hidden"
             style="height: ${heightStyle};"
             onclick="toggleMapFullscreen(event)"
             id="target-map-container"
             onmousedown="startMapDrag(event)"
             ontouchstart="startMapDrag(event)"
        >
            <div class="map-inner-layer absolute inset-0" style="${transformStyle}">
                ${trackSvgHtml}
                ${navLineHtml}
                ${pinsHtml}
                ${userHtml}
            </div>
</div>

            

<!-- Map layer toggles (draw only; bounds still include all) -->
<div class="mt-3 bg-white border border-gray-200 rounded-xl p-3 shadow-sm">
    <div class="text-sm font-semibold text-gray-700 mb-2">Map layers</div>
    <div class="flex flex-wrap gap-4 text-sm">
        <label class="flex items-center gap-2 select-none">
            <input id="map-show-targets-cb" type="checkbox" class="h-4 w-4" ${showMapTargets ? 'checked' : ''}>
            <span>Show Targets</span>
        </label>
        <label class="flex items-center gap-2 select-none">
            <input id="map-show-stakes-cb" type="checkbox" class="h-4 w-4" ${showMapStakes ? 'checked' : ''}>
            <span>Show Stakes</span>
        </label>
        <label class="flex items-center gap-2 select-none">
            <input id="map-show-finds-cb" type="checkbox" class="h-4 w-4" ${showMapFinds ? 'checked' : ''}>
            <span>Show Finds</span>
        </label>
        <label class="flex items-center gap-2 select-none">
            <input id="map-show-tracks-cb" type="checkbox" class="h-4 w-4" ${showMapTracks ? 'checked' : ''}>
            <span>Show Tracks</span>
        </label>
    </div>
</div>


    `;
}
        
    /** Toggles the map state and re-renders immediately. */
function toggleMapFullscreen(event) {
    // Prevent accidental fullscreen toggles when clicking UI controls/pins
    if (event && event.target && event.target.closest) {
        if (event.target.closest('.map-zoom-controls') || event.target.closest('.map-pin') || event.target.closest('button')) {
            return;
        }
    }

    isMapFullscreen = !isMapFullscreen;
    render();
}

function renderNavigationMiniMapSimple({
    targetLat, targetLon,
    userLat, userLon,
    distMeters,
    bearingDeg,
    movementBearingDeg
}) {
    // -----------------------------
    // Info panel values
    // -----------------------------
    const distStr =
        (typeof distMeters === 'number' && Number.isFinite(distMeters))
            ? (distMeters >= 1000 ? `${(distMeters / 1000).toFixed(2)} km` : `${Math.round(distMeters)} m`)
            : '—';

    const bearingLabel =
        (typeof bearingToCompassPoint === 'function' && typeof bearingDeg === 'number')
            ? bearingToCompassPoint(bearingDeg, 16)
            : '';

    // -----------------------------
    // Guidance (simple turn suggestion)
    // -----------------------------
    let turnText = '';
    try {
        if (typeof renderTurnGuidanceSimple === 'function') {
            // renderTurnGuidanceSimple returns HTML; here we just want the main label if possible.
            // If you already have a simple helper elsewhere, feel free to replace this.
            // We'll fall back to comparing movementBearingDeg vs bearingDeg.
        }
    } catch (e) {}

    if (!turnText) {
        if (typeof movementBearingDeg === 'number' && typeof bearingDeg === 'number') {
            const diff = ((bearingDeg - movementBearingDeg + 540) % 360) - 180; // -180..+180
            const ad = Math.abs(diff);

            if (ad < 12) turnText = 'ON COURSE';
            else if (diff > 0) turnText = ad > 45 ? 'TURN RIGHT' : 'SLIGHT RIGHT';
            else turnText = ad > 45 ? 'TURN LEFT' : 'SLIGHT LEFT';
        } else {
            turnText = '—';
        }
    }

    // -----------------------------
    // Session / breadcrumb state (stable path)
    // -----------------------------
    const STATIONARY_DEADBAND_M = 1.8;

    if (!navSession) {
        navSession = {
            active: false,
            startLat: null,
            startLon: null,
            targetLat: null,
            targetLon: null,
            path: [],
            lastLat: null,
            lastLon: null
        };
    }

    // Start a new session if target changed, or not active
    const targetChanged =
        !navSession.active ||
        navSession.targetLat !== targetLat ||
        navSession.targetLon !== targetLon;

    if (targetChanged) {
        navSession.active = true;
        navSession.startLat = userLat;
        navSession.startLon = userLon;
        navSession.targetLat = targetLat;
        navSession.targetLon = targetLon;
        navSession.path = [];
        navSession.lastLat = null;
        navSession.lastLon = null;

        // Reset breadcrumb start index too if you use that elsewhere
        if (typeof navBreadcrumbStartIndex === 'number') navBreadcrumbStartIndex = 0;
    }

    // Keep a stable origin for local coordinates
    const nav = navSession;
    if (!nav.origin) {
        nav.origin = { lat: nav.startLat, lon: nav.startLon };
    } else if (
        typeof nav.origin.lat !== 'number' ||
        typeof nav.origin.lon !== 'number'
    ) {
        nav.origin = { lat: nav.startLat, lon: nav.startLon };
    }

    // Freeze stable user position to reduce jitter
    if (!nav._stableUser) nav._stableUser = { lat: userLat, lon: userLon };
    nav._stableUser.lat = (nav._stableUser.lat * 0.85) + (userLat * 0.15);
    nav._stableUser.lon = (nav._stableUser.lon * 0.85) + (userLon * 0.15);

    const stableUserLat = nav._stableUser.lat;
    const stableUserLon = nav._stableUser.lon;

    // Add breadcrumb point only when movement exceeds deadband
    const last = nav.path.length ? nav.path[nav.path.length - 1] : null;
    let shouldAdd = true;
    if (last && typeof last.lat === 'number' && typeof last.lon === 'number') {
        const step = metersBetweenLatLon(last.lat, last.lon, stableUserLat, stableUserLon);
        if (step < STATIONARY_DEADBAND_M) shouldAdd = false;
    }
    if (shouldAdd) nav.path.push({ lat: stableUserLat, lon: stableUserLon, t: Date.now() });

    // Cap to avoid runaway memory
    const MAX_PATH_POINTS = 1500;
    if (nav.path.length > MAX_PATH_POINTS) nav.path = nav.path.slice(-MAX_PATH_POINTS);

    // -----------------------------
    // Local meters conversion (origin = start)
    // -----------------------------
    const origin = nav.origin;

    function toLocalMeters(lat, lon) {
        const mPerDegLat = 111132.92;
        const mPerDegLon = 111320 * Math.cos((origin.lat * Math.PI) / 180);
        return {
            x: (lon - origin.lon) * mPerDegLon,
            y: -(lat - origin.lat) * mPerDegLat // north up
        };
    }

    const userM = toLocalMeters(stableUserLat, stableUserLon);
    const targetM = toLocalMeters(targetLat, targetLon);

    // Freeze target local meters (prevents tiny drift)
    if (!nav._targetLocalM) nav._targetLocalM = targetM;

    function clampSvg(p) {
        const pad = 3;
        return {
            x: Math.max(pad, Math.min(100 - pad, p.x)),
            y: Math.max(pad, Math.min(100 - pad, p.y))
        };
    }

    // -----------------------------
    // OVERVIEW MAP (top) - midpoint centred
    // -----------------------------
    const centerWorldM = {
        x: (userM.x + nav._targetLocalM.x) / 2,
        y: (userM.y + nav._targetLocalM.y) / 2
    };
    const centerSvg = { x: 50, y: 50 };

    const dxUT = nav._targetLocalM.x - userM.x;
    const dyUT = nav._targetLocalM.y - userM.y;
    let viewRadiusM = Math.max(Math.abs(dxUT), Math.abs(dyUT)) * 0.7;
    viewRadiusM = Math.max(12, viewRadiusM);

    // Ensure recent trail fits a bit
    let trailAbs = 0;
    const recent = nav.path.slice(-250);
    for (const p of recent) {
        const pm = toLocalMeters(p.lat, p.lon);
        trailAbs = Math.max(trailAbs, Math.abs(pm.x - centerWorldM.x), Math.abs(pm.y - centerWorldM.y));
    }
    viewRadiusM = Math.max(viewRadiusM, trailAbs * 1.05);

    // light smoothing to reduce jitter
    if (typeof nav._overviewViewRadiusM !== 'number') nav._overviewViewRadiusM = viewRadiusM;
    nav._overviewViewRadiusM = nav._overviewViewRadiusM * 0.85 + viewRadiusM * 0.15;
    const ovScale = 50 / nav._overviewViewRadiusM;

    function toOverviewSvg(worldM) {
        return clampSvg({
            x: centerSvg.x + (worldM.x - centerWorldM.x) * ovScale,
            y: centerSvg.y + (worldM.y - centerWorldM.y) * ovScale
        });
    }

    const overviewUserSvg = toOverviewSvg(userM);
    const overviewTargetSvg = toOverviewSvg(nav._targetLocalM);
    const overviewStartSvg = toOverviewSvg({ x: 0, y: 0 });

    // Overview trail
    let overviewTrail = '';
    if (nav.path.length > 1) {
        const pts = nav.path
            .map(p => toOverviewSvg(toLocalMeters(p.lat, p.lon)))
            .map(p => `${p.x.toFixed(1)},${p.y.toFixed(1)}`)
            .join(' ');
        overviewTrail = `<polyline points="${pts}" fill="none" stroke="rgba(59,130,246,0.55)" stroke-width="1.8" />`;
    }

    // -----------------------------
    // CLOSE-UP MAP (bottom) - 10m x 10m, target centred
    // -----------------------------
    const closeupCenter = { x: 50, y: 50 };
    const CLOSEUP_HALF_SPAN_M = 5; // ±5m => 10m window
    const cuScale = 50 / CLOSEUP_HALF_SPAN_M;

    function toCloseupSvgFromWorldM(worldM) {
        const relToTarget = {
            x: worldM.x - nav._targetLocalM.x,
            y: worldM.y - nav._targetLocalM.y
        };
        return {
            x: closeupCenter.x + relToTarget.x * cuScale,
            y: closeupCenter.y + relToTarget.y * cuScale
        };
    }

    function isOnCloseup(p) {
        return p.x >= 0 && p.x <= 100 && p.y >= 0 && p.y <= 100;
    }

    const closeupUserRaw = toCloseupSvgFromWorldM(userM);
    const closeupUserOnMap = isOnCloseup(closeupUserRaw);
    const closeupUserSvg = clampSvg(closeupUserRaw);

    // Close-up trail (only points inside window)
    let closeupTrail = '';
    if (nav.path.length > 1) {
        const ptsArr = [];
        for (const p of nav.path) {
            const pm = toLocalMeters(p.lat, p.lon);
            const sp = toCloseupSvgFromWorldM(pm);
            if (isOnCloseup(sp)) {
                const cp = clampSvg(sp);
                ptsArr.push(`${cp.x.toFixed(1)},${cp.y.toFixed(1)}`);
            }
        }
        if (ptsArr.length > 1) {
            closeupTrail = `<polyline points="${ptsArr.join(' ')}" fill="none" stroke="rgba(59,130,246,0.55)" stroke-width="1.8" />`;
        }
    }

    // Direction ray ONLY when user is NOT visible in close-up
    let closeupRay = '';
    if (!closeupUserOnMap) {
        const v = { x: userM.x - nav._targetLocalM.x, y: userM.y - nav._targetLocalM.y };
        const vLen = Math.hypot(v.x, v.y) || 1;
        const ux = v.x / vLen;
        const uy = v.y / vLen;

        function rayToBoxEdge(cx, cy, dx, dy) {
            const candidates = [];
            if (dx !== 0) {
                const t1 = (0 - cx) / dx;
                const t2 = (100 - cx) / dx;
                candidates.push(t1, t2);
            }
            if (dy !== 0) {
                const t3 = (0 - cy) / dy;
                const t4 = (100 - cy) / dy;
                candidates.push(t3, t4);
            }
            const positive = candidates.filter(t => t > 0).sort((a, b) => a - b);
            for (const t of positive) {
                const x = cx + dx * t;
                const y = cy + dy * t;
                if (x >= 0 && x <= 100 && y >= 0 && y <= 100) return { x, y };
            }
            return { x: cx, y: cy };
        }

        const edge = rayToBoxEdge(closeupCenter.x, closeupCenter.y, ux, uy);
        closeupRay = `
            <line x1="${closeupCenter.x}" y1="${closeupCenter.y}"
                  x2="${edge.x.toFixed(1)}" y2="${edge.y.toFixed(1)}"
                  stroke="rgba(59,130,246,0.6)" stroke-dasharray="3 4" stroke-width="2" />
        `;
    }

    // Overlay label positioning (CSS %, stable)
    const side = distMeters < 15 ? 'above' : 'below';
    const aboveOffset = 22;
    const belowOffset = 28;
    const overlayTopPct = (side === 'above') ? (50 - aboveOffset) : (50 + belowOffset);

    // Style constants (match your first map)
    const USER_FILL = 'rgba(239,68,68,0.90)';       // red
    const USER_RING = 'rgba(239,68,68,0.18)';       // red ring
    const TARGET_FILL = 'rgba(59,130,246,0.90)';    // blue
    const TARGET_RING = 'rgba(59,130,246,0.18)';    // blue ring

    return `
        <div class="bg-white rounded-xl shadow border p-3">
            <div class="text-xs text-gray-500 mb-2">
                Mini-map (distance & bearing shown above)
            </div>

            <!-- OVERVIEW -->
            <div>
                <div class="w-full aspect-[16/10] rounded-lg border bg-gray-50 overflow-hidden relative">
                    <svg viewBox="0 0 100 100" class="w-full h-full block">
                        <g stroke="rgba(0,0,0,0.08)" stroke-width="0.6">
                            <line x1="0" y1="50" x2="100" y2="50" />
                            <line x1="50" y1="0" x2="50" y2="100" />
                            <line x1="0" y1="25" x2="100" y2="25" />
                            <line x1="0" y1="75" x2="100" y2="75" />
                            <line x1="25" y1="0" x2="25" y2="100" />
                            <line x1="75" y1="0" x2="75" y2="100" />
                        </g>

                        ${overviewTrail}

                        <!-- Start (grey) -->
                        <circle cx="${overviewStartSvg.x}" cy="${overviewStartSvg.y}" r="2.6" fill="rgba(107,114,128,0.85)" />

                        <!-- Line user -> target -->
                        <line x1="${overviewUserSvg.x}" y1="${overviewUserSvg.y}"
                              x2="${overviewTargetSvg.x}" y2="${overviewTargetSvg.y}"
                              stroke="rgba(239, 68, 68, 0.55)" stroke-width="2" />

                        <!-- Target (blue) -->
                        <circle cx="${overviewTargetSvg.x}" cy="${overviewTargetSvg.y}" r="3.5" fill="${TARGET_FILL}" />
                        <circle cx="${overviewTargetSvg.x}" cy="${overviewTargetSvg.y}" r="6.8" fill="${TARGET_RING}" />

                        <!-- User (red) -->
                        <circle cx="${overviewUserSvg.x}" cy="${overviewUserSvg.y}" r="3.6" fill="${USER_FILL}" />
                        <circle cx="${overviewUserSvg.x}" cy="${overviewUserSvg.y}" r="7.2" fill="${USER_RING}" />
                    </svg>

                    <div class="absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-semibold bg-white/95 border shadow-sm text-gray-800">
                        Overview
                    </div>

                    <div class="absolute left-1/2 -translate-x-1/2 px-2 py-1 rounded-md text-xs font-semibold bg-white/95 border shadow-sm text-gray-800"
                         style="top:${overlayTopPct}%;">
                        ${distStr}
                    </div>
                </div>

                <div class="text-[11px] text-gray-500 mt-2">
                    Overview: centered between you and target (more detail, less wasted space).
                </div>
            </div>

            <!-- CLOSE-UP -->
            <div class="mt-4">
                <div class="w-full aspect-square rounded-lg border bg-gray-50 overflow-hidden relative">
                    <svg viewBox="0 0 100 100" class="w-full h-full block">
                        <g stroke="rgba(0,0,0,0.08)" stroke-width="0.6">
                            <line x1="0" y1="50" x2="100" y2="50" />
                            <line x1="50" y1="0" x2="50" y2="100" />
                            <line x1="0" y1="25" x2="100" y2="25" />
                            <line x1="0" y1="75" x2="100" y2="75" />
                            <line x1="25" y1="0" x2="25" y2="100" />
                            <line x1="75" y1="0" x2="75" y2="100" />
                        </g>

                        ${closeupTrail}
                        ${closeupRay}

                        <!-- TARGET fixed at centre (blue) -->
                        <circle cx="${closeupCenter.x}" cy="${closeupCenter.y}" r="3.5" fill="${TARGET_FILL}" />
                        <circle cx="${closeupCenter.x}" cy="${closeupCenter.y}" r="6.8" fill="${TARGET_RING}" />

                        ${
                            closeupUserOnMap
                                ? `
                                    <line x1="${closeupUserSvg.x}" y1="${closeupUserSvg.y}" x2="${closeupCenter.x}" y2="${closeupCenter.y}"
                                        stroke="rgba(0,0,0,0.18)" stroke-width="1" />
                                    <!-- USER (red + confidence circle) -->
                                    <circle cx="${closeupUserSvg.x}" cy="${closeupUserSvg.y}" r="3.6" fill="${USER_FILL}" />
                                    <circle cx="${closeupUserSvg.x}" cy="${closeupUserSvg.y}" r="7.2" fill="${USER_RING}" />
                                  `
                                : ''
                        }
                    </svg>

                    <div class="absolute top-2 left-2 px-2 py-1 rounded-md text-xs font-semibold bg-white/95 border shadow-sm text-gray-800">
                        Close-up (10m × 10m)
                    </div>
                </div>

                <div class="text-[11px] text-gray-500 mt-2">
                    Close-up: target centered; dashed blue ray shows approach direction until you enter the window.
                </div>
            </div>
        </div>
    `;
}

// ------------------------------
// Simple guidance renderer (missing in this build)
// ------------------------------

// Normalize angle to [0, 360)
function _norm360(deg) {
    let a = deg % 360;
    if (a < 0) a += 360;
    return a;
}

// Signed smallest difference a-b in degrees, result in [-180, +180]
function _angleDiffSigned(aDeg, bDeg) {
    const a = _norm360(aDeg);
    const b = _norm360(bDeg);
    let d = a - b;
    if (d > 180) d -= 360;
    if (d <= -180) d += 360;
    return d;
}

/**
 * Flexible signature so older callers still work.
 * Accepts either:
 *  - renderTurnGuidanceSimple({ bearingDeg, movementBearingDeg, distanceMeters, bearingLabel })
 *  - renderTurnGuidanceSimple(bearingDeg, movementBearingDeg, distanceMeters)
 */
function renderTurnGuidanceSimple(a, b, c) {
    let bearingDeg = null;
    let movementBearingDeg = null;
    let distM = null;
    let bearingLabel = '';

    if (a && typeof a === 'object') {
        bearingDeg = (typeof a.bearingDeg === 'number') ? a.bearingDeg : null;
        movementBearingDeg = (typeof a.movementBearingDeg === 'number') ? a.movementBearingDeg : null;
        distM = (typeof a.distanceMeters === 'number') ? a.distanceMeters : null;
        bearingLabel = String(a.bearingLabel || '');
    } else {
        bearingDeg = (typeof a === 'number') ? a : null;
        movementBearingDeg = (typeof b === 'number') ? b : null;
        distM = (typeof c === 'number') ? c : null;
    }

    if (bearingDeg === null) return '';

    // If we don't know movement direction yet, keep it simple
    if (movementBearingDeg === null) {
        return `
            <div class="mt-3 bg-white border border-gray-200 rounded-xl p-3 shadow-sm">
                <div class="text-sm font-semibold text-gray-700 mb-1">Guidance</div>
                <div class="text-sm text-gray-700">
                    Walk towards <strong>${Math.round(bearingDeg)}°</strong>
                    ${bearingLabel ? `<span class="text-gray-500">(${bearingLabel})</span>` : ''}
                    ${Number.isFinite(distM) ? ` · <span class="text-gray-500">${Math.round(distM)}m</span>` : ''}
                </div>
                <div class="text-[11px] text-gray-500 mt-1">Move a few metres to enable left/right turn guidance.</div>
            </div>
        `;
    }

    // Relative turn: positive = turn right, negative = turn left
    const rel = _angleDiffSigned(bearingDeg, movementBearingDeg);
    const abs = Math.abs(rel);

    let turnText = '';
    if (abs <= 10) turnText = 'ON COURSE';
    else if (abs <= 35) turnText = (rel > 0) ? 'SLIGHT RIGHT' : 'SLIGHT LEFT';
    else if (abs <= 100) turnText = (rel > 0) ? 'TURN RIGHT' : 'TURN LEFT';
    else turnText = 'TURN AROUND';

    const distStr =
        Number.isFinite(distM)
            ? (distM >= 1000 ? `${(distM / 1000).toFixed(2)} km` : `${Math.round(distM)} m`)
            : '';

    return `
        <div class="mt-3 bg-white border border-gray-200 rounded-xl p-3 shadow-sm">
            <div class="flex items-start justify-between gap-3">
                <div>
                    <div class="text-sm font-semibold text-gray-700">Guidance</div>
                    <div class="text-base font-extrabold ${turnText === 'ON COURSE' ? 'text-green-700' : 'text-indigo-700'}">
                        ${turnText}${abs > 10 ? ` · ${Math.round(abs)}°` : ''}
                    </div>
                    <div class="text-sm text-gray-700 mt-1">
                        Target bearing: <strong>${Math.round(bearingDeg)}°</strong>
                        ${bearingLabel ? `<span class="text-gray-500">(${bearingLabel})</span>` : ''}
                        ${distStr ? ` · <span class="text-gray-500">${distStr}</span>` : ''}
                    </div>
                </div>
            </div>
        </div>
    `;
}

        
 function renderNavigationPanel(openSurvey) {
    // If no navigation target has been selected yet, show a hint.
    if (!navigationTargetId) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-dashed border-gray-300 mb-6">
                <h3 class="text-lg font-semibold text-gray-700 mb-1">
                    <i class="fas fa-location-arrow mr-2"></i> Navigation
                </h3>
                <p class="text-sm text-gray-600">
                    Tap a target (or find) pin on the plot to select it for navigation. 
                    Once selected, distance and bearing from your GPS position will appear here.
                </p>
            </div>
        `;
    }

    // Look up the selected target OR find in the open survey
    const target =
        openSurvey.targets.find(t => String(t.id) === String(navigationTargetId))
        || (Array.isArray(finds) ? finds : []).find(f =>
            f &&
            String(f.id) === String(navigationTargetId) &&
            String(f.surveyId) === String(openSurvey.id)
        );

    if (!target) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-red-300 mb-6">
                <h3 class="text-lg font-semibold text-red-700 mb-1">
                    <i class="fas fa-exclamation-triangle mr-2"></i> Navigation Target Missing
                </h3>
                <p class="text-sm text-gray-600">
                    The selected navigation item could not be found (it may have been deleted).
                </p>
                <button
                    class="mt-3 px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-xl font-bold"
                    onclick="clearNavigationTarget()"
                >Clear Navigation</button>
            </div>
        `;
    }

    const coordsStr = String(target.coordinates || '');
    const parts = coordsStr.split(',').map(x => parseFloat(String(x).trim()));
    const tLat = parts[0];
    const tLon = parts[1];

    if (!isFinite(tLat) || !isFinite(tLon)) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-red-300 mb-6">
                <h3 class="text-lg font-semibold text-red-700 mb-1">
                    <i class="fas fa-exclamation-triangle mr-2"></i> Navigation Unavailable
                </h3>
                <p class="text-sm text-gray-600">
                    This item does not have valid GPS coordinates.
                </p>
                <button
                    class="mt-3 px-4 py-2 bg-gray-200 hover:bg-gray-300 rounded-xl font-bold"
                    onclick="clearNavigationTarget()"
                >Clear Navigation</button>
            </div>
        `;
    }

    const u = smoothedUserCoords || currentUserCoords;
    const hasUser =
        u &&
        typeof u.lat === 'number' &&
        typeof u.lon === 'number' &&
        !isNaN(u.lat) &&
        !isNaN(u.lon);

    let distanceStr = '—';
    let bearingStr = '—';
    let miniMapHtml = '';
    let guidanceHtml = '';

    if (hasUser) {
        const dist = haversineDistanceMeters(u.lat, u.lon, tLat, tLon);
        distanceStr = dist >= 1000 ? (dist / 1000).toFixed(2) + ' km' : dist.toFixed(1) + ' m';

        const bearing = calculateBearingDegrees(u.lat, u.lon, tLat, tLon);
        bearingStr = `${bearing.toFixed(0)}° (${bearingToCompassPoint(bearing, 16)})`;

        // Mini-map
        const moveBearing = (typeof currentMovementBearingDeg === 'number') ? currentMovementBearingDeg : null;
        miniMapHtml = renderNavigationMiniMapSimple({
            targetLat: tLat,
            targetLon: tLon,
            userLat: u.lat,
            userLon: u.lon,
            distMeters: dist,
            bearingDeg: bearing,
            movementBearingDeg: moveBearing
        });

        // Guidance
        guidanceHtml = renderTurnGuidanceSimple({
            userLat: u.lat,
            userLon: u.lon,
            targetLat: tLat,
            targetLon: tLon,
            movementBearingDeg: moveBearing
        });
    } else {
        miniMapHtml = `
            <div class="bg-gray-50 border border-gray-200 rounded-xl p-3 text-sm text-gray-600">
                Waiting for a <strong>GPS fix</strong>… navigation mini-maps will appear as soon as your location is available (even if you are using <strong>Hide</strong>).
            </div>
        `;
    }

    const itemType = (String(target.type || '').toLowerCase() === 'find' || target.isFind) ? 'Find' : 'Target';

    return `
        <div class="bg-white p-4 rounded-xl shadow-md border border-gray-200 mb-6">
            <div class="flex items-start justify-between gap-3">
                <div>
                    <h3 class="text-lg font-semibold text-gray-700 mb-1">
                        <i class="fas fa-location-arrow mr-2"></i> Navigation
                    </h3>
                    <p class="text-sm text-gray-600">
                        Selected ${itemType}: <strong>${(target.description || '').replace(/</g,'&lt;').replace(/>/g,'&gt;')}</strong>
                        ${target.vdi ? ` (ID: <strong>${target.vdi}</strong>)` : ''}
                    </p>
                </div>
                <button
                    class="px-3 py-2 bg-gray-200 hover:bg-gray-300 rounded-xl font-bold"
                    onclick="clearNavigationTarget()"
                >Clear</button>
            </div>

            <div class="grid grid-cols-2 gap-3 mt-3">
                <div class="bg-gray-50 border border-gray-200 rounded-xl p-3">
                    <p class="text-xs text-gray-500 font-semibold">Distance</p>
                    <p class="text-lg font-extrabold text-gray-800">${distanceStr}</p>
                </div>
                <div class="bg-gray-50 border border-gray-200 rounded-xl p-3">
                    <p class="text-xs text-gray-500 font-semibold">Bearing</p>
                    <p class="text-lg font-extrabold text-gray-800">${bearingStr}</p>
                </div>
            </div>

            <div id="nav-mini-map-host" class="mt-3">
                ${miniMapHtml}
            </div>

            ${guidanceHtml}
        </div>
    `;
}

        // ======================================
// TRACK RECORDING HELPERS
// ======================================

function refreshActiveTrackFromSurveys() {
    activeTrackSurveyId = null;
    activeTrackId = null;

    if (!Array.isArray(surveys)) return;

    for (const survey of surveys) {
        if (!survey || !Array.isArray(survey.tracks)) continue;
        const active = survey.tracks.find(t => t && t.isRecording);
        if (active) {
            activeTrackSurveyId = survey.id;
            activeTrackId = active.id;
            break;
        }
    }
}

function ensureSurveyTracksArray(survey) {
    if (!survey) return;
    if (!Array.isArray(survey.tracks)) {
        survey.tracks = [];
    }
}

function findTrackById(trackId) {
    if (!trackId || !Array.isArray(surveys)) return null;
    for (const survey of surveys) {
        if (!survey || !Array.isArray(survey.tracks)) continue;
        const track = survey.tracks.find(t => t.id === trackId);
        if (track) {
            return { survey, track };
        }
    }
    return null;
}

function getActiveTrack() {
    if (!activeTrackId || !activeTrackSurveyId) return null;
    const survey = surveys.find(s => s.id === activeTrackSurveyId);
    if (!survey || !Array.isArray(survey.tracks)) return null;
    const track = survey.tracks.find(t => t.id === activeTrackId);
    if (!track) return null;
    return { survey, track };
}

/**
 * Log a point to the currently active track, if any.
 * Uses distanceMeters helper so we only record when you move a few metres.
 */
function logPointToActiveTrack(lat, lon, accuracy) {
    const active = getActiveTrack();
    if (!active) return;

    const { track } = active;
    if (!Array.isArray(track.points)) {
        track.points = [];
    }

    const now = Date.now();
    const last = track.points[track.points.length - 1];

    if (last) {
        const dist = distanceMeters(last.lat, last.lon, lat, lon);
        if (dist < TRACK_POINT_MIN_DISTANCE_METERS) {
            // Too small a move – don’t clutter the track
            return;
        }
    }

    track.points.push({
        time: now,
        lat,
        lon,
        accuracy: typeof accuracy === 'number' ? accuracy : null
    });

    saveSurveysToLocalStorage();
}

function handleStartTrackClick() {
    const openSurvey = surveys.find(s => s.status === 'Open');

    if (!openSurvey) {
        showMessage('You must have an open survey to record a track.', 'error');
        return;
    }

    if (isAnyTrackRecording()) {
        showMessage('A track is already being recorded. Stop it before starting a new one.', 'warning');
        return;
    }

    isTrackingActive = true;
    startLiveMapLocationWatch();
    startCompassAutoRefresh();

    ensureSurveyTracksArray(openSurvey);

    const nextIndex = openSurvey.tracks.length + 1;
    const name = `Track ${nextIndex}`;

    const newTrack = {
        id: generateId(),
        name,
        description: '',              // ✅ NEW: GPX supports <desc>
        createdAt: Date.now(),
        isRecording: true,
        isVisible: true,
        color: pickTrackColor(openSurvey.tracks.length), // ✅ keep your colour logic
        points: []
    };

    openSurvey.tracks.push(newTrack);

    activeTrackSurveyId = openSurvey.id;
    activeTrackId = newTrack.id;

    saveSurveysToLocalStorage();
    showMessage(`Started recording ${name}.`, 'success');
    render();
    // After render(), pop the modal so user can name/describe immediately
    openEditTrackModal(newTrack.id, { isNew: true });

}

/**
 * Stop recording the active track (if any).
 */
function handleStopTrackClick() {
    const active = getActiveTrack();
    if (!active) {
        showMessage('No active track to stop.', 'warning');
        return;
    }

    // Stop recording points into the track
    active.track.isRecording = false;
    saveSurveysToLocalStorage();

    const name = active.track.name || 'track';

    // Clear "active recording" pointers (this is the real source of truth)
    activeTrackSurveyId = null;
    activeTrackId = null;

    // Keep GPS running if user position is shown OR navigation target exists
    // (Requires you to have needsGpsNow() as discussed, or inline the condition)
    if (typeof needsGpsNow === 'function') {
        if (!needsGpsNow()) {
            if (typeof stopLiveMapLocationWatch === 'function') stopLiveMapLocationWatch();
        } else {
            if (!liveMapWatchId) startLiveMapLocationWatch();
        }
    }

    showMessage(`Stopped recording ${name}.`, 'info');
    render();
}

/**
 * Toggle whether a track is drawn on the map.
 */
function toggleTrackVisibility(trackId, isVisible) {
    const found = findTrackById(trackId);
    if (!found) return;

    found.track.isVisible = !!isVisible;
    saveSurveysToLocalStorage();

    if (currentPage === 'Compass') {
        render();
    }
}

     
function renderTracksPanel(openSurvey) {
    if (!openSurvey) return '';

    const tracks = Array.isArray(openSurvey.tracks) ? openSurvey.tracks : [];
    const hasTracks = tracks.length > 0;

    let tracksListHtml = '';

    if (hasTracks) {
        tracksListHtml = tracks.map(track => {
            const isVisible = track.isVisible !== false;
            const pointsCount = Array.isArray(track.points) ? track.points.length : 0;
            const created = track.createdAt
                ? new Date(track.createdAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })
                : '';

            const desc = String(track.description || '').trim();

            const activeBadge = track.isRecording
                ? `<span class="ml-2 inline-flex items-center text-[10px] text-red-600 font-semibold">
                        <span class="inline-block w-2 h-2 rounded-full bg-red-500 mr-1 animate-pulse"></span>
                        recording
                   </span>`
                : '';

            return `
                <div class="flex items-center justify-between gap-2 py-1 border-b border-gray-100 last:border-b-0">
                    <label class="flex items-center gap-2 select-none min-w-0 flex-1">
                        <input
                            type="checkbox"
                            class="track-visibility-toggle h-4 w-4 text-primary flex-shrink-0"
                            data-track-id="${track.id}"
                            ${isVisible ? 'checked' : ''}
                        >
                        <div class="flex flex-col min-w-0">
                            <span class="text-sm font-medium text-gray-700 truncate">
                                ${track.name || 'Track'}
                            </span>
                            <span class="text-xs text-gray-500 truncate">
                                ${pointsCount} points${created ? ` · ${created}` : ''}
                            </span>
                            ${desc ? `
                                <span class="text-[11px] text-gray-400 truncate">
                                    ${desc}
                                </span>
                            ` : ''}
                        </div>
                    </label>

                    <div class="flex items-center gap-2 flex-shrink-0">
                        ${activeBadge}

                        <button
                            type="button"
                            class="track-edit-btn px-3 py-2 rounded-lg bg-slate-700 text-white text-sm hover:bg-slate-800"
                            data-track-id="${track.id}"
                            title="Edit track name & description"
                            aria-label="Edit track"
                        >
                            <i class="fas fa-pen"></i>
                        </button>

                        <button
                            type="button"
                            class="track-delete-btn px-3 py-2 rounded-lg bg-gray-100 hover:bg-red-100 text-red-600 font-bold"
                            data-track-id="${track.id}"
                            title="Delete track"
                            aria-label="Delete track"
                        >
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        }).join('');
    } else {
        tracksListHtml = `
            <p class="text-xs text-gray-500 italic">
                You don't have any tracks recorded yet for this survey.
                Use <strong>Start Tracking</strong> above to begin logging your path.
            </p>
        `;
    }

    return `
        <div class="bg-white p-4 rounded-xl shadow-lg border border-gray-100 mb-4">
            <div class="mb-3">
                <h3 class="text-xl font-semibold text-gray-700 flex items-center gap-2">
                    <i class="fas fa-route text-primary"></i>
                    Tracks for this survey
                </h3>
                <p class="text-xs text-gray-500 mt-1">
                    Select which tracks to overlay on the map.
                </p>
            </div>

            <div class="mt-2 space-y-1">
                ${tracksListHtml}
            </div>
        </div>
    `;
}

function renderCompassPage(isAutoRefresh = false) {
    const openSurvey = surveys.find(s => s.status === 'Open');

    if (!openSurvey) {
        return `
            <div class="p-4">
                <h2 class="text-3xl font-bold text-primary mb-6">Targets Plot View</h2>
                <div class="bg-white p-6 rounded-xl shadow-lg border-l-4 border-red-500">
                    <h3 class="text-xl font-bold text-red-600 mb-3">No Open Survey</h3>
                    <p class="text-gray-700">Please open a survey on the <strong>Home</strong> page to view its targets on the plot.</p>
                </div>
            </div>
        `;
    }

    // Prevent the "numeric keypad disappears" bug: never auto-refresh while typing in the Target ID box
    const activeEl = document.activeElement;
    const isTypingInQuickBox = activeEl && activeEl.id === 'compass-quick-target-vdi';

    // GPS watch: needed for tracking OR navigation
    const needsGps = isAnyTrackRecording() || !!navigationTargetId;

    // GPS watch: needed for showing user position OR navigation OR recording a track
    if (needsGpsNow()) {
        if (!liveMapWatchId) startLiveMapLocationWatch();
    } else {
        if (typeof stopLiveMapLocationWatch === 'function') {
            stopLiveMapLocationWatch();
        } else if (liveMapWatchId) {
            try { navigator.geolocation.clearWatch(liveMapWatchId); } catch (e) {}
            liveMapWatchId = null;
            bestLiveAccuracy = Infinity;
            smoothedUserCoords = null;
        }
    }

    // Auto-refresh loop: when GPS is needed, and never while typing (to avoid keypad bug)
    // Auto-refresh: delegate to startCompassAutoRefresh() (GPS-driven + safety net)
    // and never refresh while typing (prevents keypad bug)
    if (!isAutoRefresh) {
        const needsGps = !!showUserPosition || !!navigationTargetId || isAnyTrackRecording();

        if (!needsGps || isTypingInQuickBox) {
            if (typeof stopCompassAutoRefresh === 'function') stopCompassAutoRefresh();
            else if (autoRefreshIntervalId) { clearInterval(autoRefreshIntervalId); autoRefreshIntervalId = null; }
        } else {
            if (typeof startCompassAutoRefresh === 'function') startCompassAutoRefresh();
        }
    }

    // Targets with usable coordinates
    const targets = getActiveTargets(openSurvey).filter(
        t => t.coordinates && t.coordinates.includes(',') && t.coordinates !== 'No GPS logged'
    );

    // ✅ FINDS with usable coordinates (because targets may be deleted after copying to finds)
    const findsForMap = (Array.isArray(finds) ? finds : [])
        .filter(f =>
            f &&
            String(f.surveyId) === String(openSurvey.id) &&
            f.coordinates &&
            String(f.coordinates).includes(',') &&
            String(f.coordinates) !== 'No GPS logged'
        )
        .map(f => ({
            // Important: Keep the real find ID so navigationTargetId can refer to finds
            id: f.id,
            description: f.description || 'Find',
            type: 'Find',
            findType: f.type || 'Unknown',
            vdi: f.vdi || '',
            status: 'find',
            accuracy: f.accuracy || '',
            coordinates: f.coordinates,
            centerOnMap: false,
            isFind: true
        }));

    // ✅ Combined points for plotting
    const pointsForPlot = [...targets, ...findsForMap];

    // Recording status line (optional nice feedback)
    const activeTrack = Array.isArray(openSurvey.tracks)
        ? openSurvey.tracks.find(t => t && t.isRecording)
        : null;

    const trackingStatusHtml = isAnyTrackRecording()
        ? `<span class="flex items-center text-[11px] text-green-700 font-semibold">
                <span class="inline-block w-2 h-2 rounded-full bg-green-500 mr-1 animate-pulse"></span>
                Tracking ON${activeTrack ? ` · Recording: ${activeTrack.name || 'Track'}` : ''}
           </span>`
        : `<span class="text-[11px] text-gray-500">Tracking OFF</span>`;

    return `
        <div class="p-4">
            <h2 class="text-3xl font-bold text-primary mb-4">Targets Plot View</h2>

            <!-- Survey info -->
            <div class="bg-white p-4 rounded-xl shadow-lg border border-gray-100 mb-4">
                <div class="flex items-start justify-between gap-3">
                    <div>
                        <p class="text-sm text-gray-700">
                            <span class="font-semibold">Survey:</span> ${openSurvey.name || 'Unnamed survey'}
                        </p>
                        <p class="text-xs text-gray-500 mt-1">
                            ${targets.length} targets with GPS coordinates · ${findsForMap.length} finds with GPS coordinates
                        </p>
                        <div class="mt-2">${trackingStatusHtml}</div>
                    </div>
                </div>
            </div>

${(() => {
    const isOn = !!isAnyTrackRecording();
    const startDisabled = isAnyTrackRecording();
    const stopDisabled = !isAnyTrackRecording();

    const activeTrack = (openSurvey && Array.isArray(openSurvey.tracks))
        ? openSurvey.tracks.find(t => t && t.isRecording)
        : null;

    const statusText = isOn
        ? `Tracking ON${activeTrack ? ` · Recording: ${activeTrack.name || 'Track'}` : ''}`
        : 'Tracking OFF';

    return `
    <div class="bg-white p-4 rounded-xl shadow-lg border border-gray-100 mb-4">
        <div class="flex items-start justify-between gap-3 mb-3">
            <h3 class="text-xl font-semibold text-gray-700 flex items-center">
                <i class="fas fa-route mr-2"></i> Tracking Controls
            </h3>

            <span class="text-xs font-semibold px-2 py-1 rounded-full ${isOn ? 'bg-green-100 text-green-700' : 'bg-gray-100 text-gray-600'}">
                ${statusText}
            </span>
        </div>

        <div class="grid grid-cols-2 gap-3">
            <button
                id="start-track-btn"
                type="button"
                ${startDisabled ? 'disabled' : ''}
                class="py-3 rounded-xl font-bold text-white shadow
                       ${startDisabled ? 'bg-green-600 opacity-40 cursor-not-allowed' : 'bg-green-600 hover:bg-green-700'}">
                🟢 Start Tracking
            </button>

            <button
                id="stop-track-btn"
                type="button"
                ${stopDisabled ? 'disabled' : ''}
                class="py-3 rounded-xl font-bold text-white shadow
                       ${stopDisabled ? 'bg-red-600 opacity-40 cursor-not-allowed' : 'bg-red-600 hover:bg-red-700'}">
                🔴 Stop Tracking
            </button>
        </div>
        <p class="text-xs text-gray-500 mt-2">
            Tip: turn tracking <strong>OFF</strong> when you get home so your current location doesn’t squash the survey map.
        </p>
    </div>
    `;
})()}

  
                    <!-- Quick range buttons (rainbow) -->
            <div class="bg-white p-3 rounded-xl shadow-lg border border-gray-100 mb-4">
                <div class="grid grid-cols-5 gap-2">
                    <button type="button"
                        class="compass-range-btn w-full py-3 rounded-lg text-white font-extrabold text-xs shadow bg-blue-600 hover:bg-blue-700"
                        data-min="-7" data-max="3">
                        -7→3
                    </button>

                    <button type="button"
                        class="compass-range-btn w-full py-3 rounded-lg text-white font-extrabold text-xs shadow bg-sky-500 hover:bg-sky-600"
                        data-min="4" data-max="11">
                        4→11
                    </button>

                    <button type="button"
                        class="compass-range-btn w-full py-3 rounded-lg text-white font-extrabold text-xs shadow bg-emerald-600 hover:bg-emerald-700"
                        data-min="12" data-max="18">
                        12→18
                    </button>

                    <button type="button"
                        class="compass-range-btn w-full py-3 rounded-lg text-white font-extrabold text-xs shadow bg-amber-500 hover:bg-amber-600"
                        data-min="19" data-max="26">
                        19→26
                    </button>

                    <button type="button"
                        class="compass-range-btn w-full py-3 rounded-lg text-white font-extrabold text-xs shadow bg-red-600 hover:bg-red-700"
                        data-min="27" data-max="40">
                        27→40
                    </button>
                </div>

                <p class="text-[11px] text-gray-500 mt-2">
                    Tap a colour to instantly log a target with a Target ID chosen inside that range.
                </p>
            </div>

            <!-- STAKE button (creates a marker target with VDI -100) -->
            <div class="mt-3">
                  <button
                    id="stake-target-btn"
                    type="button"
                    class="w-full py-3 rounded-lg font-extrabold shadow bg-purple-600 text-white active:bg-purple-700"
                    >
                    STAKE
                  </button>
            </div>

            <!-- Map -->
            <div class="bg-white p-4 rounded-xl shadow-lg border border-gray-100 mb-4">
                <h3 class="text-xl font-semibold text-gray-700 flex items-center mb-3">
                    <i class="fas fa-map mr-2"></i> Survey Map
                </h3>
                ${renderTargetPlot(pointsForPlot, showUserPosition ? (smoothedUserCoords || currentUserCoords) : null)}
            </div>

            <!-- Navigation -->
            ${renderNavigationPanel(openSurvey)}

            <!-- Tracks list stays where it is -->
            ${renderTracksPanel(openSurvey)}
        </div>
    `;
}
        
/** Renders the content for the Settings page. */
function renderSettingsPage() {
    const secondaryColor = 'rgb(var(--color-secondary))';

    // Limits (Tester build) - display only
    // Assumes you have loadAppLimits() + isExpired(); falls back to your defaults if not present yet.
    const limits = (typeof loadAppLimits === 'function') ? loadAppLimits() : {
        maxSurveys: 3,
        maxTargets: 50,
        maxFinds: 30,
        expiryDate: '2026-06-01'
    };

    const valOrBlank = (v) => (v === null || v === undefined || v === '') ? '' : String(v);
    const expired = (typeof isExpired === 'function') ? isExpired(limits) : false;

    // Display strings (blank means unlimited / no expiry)
    const displayMaxSurveys = valOrBlank(limits.maxSurveys);
    const displayMaxTargets = valOrBlank(limits.maxTargets);
    const displayMaxFinds   = valOrBlank(limits.maxFinds);
    const displayExpiryDate = valOrBlank(limits.expiryDate);

    return `
        <div class="p-4">
            <h2 class="text-3xl font-bold text-primary mb-6">Settings & Local Data Management</h2>

            <div class="bg-white p-4 rounded-xl shadow-lg mb-8 border border-gray-100">
                <h3 class="text-xl font-semibold text-gray-700 mb-3">Your Profile</h3>
                <p class="text-md text-gray-800 mb-1"><strong>Name:</strong> ${userProfile.name}</p>
<p class="text-md text-gray-800 mb-1">
  <strong>NCMD Membership number :</strong> ${
    (userProfile.ncmdNumber && userProfile.ncmdNumber.trim())
      ? userProfile.ncmdNumber.trim()
      : '<span class="text-gray-400">—</span>'
  }
</p>

                <p class="text-md text-gray-800 mb-4"><strong>Detector:</strong> ${userProfile.detector}</p>
                
                <div class="mt-4 pt-3 border-t border-gray-100">
                    <button onclick="showEditProfileModal()" 
                            class="px-3 py-2 text-white font-bold rounded-md text-sm hover:opacity-90 transition duration-150" 
                            style="background-color: ${secondaryColor};">
                        <i class="fas fa-user-edit mr-1"></i> Edit Profile
                    </button>
                </div>
            </div>

            <!-- PHOTO SETTINGS -->
<div class="bg-white p-4 rounded-xl shadow-lg mb-6 border-l-4 border-sky-500">
  <h4 class="text-lg font-semibold text-sky-700 mb-2">Photo Settings</h4>
  <p class="text-sm text-gray-600 mb-3">
    Photos will be resized when selected (before saving). This reduces storage and makes export/import faster.
    Set to <strong>0</strong> to disable resizing.
  </p>

  <label class="block text-sm font-medium text-gray-700 mb-1" for="max-photo-width-input">
    Max Photo Width (px)
  </label>

  <div class="flex gap-2">
    <input id="max-photo-width-input"
           type="number"
           inputmode="numeric"
           min="0"
           step="50"
           class="w-full border border-gray-300 rounded-lg p-2"
           placeholder="1000" />
    <button id="save-photo-settings-btn"
            type="button"
            class="px-4 py-2 rounded-lg bg-sky-600 text-white font-bold shadow hover:bg-sky-700">
      Save
    </button>
  </div>
</div>
<!-- Privacy and legal -->

<!-- ABOUT / VERSION -->
<div class="bg-white p-4 rounded-xl shadow-lg mb-6 border-l-4 border-indigo-500">
  <h4 class="text-lg font-semibold text-indigo-700 mb-2">About</h4>

  <p class="text-sm text-gray-700">
    <strong>${APP_NAME}</strong>
  </p>

  <div class="mt-2 text-sm text-gray-700 space-y-1">
    <p><strong>Version:</strong> ${APP_VERSION}</p>
    <p><strong>Build:</strong> ${APP_BUILD}</p>
  </div>

  <div class="mt-4 pt-3 border-t border-gray-100 flex flex-col gap-2">
    <button
      id="open-privacy-btn"
      type="button"
      class="w-full px-3 py-2 rounded-md bg-gray-100 text-gray-800 font-semibold hover:bg-gray-200"
    >
      <i class="fas fa-shield-alt mr-2"></i> Privacy & Legal
    </button>
    <p class="text-xs text-gray-500 mt-2">
      Privacy policy, disclaimer, and copyright information.
    </p>
  </div>

  <p class="text-xs text-gray-500 mt-2">
    Detekta stores your data locally on your device. No analytics. No tracking.
  </p>
</div>

<!-- APP LIMITS (TESTER BUILD) - READ ONLY -->
<div class="bg-white p-4 rounded-xl shadow-lg mb-6 border-l-4 border-emerald-500">
  <div class="flex items-start justify-between gap-3">
    <div>
      <h4 class="text-lg font-semibold text-emerald-700 mb-1">App Limits (Tester Build)</h4>
      <p class="text-sm text-gray-600">
        These limits are set by the build. Blank means <strong>unlimited</strong>.
      </p>
    </div>
    ${expired ? `<div class="text-xs font-bold text-red-700 bg-red-100 border border-red-200 px-2 py-1 rounded-md">EXPIRED</div>` : ``}
  </div>

  <div class="mt-4 space-y-3">
    <div>
      <label class="block text-sm font-medium text-gray-700 mb-1" for="limits-max-surveys">
        Max number of surveys
      </label>
      <input id="limits-max-surveys"
             type="text"
             readonly
             class="w-full border border-gray-200 rounded-lg p-2 bg-gray-50 text-gray-700"
             value="${displayMaxSurveys}"
             placeholder="Unlimited" />
    </div>

    <div>
      <label class="block text-sm font-medium text-gray-700 mb-1" for="limits-max-targets">
        Max number of targets
      </label>
      <input id="limits-max-targets"
             type="text"
             readonly
             class="w-full border border-gray-200 rounded-lg p-2 bg-gray-50 text-gray-700"
             value="${displayMaxTargets}"
             placeholder="Unlimited" />
    </div>

    <div>
      <label class="block text-sm font-medium text-gray-700 mb-1" for="limits-max-finds">
        Max number of finds
      </label>
      <input id="limits-max-finds"
             type="text"
             readonly
             class="w-full border border-gray-200 rounded-lg p-2 bg-gray-50 text-gray-700"
             value="${displayMaxFinds}"
             placeholder="Unlimited" />
    </div>

    <div>
      <label class="block text-sm font-medium text-gray-700 mb-1" for="limits-expiry-date">
        Expiration date
      </label>
      <input id="limits-expiry-date"
             type="text"
             readonly
             class="w-full border border-gray-200 rounded-lg p-2 bg-gray-50 text-gray-700"
             value="${displayExpiryDate}"
             placeholder="No expiry" />
      <p class="text-xs text-gray-500 mt-1">
        If expired, no new surveys, targets, or finds can be created.
      </p>
    </div>
  </div>
</div>

            <!-- Danger Zone: Reset All Data -->
            <div class="mt-8 border-t border-gray-300 pt-6">
                <h3 class="text-lg font-semibold text-red-600 mb-3">Danger Zone</h3>
                <button id="reset-all-data-btn"
                        class="w-full bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-red-800 transition duration-150">
                    <i class="fas fa-trash-alt mr-1"></i> Reset ALL Local Data on This Device
                </button>
                <p class="text-xs text-gray-500 mt-2">
                    This will delete all saved surveys, targets, finds and photos stored locally on this device.
                    Use this only after exporting anything important.
                </p>
                <p></p>
                  <p class="text-sm text-gray-600 mb-3">
                    Maintenance tools for cleaning local data. Use carefully.
                    </p>

                      <button id="maintenance-btn"
                      type="button"
                      class="w-full bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-red-800 transition">
                        <i class="fas fa-broom mr-1"></i> Maintenance: Clean Local Data
                      </button>

                      <p class="text-xs text-gray-500 mt-2">
                        Removes any leftover “deleted” items and tidies storage.
                      </p>

            </div>
        </div>
    `;
}
/**
 * Convert a Blob to a data URL (base64).
 * Used when exporting photos so they can travel inside JSON.
 */
function blobToDataUrl(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

// Export every survey into ONE master index.html (anchor links that work on Android content://),
// plus write all JPGs into per-survey subfolders (like your current exporter).
async function exportAllSurveysPhotoGalleries_ToFolder(rootPick) {
    const logBox = document.getElementById('export-photo-gallery-log');
    const btn = document.getElementById('export-gallery-to-folder-btn');

    const log = (msg) => {
        console.log('[Gallery Export All]', msg);
        if (!logBox) return;
        logBox.value += msg + '\n';
        logBox.scrollTop = logBox.scrollHeight;
    };
    if (logBox) logBox.value = '';

    if (!Array.isArray(surveys) || surveys.length === 0) {
        showMessage('No surveys to export.', 'error');
        return;
    }

    let originalBtnText = '';
    if (btn) {
        originalBtnText = btn.innerText;
        btn.disabled = true;
        btn.innerText = 'Exporting all surveys...';
    }

    // ---------- helpers ----------
    const safeFolderName = (s) => {
        const base = String(s ?? '').trim() || 'Survey';
        return base
            .replace(/[\/\\:*?"<>|]/g, '_')
            .replace(/\s+/g, ' ')
            .trim()
            .slice(0, 60);
    };

    const safeId = (s) => String(s ?? '')
        .replace(/[^a-zA-Z0-9\-_]/g, '')
        .slice(0, 40) || 'id';

    const xmlEscape = (s) => String(s ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');

    const dataUrlToBlob = async (dataUrl) => {
        const res = await fetch(dataUrl);
        return await res.blob();
    };

    const blobToDataUrl = (blob) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error || new Error('File read failed'));
        reader.readAsDataURL(blob);
    });

    const extFromMime = (mime) => {
        const m = String(mime || '').toLowerCase();
        if (m.includes('jpeg') || m.includes('jpg')) return 'jpg';
        if (m.includes('png')) return 'png';
        if (m.includes('webp')) return 'webp';
        if (m.includes('gif')) return 'gif';
        return 'bin';
    };

    // Resolve a "photo ref" (data URL or idb ref) to a Blob.
    const resolvePhotoRefToBlob = async (ref) => {
        if (!ref) return null;

        // data URL
        if (typeof ref === 'string' && ref.startsWith('data:image/')) {
            try { return await dataUrlToBlob(ref); } catch (e) { return null; }
        }

        // IndexedDB ref: "idb:..."
        if (typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(ref)) {
            try {
                if (typeof parsePhotoRef === 'function' && typeof loadPhotoBlob === 'function') {
                    const id = parsePhotoRef(ref);
                    if (id == null) return null;
                    return await loadPhotoBlob(id);
                }
            } catch (e) {
                return null;
            }
        }

        return null;
    };

    // Write file into a directory using your existing helper if present.
    const writeFile = async (dirHandle, filename, blob) => {
        if (typeof writeFileToHandle === 'function') {
            await writeFileToHandle(dirHandle, filename, blob);
            return;
        }
        // fallback
        const fh = await dirHandle.getFileHandle(filename, { create: true });
        const w = await fh.createWritable();
        await w.write(blob);
        await w.close();
    };

    // Get a survey thumbnail as a DATA URL (for master grid).
    const getSurveyThumbDataUrl = async (survey) => {
        // Prefer embedded data URL
        if (survey && typeof survey.surveyPhotoData === 'string' && survey.surveyPhotoData.startsWith('data:image/')) {
            return survey.surveyPhotoData;
        }

        // Try IndexedDB photo ref
        if (survey && survey.surveyPhotoRef && typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(survey.surveyPhotoRef)) {
            try {
                const blob = await resolvePhotoRefToBlob(survey.surveyPhotoRef);
                if (blob) return await blobToDataUrl(blob);
            } catch (_) {}
        }

        return '';
    };

    // Build the per-survey gallery HTML fragment that points into its own subfolder.
    const buildSurveySectionHtml = ({
        survey,
        folderName,
        surveyHeroRelPath,
        findCardsHtml,
        targetCardsHtml,
        fullSectionsHtml,
        includeTargets
    }) => {
        const title = survey?.name || 'Survey';
        const created = survey?.creationDate ? new Date(survey.creationDate).toLocaleString() : '';
        const changed = survey?.dateLastChanged ? new Date(survey.dateLastChanged).toLocaleString() : '';
        const desc = survey?.description || '';

        const info = `
            <div class="surveyHeader">
              <div class="surveyHeaderTop">
                <h2 class="surveyTitle">${xmlEscape(title)}</h2>
                <a class="backTop" href="#top">Back to top</a>
              </div>
              ${desc ? `<p class="surveyDesc">${xmlEscape(desc)}</p>` : ''}
              <p class="surveyMeta">
                ${created ? `<span><strong>Created:</strong> ${xmlEscape(created)}</span>` : ''}
                ${changed ? `<span><strong>Last changed:</strong> ${xmlEscape(changed)}</span>` : ''}
                <span><strong>Folder:</strong> ${xmlEscape(folderName)}</span>
              </p>
              ${surveyHeroRelPath ? `
                <div class="heroWrap">
                  <img class="heroImg" src="${xmlEscape(surveyHeroRelPath)}" alt="Survey photo">
                </div>` : ''
              }
            </div>
        `;

        return `
          <section class="surveySection" id="survey-${safeId(survey?.id)}">
            ${info}

            <h3>Finds</h3>
            <div class="grid">${findCardsHtml || ''}</div>

            ${includeTargets ? `<h3>Targets</h3><div class="grid">${targetCardsHtml || ''}</div>` : ''}

            <h3>Full Photos</h3>
            ${fullSectionsHtml || ''}

            <div class="surveyFooter">
              <a href="#top">Back to top</a>
            </div>
          </section>
        `;
    };

    // ---------- main ----------
    try {
        if (!rootPick) {
            // If caller didn't pass a handle, use directory picker.
            if (!window.showDirectoryPicker) {
                showMessage('Folder export needs the File System Access API (Chrome/Edge).', 'error');
                return;
            }
            rootPick = await window.showDirectoryPicker();
        }

        log(`Exporting ${surveys.length} surveys into one master index.html (Android-safe links).`);

        // If you already have a checkbox for “include targets”, use it if present.
        // If not present, default true to match your current gallery exporter.
        const includeTargetsCb = document.getElementById('export-gallery-include-targets-cb');
        const includeTargets = includeTargetsCb ? !!includeTargetsCb.checked : true;

        const masterCards = [];
        const masterSections = [];

        // We do NOT reuse “exportOpenSurveyPhotoGallery_ToFolder” here, because it generates separate index pages,
        // which is exactly what fails on Android content:// navigation.
        for (let i = 0; i < surveys.length; i++) {
            const survey = surveys[i];
            const title = survey?.name || `Survey ${i + 1}`;
            const folderName = `${safeFolderName(title)}_${safeId(survey?.id || i + 1)}`;

            log(`\n[${i + 1}/${surveys.length}] ${title} -> ${folderName}/`);

            const surveyDir = await rootPick.getDirectoryHandle(folderName, { create: true });
            const surveyImgDir = await surveyDir.getDirectoryHandle('Survey', { create: true });
            const findsImgDir  = await surveyDir.getDirectoryHandle('Finds',  { create: true });
            const targetsImgDir= await surveyDir.getDirectoryHandle('Targets',{ create: true });

            // ----- Export Survey hero photo (if exists) -----
            let surveyHeroRelPath = '';
            {
                const ref = survey?.surveyPhotoData || survey?.surveyPhotoRef || '';
                const blob = await resolvePhotoRefToBlob(ref);
                if (blob) {
                    const ext = extFromMime(blob.type);
                    const fileName = `survey_${safeId(survey?.id)}.${ext}`;
                    await writeFile(surveyImgDir, fileName, blob);
                    surveyHeroRelPath = `./${folderName}/Survey/${fileName}`;
                }
            }

            // ----- Collect finds linked to this survey -----
            const linkedFinds = (Array.isArray(finds) ? finds : []).filter(f => f && f.surveyId === survey.id);

            // ----- Build cards + export find photos -----
            const findCards = [];
            const targetCards = [];
            const fullSections = [];

            // Helper to push a “full photo” section
            const pushFullSection = (label, relPath) => {
                if (!relPath) return;
                fullSections.push(`
                  <div class="detail">
                    <p class="back"><a href="#top">Back to top</a></p>
                    <img class="full" src="${xmlEscape(relPath)}" alt="${xmlEscape(label)}">
                    <p class="muted">${xmlEscape(label)}</p>
                  </div>
                `);
            };

            // FIND cards
            for (let fi = 0; fi < linkedFinds.length; fi++) {
                const f = linkedFinds[fi];

                // photos array (new) or legacy single
                let refs = [];
                if (Array.isArray(f.photos) && f.photos.length) refs = f.photos.slice();
                else if (f.targetPhotoData || f.photoData) refs = [f.targetPhotoData || f.photoData].filter(Boolean);

                // export only first photo as thumbnail for the card (like your existing gallery),
                // but ALSO include all photos in the Full Photos section.
                let thumbRel = '';
                for (let pi = 0; pi < refs.length; pi++) {
                    const blob = await resolvePhotoRefToBlob(refs[pi]);
                    if (!blob) continue;

                    const ext = extFromMime(blob.type);
                    const fileName = `find_${safeId(f.id)}_${pi + 1}.${ext}`;
                    await writeFile(findsImgDir, fileName, blob);

                    const relPath = `./${folderName}/Finds/${fileName}`;

                    if (!thumbRel) thumbRel = relPath;
                    pushFullSection(`Find: ${f.description || f.vdi || f.id} (photo ${pi + 1})`, relPath);
                }

                findCards.push(`
                  <a class="thumbLink" href="#survey-${safeId(survey.id)}">
                    <div class="card">
                      ${thumbRel ? `<img src="${xmlEscape(thumbRel)}" alt="Find photo">` : `<div class="noimg">No photo</div>`}
                      <div class="cap">
                        <div class="title">${xmlEscape(f.description || (f.vdi ? `VDI ${f.vdi}` : 'Find'))}</div>
                        <div class="metaLine">${xmlEscape(f.type || 'Unknown')} • ${xmlEscape(f.depth || '')}</div>
                      </div>
                    </div>
                  </a>
                `);
            }

            // TARGET cards
            const targets = Array.isArray(survey.targets) ? survey.targets : [];
            if (includeTargets) {
                for (let ti = 0; ti < targets.length; ti++) {
                    const t = targets[ti];

                    let refs = [];
                    if (Array.isArray(t.photos) && t.photos.length) refs = t.photos.slice();
                    else if (t.targetPhotoData || t.photoDataUrl) refs = [t.targetPhotoData || t.photoDataUrl].filter(Boolean);

                    let thumbRel = '';
                    for (let pi = 0; pi < refs.length; pi++) {
                        const blob = await resolvePhotoRefToBlob(refs[pi]);
                        if (!blob) continue;

                        const ext = extFromMime(blob.type);
                        const fileName = `target_${safeId(t.id)}_${pi + 1}.${ext}`;
                        await writeFile(targetsImgDir, fileName, blob);

                        const relPath = `./${folderName}/Targets/${fileName}`;

                        if (!thumbRel) thumbRel = relPath;
                        pushFullSection(`Target: ${t.description || t.vdi || t.id} (photo ${pi + 1})`, relPath);
                    }

                    targetCards.push(`
                      <a class="thumbLink" href="#survey-${safeId(survey.id)}">
                        <div class="card">
                          ${thumbRel ? `<img src="${xmlEscape(thumbRel)}" alt="Target photo">` : `<div class="noimg">No photo</div>`}
                          <div class="cap">
                            <div class="title">${xmlEscape(t.description || (t.vdi ? `VDI ${t.vdi}` : 'Target'))}</div>
                            <div class="metaLine">${xmlEscape(t.type || 'Unknown')} • ${xmlEscape(t.depth || '')}</div>
                          </div>
                        </div>
                      </a>
                    `);
                }
            }

            // ----- Master card thumb (DATA URL so it always shows) -----
            const thumbDataUrl = await getSurveyThumbDataUrl(survey);
            masterCards.push({
                surveyId: survey.id,
                title,
                thumbDataUrl
            });

            // ----- Survey section in the ONE master index -----
            masterSections.push(buildSurveySectionHtml({
                survey,
                folderName,
                surveyHeroRelPath,
                findCardsHtml: findCards.join(''),
                targetCardsHtml: targetCards.join(''),
                fullSectionsHtml: fullSections.join(''),
                includeTargets
            }));
        }

        // ----- Write ONE master index.html -----
        const now = new Date();
        const masterHtml = `
<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>geoFind — Photo Galleries</title>
<style>
  /* Home page hero banner */
.home-hero {
    width: 100%;
    max-height: 28vh;          /* controls banner height */
    overflow: hidden;
    border-radius: 12px;
    margin-bottom: .75rem;
}

.home-hero img {
    width: 100%;
    height: 100%;
    object-fit: cover;         /* crop safely */
    display: block;
}

  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:0;background:#f7f7f7;color:#111}
  header{padding:18px 16px;background:#fff;border-bottom:1px solid #e5e7eb}
  h1{margin:0;font-size:20px}
  .sub{margin:6px 0 0;color:#444;font-size:13px}
  main{padding:16px;max-width:1100px;margin:0 auto}
  .gridTop{display:grid;grid-template-columns:repeat(auto-fit,minmax(220px,1fr));gap:14px;margin-bottom:18px}
  a.cardTop{display:block;text-decoration:none;color:inherit;background:#fff;border:1px solid #e5e7eb;border-radius:14px;overflow:hidden;box-shadow:0 4px 14px rgba(0,0,0,.05)}
  .thumb{aspect-ratio:4/3;background:#eee;display:flex;align-items:center;justify-content:center}
  .thumb img{width:100%;height:100%;object-fit:cover;display:block}
  .meta{padding:10px 12px}
  .title{font-weight:800;font-size:14px;line-height:1.2}
  .hint{font-size:12px;color:#666;margin-top:4px}

  .surveySection{background:#fff;border:1px solid #e5e7eb;border-radius:16px;padding:14px;margin:18px 0;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  .surveyHeaderTop{display:flex;gap:10px;align-items:center;justify-content:space-between;flex-wrap:wrap}
  .surveyTitle{margin:0;font-size:18px}
  .backTop{font-size:12px;color:#111;text-decoration:underline}
  .surveyDesc{margin:8px 0 0;color:#333;font-size:13px}
  .surveyMeta{margin:8px 0 0;color:#555;font-size:12px;display:flex;gap:10px;flex-wrap:wrap}

  .heroWrap{margin-top:12px}
  .heroImg{width:100%;height:auto;border-radius:14px;border:1px solid #e5e7eb}

  h3{margin:18px 0 10px;font-size:14px}
  .grid{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:12px}
  @media (max-width:900px){.grid{grid-template-columns:repeat(2,minmax(0,1fr));}}
  @media (max-width:520px){.grid{grid-template-columns:repeat(2,minmax(0,1fr));}}

  .card{background:#fff;border:1px solid #e5e7eb;border-radius:14px;overflow:hidden}
  .card img{width:100%;height:200px;object-fit:cover;display:block}
  .noimg{height:120px;display:flex;align-items:center;justify-content:center;color:#666;background:#f1f5f9;font-size:12px}
  .cap{padding:10px}
  .metaLine{font-size:12px;color:#333}
  a.thumbLink{text-decoration:none;color:inherit}

  .detail{background:#fff;border:1px solid #e5e7eb;border-radius:14px;padding:14px;margin-top:14px}
  img.full{width:100%;height:auto;border-radius:12px;border:1px solid #e5e7eb}
  .muted{color:#333;font-size:12px;margin:8px 0 0}
  .surveyFooter{margin-top:12px;font-size:12px}
</style>
</head>
<body>
  <a id="top"></a>
  <header>
    <h1>Photo Galleries</h1>
    <p class="sub">Exported ${xmlEscape(now.toLocaleString())} — tap a survey to jump to its gallery (works on Android).</p>
  </header>
  <main>

    <div class="gridTop">
      ${masterCards.map(c => `
        <a class="cardTop" href="#survey-${safeId(c.surveyId)}">
          <div class="thumb">
            ${c.thumbDataUrl
              ? `<img src="${c.thumbDataUrl}" alt="${xmlEscape(c.title)}">`
              : `<div style="padding:12px;color:#666;font-size:12px;text-align:center">No survey photo</div>`
            }
          </div>
          <div class="meta">
            <div class="title">${xmlEscape(c.title)}</div>
            <div class="hint">Open gallery</div>
          </div>
        </a>
      `).join('')}
    </div>

    ${masterSections.join('\n')}

    <p class="muted" style="margin-top:22px;">Generated by geoFind.</p>
  </main>
</body>
</html>`.trim();

        await writeFile(rootPick, 'index.html', new Blob([masterHtml], { type: 'text/html' }));

        log('\nDone. Wrote ONE master index.html (anchor links) plus per-survey image folders.');
        showMessage('All surveys exported (Android-safe master index).', 'success');

    } catch (e) {
        console.error('exportAllSurveysPhotoGalleries_ToFolder error:', e);
        showMessage(`Export all surveys failed: ${e.message || e}`, 'error');
        log(`ERROR: ${e.message || e}`);
    } finally {
        if (btn) {
            btn.disabled = false;
            btn.innerText = originalBtnText || 'Export Photo Gallery to Folder';
        }
    }
}


/**
 * Core exporter: writes ONE survey gallery directly into `galleryDir`.
 * Returns true if it wrote index.html, false if there were no photos.
 */
async function exportSurveyPhotoGallery_NoModal({ survey, galleryDir, includeTargets, maxW, log, showSpinner }) {
    const openSurvey = survey;
    if (!openSurvey) return false;

    const escapeHtml = (s) => String(s ?? '')
        .replace(/&/g, '&amp;')
        .replace(/</g, '&lt;')
        .replace(/>/g, '&gt;')
        .replace(/"/g, '&quot;')
        .replace(/'/g, '&#39;');

    const blobToDataUrl = (blob) => new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onload = () => resolve(reader.result);
        reader.onerror = () => reject(reader.error || new Error('File read failed'));
        reader.readAsDataURL(blob);
    });

    // Gather ALL photo references from all possible fields (deduped)
    const collectPhotoInputs = (obj, kind) => {
        const out = [];
        const add = (v) => {
            if (!v) return;
            if (Array.isArray(v)) {
                v.forEach(add);
                return;
            }
            const s = String(v).trim();
            if (!s) return;
            out.push(s);
        };

        // New/primary fields
        add(obj?.photos);
        add(obj?.photoRefs); // some records may still have this

        // Kind-specific single fields
        if (kind === 'survey') {
            add(obj?.surveyPhotoRef);
            add(obj?.surveyPhotoData);
            add(obj?.surveyPhotoDataUrl);
        } else if (kind === 'find') {
            add(obj?.findPhotoRef);
            add(obj?.findPhotoData);
            add(obj?.findPhotoDataUrl);
            // older/alternate naming you’ve used in places
            add(obj?.photoRef);
            add(obj?.photoData);
            add(obj?.photoDataUrl);
            // very old carry-over (some finds were created from targets)
            add(obj?.targetPhotoRef);
            add(obj?.targetPhotoData);
        } else if (kind === 'target') {
            add(obj?.targetPhotoRef);
            add(obj?.targetPhotoData);
            add(obj?.targetPhotoDataUrl);
            add(obj?.photoRef);
            add(obj?.photoData);
            add(obj?.photoDataUrl);
        }

        // Deduplicate while preserving order
        const seen = new Set();
        const deduped = [];
        for (const x of out) {
            if (seen.has(x)) continue;
            seen.add(x);
            deduped.push(x);
        }
        return deduped;
    };

    async function saveJpg(dirHandle, filenameBase, photoRefOrDataUrl) {
        const rawBlob = await resolvePhotoBlob(photoRefOrDataUrl);
        if (!rawBlob) return null;

        const outBlob = await resizeBlobToMaxWidthJpeg(rawBlob, maxW, 0.85);
        if (!outBlob) return null;

        const fileName = `${filenameBase}.jpg`;
        await writeFileToHandle(dirHandle, fileName, outBlob);
        return outBlob;
    }

    // Create JPG subfolders
    const surveyDir  = await getOrCreateDir(galleryDir, 'Survey');
    const findsDir   = await getOrCreateDir(galleryDir, 'Finds');
    const targetsDir = await getOrCreateDir(galleryDir, 'Targets');

    // Build item list (ONE item per photo)
    const items = [];

    // Survey photo(s)
    const surveyPhotos = collectPhotoInputs(openSurvey, 'survey');
    for (let i = 0; i < surveyPhotos.length; i++) {
        items.push({
            kind: 'survey',
            parentId: openSurvey.id,
            indexInParent: i + 1,
            title: openSurvey.name || 'Survey photo',
            type: 'Survey',
            vdi: '',
            depth: '',
            time: openSurvey.creationDate || openSurvey.dateLastChanged || '',
            coords: '',
            accuracy: '',
            photoRefOrDataUrl: surveyPhotos[i]
        });
    }

    // Finds
    const linkedFinds = (Array.isArray(finds) ? finds : []).filter(f => f.surveyId === openSurvey.id);
    for (const f of linkedFinds) {
        const photoInputs = collectPhotoInputs(f, 'find');
        for (let i = 0; i < photoInputs.length; i++) {
            items.push({
                kind: 'find',
                parentId: f.id,
                indexInParent: i + 1,
                title: f.description || f.name || `Find ${f.id}`,
                type: f.type || '',
                vdi: f.vdi || '',
                depth: f.depth || '',
                time: f.time || f.date || '',
                coords: f.coordinates || '',
                accuracy: f.accuracy || '',
                photoRefOrDataUrl: photoInputs[i]
            });
        }
    }

    // Targets (optional)
    if (includeTargets && Array.isArray(openSurvey.targets)) {
        for (const t of openSurvey.targets) {
            const photoInputs = collectPhotoInputs(t, 'target');
            for (let i = 0; i < photoInputs.length; i++) {
                items.push({
                    kind: 'target',
                    parentId: t.id,
                    indexInParent: i + 1,
                    title: t.description || `Target ${t.id}`,
                    type: t.type || '',
                    vdi: t.vdi || '',
                    depth: t.depth || '',
                    time: t.time || '',
                    coords: t.coordinates || '',
                    accuracy: t.accuracy || '',
                    photoRefOrDataUrl: photoInputs[i]
                });
            }
        }
    }

    if (!items.length) return false;

    log?.(`  Total photos discovered: ${items.length}`);
    showSpinner?.(`Processing 0/${items.length}…`);

    let surveyHeroHtml = '';
    const findCards = [];
    const targetCards = [];
    const sections = [];

    for (let i = 0; i < items.length; i++) {
        const it = items[i];
        const baseName = `${it.kind}_${safeSlug(it.parentId)}_${String(it.indexInParent).padStart(2, '0')}`;
        const anchorId = baseName;

        showSpinner?.(`Processing ${i + 1}/${items.length}…`);

        let dirHandle = findsDir;
        if (it.kind === 'survey') dirHandle = surveyDir;
        else if (it.kind === 'target') dirHandle = targetsDir;

        const outBlob = await saveJpg(dirHandle, baseName, it.photoRefOrDataUrl);
        if (!outBlob) continue;

        const dataUrl = await blobToDataUrl(outBlob);

        if (it.kind === 'survey') {
            // Use first survey photo as hero; additional survey photos go into “Full Photos”
            if (!surveyHeroHtml) {
                surveyHeroHtml = `
                  <div class="surveyHero">
                    <img class="surveyImg" src="${escapeHtml(dataUrl)}" alt="Survey photo">
                  </div>
                `;
            }
        } else {
            const card = `
              <div class="card">
                <a class="thumbLink" href="#${anchorId}">
                  <img src="${escapeHtml(dataUrl)}" alt="${escapeHtml(it.title)}">
                </a>
                <div class="cap">
                  <div class="title">${escapeHtml(it.title)}</div>
                  <div class="metaLine">${escapeHtml(it.vdi)} ${it.type ? '· ' + escapeHtml(it.type) : ''}</div>
                  <div class="metaLine">${escapeHtml(fmtDateTime(it.time))}</div>
                </div>
              </div>
            `;
            if (it.kind === 'find') findCards.push(card);
            else targetCards.push(card);
        }

        sections.push(`
          <div class="detail" id="${anchorId}">
            <p class="back"><a href="#top">↑ Back to top</a></p>
            <h3>${escapeHtml(it.title)}</h3>
            <p class="muted">${escapeHtml(it.kind)} photo ${it.indexInParent}</p>
            <img class="full" src="${escapeHtml(dataUrl)}" alt="${escapeHtml(it.title)}">
            <ul class="meta">
              <li><strong>Type:</strong> ${escapeHtml(it.type)}</li>
              ${it.vdi ? `<li><strong>VDI/ID:</strong> ${escapeHtml(it.vdi)}</li>` : ''}
              ${it.depth ? `<li><strong>Depth:</strong> ${escapeHtml(it.depth)}</li>` : ''}
              ${it.time ? `<li><strong>Date/Time:</strong> ${escapeHtml(fmtDateTime(it.time))}</li>` : ''}
              ${it.coords ? `<li><strong>Coordinates:</strong> ${escapeHtml(it.coords)}</li>` : ''}
              ${it.accuracy ? `<li><strong>Accuracy:</strong> ${escapeHtml(it.accuracy)}</li>` : ''}
              <li><strong>Parent ID:</strong> ${escapeHtml(it.parentId)}</li>
              <li><strong>Photo #:</strong> ${it.indexInParent}</li>
            </ul>
            <hr>
          </div>
        `);
    }

    const surveyInfoHtml = `
      <div class="surveyBox">
        <h1>${escapeHtml(openSurvey.name || 'Unnamed survey')}</h1>
        <p><strong>Description:</strong> ${escapeHtml(openSurvey.description || '')}</p>
        <p><strong>Exported:</strong> ${escapeHtml(new Date().toLocaleString())}</p>
        <p class="muted">index.html is embedded/phone-safe and does not link to the JPG folders.</p>
      </div>
    `;

    const indexHtml = `<!doctype html>
<html>
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1">
<title>geoFind Gallery - ${escapeHtml(openSurvey.name || 'Survey')}</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;margin:18px;color:#111;background:#f8fafc;}
  .wrap{max-width:1200px;margin:0 auto;}
  .surveyBox{background:#fff;border:1px solid #e5e7eb;border-left:6px solid #0ea5e9;border-radius:14px;padding:16px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  h1{margin:0 0 8px 0;font-size:26px}
  h2{margin:22px 0 10px 0}
  h3{margin:8px 0 10px 0}
  .muted{color:#64748b;font-size:14px}

  .surveyHero{background:#fff;border:1px solid #e5e7eb;border-radius:14px;overflow:hidden;box-shadow:0 6px 18px rgba(0,0,0,0.06); margin-top:12px;}
  .surveyImg{width:100%; height:auto; display:block;}

  .grid{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:10px}
  @media (max-width:520px){.grid{grid-template-columns:repeat(2,minmax(0,1fr));}}

  .card{background:#fff;border:1px solid #e5e7eb;border-radius:14px;overflow:hidden;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  .card img{width:100%;height:120px;object-fit:cover;display:block}
  .cap{padding:10px}
  .title{font-weight:800;font-size:14px;margin-bottom:4px}
  .metaLine{font-size:12px;color:#64748b}
  a.thumbLink{text-decoration:none;color:inherit}

  .detail{background:#fff;border:1px solid #e5e7eb;border-radius:14px;padding:14px;margin-top:14px;box-shadow:0 6px 18px rgba(0,0,0,0.06)}
  img.full{width:100%;height:auto;border-radius:12px;border:1px solid #e5e7eb}
  .meta{margin:12px 0 0 0;padding:0;list-style:none}
  .meta li{padding:6px 0;border-bottom:1px solid #f1f5f9}
  .back{margin:0 0 8px 0}
</style>
</head>
<body>
  <a id="top"></a>
  <div class="wrap">
    ${surveyInfoHtml}
    ${surveyHeroHtml}

    <h2>Finds</h2>
    <div class="grid">${findCards.join('')}</div>

    ${includeTargets ? `<h2>Targets</h2><div class="grid">${targetCards.join('')}</div>` : ''}

    <h2>Full Photos</h2>
    ${sections.join('')}

    <p class="muted" style="margin-top:22px;">Generated by geoFind.</p>
  </div>
</body>
</html>`;

    await writeFileToHandle(galleryDir, 'index.html', new Blob([indexHtml], { type: 'text/html' }));
    return true;
}


        /** Exports all data (surveys and profile) to a JSON string and displays it. */
        function exportData() {
            const dataToExport = {
                surveys: surveys,
                profile: userProfile,
                userId: userId,
                exportDate: new Date().toISOString()
            };

            const jsonString = JSON.stringify(dataToExport, null, 2);
            const dataArea = document.getElementById('exported-data-area');
            
            dataArea.value = jsonString;
            dataArea.classList.remove('hidden');
            dataArea.select(); // Select the text for easy copying
            
            // Try to copy to clipboard
            navigator.clipboard.writeText(jsonString).then(() => {
                showMessage('Data copied to clipboard! Paste it safely.', 'success');
            }).catch(err => {
                showMessage('Exported data displayed. Please manually copy the text.', 'warning');
                console.error('Could not copy text: ', err);
            });
        }

        /** Imports data from a JSON string, overwriting existing local storage. */
        function importData() {
            const dataArea = document.getElementById('import-data-area');
            const jsonString = dataArea.value.trim();

            if (!jsonString) {
                return showMessage('Please paste the JSON data into the box.', 'error');
            }

            try {
                const importedData = JSON.parse(jsonString);

                if (!importedData.surveys || !importedData.profile) {
                    throw new Error("Invalid data structure. Missing 'surveys' or 'profile' key.");
                }

                showConfirmationModal(
                    "Confirm Data Import",
                    `Are you sure you want to import data? This will **permanently overwrite** your ${surveys.length} existing local surveys.`,
                    () => {
                        // Overwrite global state
                        // Overwrite global state
                        surveys = importedData.surveys;
                        userProfile = importedData.profile;
                        userId = importedData.userId || generateId(); // Use existing ID or generate a new one

                        // NEW: re-evaluate any active track
                        refreshActiveTrackFromSurveys();

                        saveSurveysToLocalStorage();
                        dataArea.value = ''; // Clear the input area
                        showMessage('Data successfully imported and saved!', 'success');
                        currentPage = 'Home'; // Navigate to home to show new data
                        render();
                    }
                );
            } catch (e) {
                console.error("Import Error:", e);
                showMessage(`Import failed: ${e.message || 'Invalid JSON format.'}`, 'error');
            }
        }

// ------------------------------------------------------
//  SURVEY-LEVEL EXPORT / IMPORT 
// ------------------------------------------------------

/**
 * Build an array of data URLs for a given photo array on a target or find.
 * It understands IndexedDB refs ("idb:123") and legacy direct data URLs.
 */
async function buildPhotoDataUrlsFromRefs(refs, fallbackSingleDataUrl) {
    const result = [];

    if (Array.isArray(refs) && refs.length) {
        for (const ref of refs) {
            if (typeof ref !== 'string' || !ref) continue;

            // New world: IndexedDB reference, e.g. "idb:5"
            if (isIndexedDbPhotoRef(ref)) {
                const id = parsePhotoRef(ref);
                if (id != null) {
                    const blob = await loadPhotoBlob(id);
                    if (blob) {
                        const dataUrl = await blobToDataUrl(blob);
                        if (dataUrl) result.push(dataUrl);
                    }
                }
            } else if (ref.startsWith('data:image/')) {
                // Legacy: direct base64 data URL
                result.push(ref);
            }
        }
    }

    // If nothing came from refs, fall back to a single stored thumbnail
    if (!result.length && fallbackSingleDataUrl && typeof fallbackSingleDataUrl === 'string') {
        result.push(fallbackSingleDataUrl);
    }

    return result;
}

function showExportConfirmModal(onConfirmCallback) {
    showConfirmationModal(
        "Export survey",
        "Export the open survey as a <strong>.zip package</strong> including photos?<br><br>" +
        "This is the recommended format for backups and moving surveys between devices.",
        onConfirmCallback
    );
}

function showImportConfirmModal(filename, onConfirmCallback) {
    showConfirmationModal(
        "Import survey",
        `Import survey from file "<strong>${filename}</strong>"?<br><br>` +
        `This will add the survey and its finds  to your local data.`,
        onConfirmCallback
    );
}


/* ============================
   Survey Report (PDF) export
   ============================ */

/** Convert a Blob to a data: URL (safe for printing). */
function blobToDataUrl(blob) {
    return new Promise((resolve, reject) => {
        try {
            const reader = new FileReader();
            reader.onload = () => resolve(String(reader.result || ''));
            reader.onerror = () => reject(reader.error || new Error('Failed to read blob.'));
            reader.readAsDataURL(blob);
        } catch (err) {
            reject(err);
        }
    });
}

/** Get open survey (returns null if none). */
function getOpenSurveyOrNull() {
    const all = Array.isArray(surveys) ? surveys : [];
    return all.find(s => s && s.status === 'Open') || null;
}

/** Permission dates are stored as dd/mm/yy strings; show them as-is if already in that format. */
function safePermissionDateDisplay(v) {
    if (!v) return '';
    // If app already has a formatter for permission dates, prefer it.
    if (typeof formatSurveyPermissionDate === 'function') {
        try { return formatSurveyPermissionDate(v); } catch (_) { /* fall through */ }
    }
    return String(v);
}

/** Returns an array of survey photo refs in display order. Supports both multi-photo surveys and legacy single photo. */
function getSurveyPhotoRefs(survey) {
    const refs = [];
    if (survey) {
        if (Array.isArray(survey.photos)) {
            for (const r of survey.photos) if (r) refs.push(r);
        }
        // Legacy fallback
        if (refs.length === 0 && survey.surveyPhotoRef) refs.push(survey.surveyPhotoRef);
        if (refs.length === 0 && survey.photoRef) refs.push(survey.photoRef);
    }
    return refs;
}

/** Build the report HTML string (images are injected separately once available). */
function buildSurveyReportHtml({detectoristName, surveyName, generatedStr, appVersionStr, detailsRowsHtml, summaryRowHtml, findsRowsHtml, surveyPhotosHtml, findsPerFindPagesHtml, notesText }) {
    return `<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Survey Report - ${surveyName ? surveyName.replace(/</g,'&lt;') : ''}</title>
<style>
    body { font-family: Arial, Helvetica, sans-serif; margin: 28px; color: #111; }
    h1,h2,h3 { margin: 0; }
    .muted { color: #555; font-size: 12px; }
    .header { display: flex; justify-content: space-between; align-items: flex-start; gap: 12px; }
    .brand { font-size: 18px; font-weight: 700; }
    .report-title { font-size: 20px; font-weight: 700; margin-top: 2px; }
    .title-block { margin-top: 14px; padding-bottom: 10px; border-bottom: 1px solid #ddd; }
    .detectorist { font-size: 14px; font-weight: 700; margin-bottom: 6px; }
    .survey-title { font-size: 18px; font-weight: 700; }
    table { width: 100%; border-collapse: collapse; margin-top: 14px; }
    th, td { border: 1px solid #ddd; padding: 8px; vertical-align: top; }
    th { background: #f5f5f5; text-align: left; }
    .section { margin-top: 18px; page-break-inside: avoid; }
    .section-title { font-size: 14px; font-weight: 700; margin-bottom: 6px; }
    .summary-table th, .summary-table td { text-align: center; }
    .photos { display: grid; grid-template-columns: 1fr 1fr; gap: 6px; margin-top: 10px; width: 100%; }
    .photo { border: 0; padding: 2px; margin: 0; }
    .photo img { width: 100%; height: auto; display: block; }
    .find-page { page-break-before: always; margin-top: 18px; }
    .find-page.first { page-break-before: auto; }
    .find-header { font-size: 14px; font-weight: 700; margin-bottom: 8px; }
    .find-details { font-size: 12px; line-height: 1.35; margin-bottom: 10px; }
    .find-details .row { margin: 2px 0; }
    @media print { body { margin: 0; } .photo { border: 0; } }
    @page { margin: 10mm; }

    .photo figcaption { font-size: 11px; color: #555; margin-top: 4px; line-height: 1.2; }
    .notes { white-space: pre-wrap; border: 1px solid #ddd; padding: 10px; }
    .footer { margin-top: 22px; padding-top: 10px; border-top: 1px solid #ddd; font-size: 11px; color: #555; }
    @media print { body { margin: 16mm; } }
</style>
</head>
<body>
    <div class="header">
        <div>
            <div class="brand">DETETKA – Metal Detecting App</div>
            <div class="report-title">Survey Report</div>
        </div>
        <div class="muted" style="text-align:right">
            <div>Generated: ${generatedStr}</div>
            <div>App version: ${appVersionStr}</div>
        </div>
    </div>

    <div class="title-block">
        <div class="detectorist">Detectorist: ${detectoristName ? detectoristName.replace(/</g,'&lt;') : ''}</div>
        <div class="survey-title">Survey: ${surveyName ? surveyName.replace(/</g,'&lt;') : ''}</div>
    </div>

    <div class="section">
        <div class="section-title">Survey Details</div>
        <table>
            <tbody>
                ${detailsRowsHtml}
            </tbody>
        </table>
    </div>

    <div class="section">
        <div class="section-title">Survey Summary</div>
        <table class="summary-table">
            <thead>
                <tr>
                    <th>Targets</th><th>Finds</th><th>Stakes</th><th>Tracks</th><th>Photos</th>
                </tr>
            </thead>
            <tbody>
                ${summaryRowHtml}
            </tbody>
        </table>
    </div>

    <div class="section">
        <div class="section-title">Finds Recorded</div>
        <table>
            <thead>
                <tr><th style="width:25%">Type</th><th style="width:15%">VDI</th><th>Description</th></tr>
            </thead>
            <tbody>
                ${findsRowsHtml}
            </tbody>
        </table>
    </div>

    <div class="section">
        <div class="section-title">Survey Photos</div>
        ${surveyPhotosHtml}
    </div>

    <div class="section">
        <div class="section-title">Finds Photos</div>
        ${findsPerFindPagesHtml}
    </div>

    <div class="section">
        <div class="section-title">Additional Notes</div>
        <div class="notes">${(notesText || '').replace(/</g,'&lt;')}</div>
    </div>

    <div class="footer">
        Generated by Detekta – Metal Detecting App
    </div>
</body>
</html>`;
}

/** Export a printable Survey Report using the browser's Print dialog (Save as PDF). */
async function exportSurveyReportPdf() {
    const logEl = document.getElementById('export-survey-report-log');
    const log = (msg) => { if (logEl) { logEl.value += msg + "\\n"; logEl.scrollTop = logEl.scrollHeight; } };

    try {
        if (logEl) logEl.value = '';
        log('Preparing report...');

        const survey = getOpenSurveyOrNull();
        if (!survey) {
            log('No open survey found. Open a survey first.');
            showMessage('No open survey is open.', 'warning');
            return;
        }

        const detectoristName = (userProfile && userProfile.name) ? String(userProfile.name) : '';
        const appVersionStr = (typeof APP_VERSION !== 'undefined' && APP_VERSION) ? String(APP_VERSION) : (typeof appVersion !== 'undefined' && appVersion ? String(appVersion) : '');
        const now = new Date();
        const generatedStr = (typeof formatDate === 'function') ? formatDate(now) : now.toLocaleDateString();

        // Survey details (v1 layout)
        const detailPairs = [];
        detailPairs.push(['Survey name', survey.name || '']);
        detailPairs.push(['Location / notes', survey.description || survey.location || '']);
        detailPairs.push(['Permission from', survey.permissionFrom || '']);
        detailPairs.push(['Permission granted', safePermissionDateDisplay(survey.permissionDate || survey.permissionGranted || '')]);
        detailPairs.push(['Permission expires', safePermissionDateDisplay(survey.permissionExpiry || survey.permissionReview || '')]);
        detailPairs.push(['Site type', survey.siteType || '']);
        detailPairs.push(['Soil condition', survey.soilCondition || '']);
        detailPairs.push(['Detector(s) used', survey.detector || '']);
        detailPairs.push(['NCMD number', (userProfile && userProfile.ncmdNumber) ? String(userProfile.ncmdNumber) : '']);

        const detailsRowsHtml = detailPairs
            .filter(([_, v]) => v !== null && v !== undefined && String(v).trim() !== '')
            .map(([k, v]) => `<tr><th>${String(k).replace(/</g,'&lt;')}</th><td>${String(v).replace(/</g,'&lt;')}</td></tr>`)
            .join('');

        // Summary counts
        const targetsCount = (typeof getSurveyTargetsOnly === 'function') ? getSurveyTargetsOnly(survey).length : (Array.isArray(survey.targets) ? survey.targets.length : 0);
        const stakesCount  = (typeof getSurveyStakesOnly === 'function') ? getSurveyStakesOnly(survey).length : (Array.isArray(survey.stakes) ? survey.stakes.length : 0);
        const surveyFinds  = Array.isArray(finds) ? finds.filter(f => f && !f.deleted && f.surveyId === survey.id) : [];
        const findsCount   = surveyFinds.length;
        const tracksCount  = Array.isArray(survey.tracks) ? survey.tracks.length : 0;

        const photoRefs = getSurveyPhotoRefs(survey);
        const photosCount = photoRefs.length;

        const summaryRowHtml = `<tr><td>${targetsCount}</td><td>${findsCount}</td><td>${stakesCount}</td><td>${tracksCount}</td><td>${photosCount}</td></tr>`;

        // Finds rows
        const findsRowsHtml = (surveyFinds.length === 0)
            ? `<tr><td colspan="3" class="muted">No finds recorded.</td></tr>`
            : surveyFinds.map(f => {
                const type = f.findType || f.type || f.category || 'Find';
                const vdi  = (f.vdi !== undefined && f.vdi !== null && String(f.vdi).trim() !== '') ? String(f.vdi) : (f.targetId || '');
                const desc = f.notes || f.description || '';

                const parts = [];
                if (desc) parts.push(desc);
                if (f.identification) parts.push(`Identification: ${f.identification}`);
                if (f.material) parts.push(`Material: ${f.material}`);
                if (f.condition) parts.push(`Condition: ${f.condition}`);
                if (f.period) parts.push(`Period: ${f.period}`);
                if (f.weightG) parts.push(`Weight: ${f.weightG} g`);
                if (f.dimensionsMm) parts.push(`Size: ${f.dimensionsMm}`);
                if (f.whereKept) parts.push(`Where kept: ${f.whereKept}`);
                if (f.possibleTreasure) parts.push(`Possible treasure: Yes`);
                if (f.disposition) parts.push(`Disposition: ${f.disposition}`);

                const descHtml = parts.map(p => String(p).replace(/</g,'&lt;')).join('<br>');

                return `<tr><td>${String(type).replace(/</g,'&lt;')}</td><td>${String(vdi).replace(/</g,'&lt;')}</td><td>${descHtml}</td></tr>`;
            }).join('');

        // Photos: load and embed as data URLs (safer for printing)
        let surveyPhotosHtml = '<div class="muted">No survey photos.</div>';
        if (photoRefs.length > 0 && typeof loadPhotoBlob === 'function' && typeof parsePhotoRef === 'function') {
            log(`Loading ${photoRefs.length} survey photo(s)...`);
            const dataUrls = [];
            for (const ref of photoRefs) {
                try {
                    const parsed = parsePhotoRef(ref);
                    const blob = await loadPhotoBlob(parsed);
                    if (!blob) continue;

                    const dataUrl = await new Promise((resolve, reject) => {
                        const reader = new FileReader();
                        reader.onload = () => resolve(reader.result);
                        reader.onerror = reject;
                        reader.readAsDataURL(blob);
                    });

                    if (typeof dataUrl === 'string' && dataUrl.startsWith('data:')) {
                        dataUrls.push(dataUrl);
                    }
                } catch (e) {
                    log('A survey photo could not be loaded (skipped).');
                }
            }
            if (dataUrls.length > 0) {
                surveyPhotosHtml = `<div class="photos">` +
                    dataUrls.map(u => `<div class="photo"><img src="${u}" alt=""></div>`).join('') +
                    `</div>`;
            } else {
                surveyPhotosHtml = '<div class="muted">No survey photos could be loaded.</div>';
            }
        }

        // Finds photos (optional)
        let findsPerFindPagesHtml = '<div class="muted">No finds recorded.</div>';

        const collectPhotoRefs = (obj) => {
            const out = [];
            if (!obj || typeof obj !== 'object') return out;

            const candidates = [
                obj.photos, obj.findPhotos, obj.findPhotoRefs, obj.photoRefs, obj.images, obj.imageRefs,
                obj.findPhotoRef, obj.photoRef, obj.photo, obj.image
            ];

            for (const c of candidates) {
                if (!c) continue;
                if (Array.isArray(c)) {
                    for (const v of c) if (typeof v === 'string' && v.trim()) out.push(v.trim());
                } else if (typeof c === 'string' && c.trim()) {
                    out.push(c.trim());
                }
            }

            // Fallback: scan object values for likely refs
            for (const [k, v] of Object.entries(obj)) {
                if (!v) continue;
                const key = String(k || '').toLowerCase();
                if (!(key.includes('photo') || key.includes('image'))) continue;

                if (typeof v === 'string') {
                    const s = v.trim();
                    if (!s) continue;
                    if (typeof parsePhotoRef === 'function') {
                        try { parsePhotoRef(s); out.push(s); } catch(e) {}
                    } else if (s.includes('|') || s.includes(':')) {
                        out.push(s);
                    }
                } else if (Array.isArray(v)) {
                    for (const it of v) {
                        if (typeof it !== 'string') continue;
                        const s = it.trim();
                        if (!s) continue;
                        if (typeof parsePhotoRef === 'function') {
                            try { parsePhotoRef(s); out.push(s); } catch(e) {}
                        } else if (s.includes('|') || s.includes(':')) {
                            out.push(s);
                        }
                    }
                }
            }

            // Deduplicate
            return Array.from(new Set(out));
        };

        // Build per-find pages: each find starts on a new page, details once at the top,
        // then photos printed below in rows (2 per row).
        if (surveyFinds.length > 0) {
            const pages = [];

            for (let i = 0; i < surveyFinds.length; i++) {
                const f = surveyFinds[i];

                const type = (f.findType || f.type || f.category || 'Find');
                const vdi  = (f.vdi ?? f.targetId ?? f.targetID ?? f.targetIdValue ?? '').toString();
                const desc = (f.description ?? f.notes ?? '').toString();

                const lines = [];
                const addLine = (label, value) => {
                    if (value === undefined || value === null) return;
                    const s = String(value).trim();
                    if (!s) return;
                    lines.push(`<div class="row"><strong>${escapeHtml(label)}:</strong> ${escapeHtml(s)}</div>`);
                };

                addLine('Type', type);
                addLine('VDI', vdi);

                // New fields (object-focused)
                addLine('Identification', f.identification);
                addLine('Material', f.material);
                addLine('Condition', f.condition);
                addLine('Period / Date', f.period);
                addLine('Weight (g)', f.weightG);
                addLine('Dimensions (mm)', f.dimensionsMm);
                addLine('Where kept', f.whereKept);
                if (f.possibleTreasure) {
                    lines.push(`<div class="row"><strong>Possible treasure:</strong> Yes</div>`);
                }
                addLine('Disposition', f.disposition);

                // Existing context fields
                addLine('Depth', (f.depth !== undefined && f.depth !== null) ? f.depth : '');
                if (f.lat !== undefined && f.lon !== undefined) {
                    addLine('Coordinates', `${f.lat}, ${f.lon}`);
                } else if (f.coordinates) {
                    addLine('Coordinates', f.coordinates);
                }
                addLine('Accuracy', f.accuracy);

                if (desc && desc.trim()) addLine('Description', desc);

                // Photos (load and embed as data URLs)
                let photosHtml = '<div class="muted">No photos for this find.</div>';
                const refs = collectPhotoRefs(f);

                if (refs.length > 0 && typeof loadPhotoBlob === 'function' && typeof parsePhotoRef === 'function') {
                    const figures = [];
                    for (let p = 0; p < refs.length; p++) {
                        const ref = refs[p];
                        try {
                            const parsed = parsePhotoRef(ref);
                            const blob = await loadPhotoBlob(parsed);
                            if (!blob) continue;

                            const dataUrl = await new Promise((resolve, reject) => {
                                const reader = new FileReader();
                                reader.onload = () => resolve(reader.result);
                                reader.onerror = reject;
                                reader.readAsDataURL(blob);
                            });

                            figures.push(
                                `<figure class="photo">` +
                                `<img src="${dataUrl}" alt="">` +
                                `<figcaption>Photo ${p + 1}</figcaption>` +
                                `</figure>`
                            );
                        } catch (e) {
                            log('A find photo could not be loaded (skipped).');
                        }
                    }
                    if (figures.length > 0) {
                        photosHtml = `<div class="photos">` + figures.join('') + `</div>`;
                    }
                } else if (refs.length > 0) {
                    // If photo loader isn't available, at least indicate there are photos
                    photosHtml = `<div class="muted">${refs.length} photo(s) recorded for this find (not available to embed).</div>`;
                }

                const header = `${escapeHtml(type)}${(f.identification && String(f.identification).trim()) ? ' – ' + escapeHtml(String(f.identification).trim()) : ''}`;

                pages.push(
                    `<div class="find-page ${i === 0 ? 'first' : ''}">` +
                    `<div class="find-header">${header}</div>` +
                    `<div class="find-details">${lines.join('')}</div>` +
                    `${photosHtml}` +
                    `</div>`
                );
            }

            findsPerFindPagesHtml = pages.join('');
        }

        const notesText = survey.description || survey.location || '';

        const reportHtml = buildSurveyReportHtml({
            detectoristName,
            surveyName: survey.name || '',
            generatedStr,
            appVersionStr,
            detailsRowsHtml,
            summaryRowHtml,
            findsRowsHtml,
            surveyPhotosHtml,
            findsPerFindPagesHtml,
            notesText
        });

        log('Opening report...');
        const w = window.open('', '_blank');
        if (!w) {
            log('Popup blocked. Please allow popups for this site and try again.');
            showMessage('Popup blocked. Allow popups then try again.', 'warning');
            return;
        }

        w.document.open();
        w.document.write(reportHtml);
        w.document.close();

        // Wait a moment for images to render, then print
        w.onload = () => {
            try {
                w.focus();
                w.print();
                log('Print dialog opened (choose “Save as PDF”).');
            } catch (e) {
                log('Could not open print dialog.');
            }
        };

        showMessage('Survey report opened. Use Print → Save as PDF.', 'success');
    } catch (err) {
        console.error(err);
        if (document.getElementById('export-survey-report-log')) {
            document.getElementById('export-survey-report-log').value += `ERROR: ${err && err.message ? err.message : err}\\n`;
        }
        showMessage('Survey report export failed. See log.', 'error');
    }
}


function exportOpenSurveyWithPhotos() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('No open survey to export.', 'error');
        return;
    }

    showExportConfirmModal(() => {
        actuallyExportOpenSurvey(); // we keep the function name to avoid changing your button wiring
    });
}

async function actuallyExportOpenSurvey() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('No open survey to export.', 'error');
        return;
    }

    if (typeof JSZip === 'undefined') {
        showMessage('ZIP export needs JSZip. Add the JSZip <script> tag first.', 'error');
        return;
    }

    const btn    = document.getElementById('export-open-survey-with-photos-btn');
    const logBox = document.getElementById('export-open-survey-log');

    const log = (msg) => {
        if (!logBox) return;
        logBox.value += msg + '\n';
        logBox.scrollTop = logBox.scrollHeight;
    };

    if (logBox) logBox.value = '';

    let originalBtnText = '';
    if (btn) {
        originalBtnText = btn.innerText;
        btn.disabled = true;
        btn.innerText = 'Exporting ZIP...';
    }

    const safeName = (openSurvey.name || 'survey')
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, '-')
        .replace(/^-+|-+$/g, '')
        || 'survey';

    const timestamp = new Date()
        .toISOString()
        .replace(/[:.]/g, '')
        .replace('T', '_')
        .replace('Z', '');

    const extFromMime = (mime) => {
        const m = String(mime || '').toLowerCase();
        if (m.includes('jpeg') || m.includes('jpg')) return 'jpg';
        if (m.includes('png')) return 'png';
        if (m.includes('webp')) return 'webp';
        if (m.includes('gif')) return 'gif';
        return 'bin';
    };

    const loadBlobFromRef = async (ref) => {
        const id = parsePhotoRef(ref);
        if (id == null) return null;
        return await loadPhotoBlob(id);
    };

    try {
        showProgressOverlay('Exporting ZIP', 'Packaging survey + photos…');
        updateProgressOverlay(1, 'Preparing data…');

        log(`Starting ZIP export for survey: ${openSurvey.name || 'Unnamed survey'}`);

        // Deep copy (no mutation of live data)
        const surveyCopy = JSON.parse(JSON.stringify(openSurvey));
        // IMPORTANT: Do not export deleted targets/stakes.
        // Deleted entries can still have photos attached (useful for audit), but they should not be part of a survey backup/share ZIP.
        if (surveyCopy && Array.isArray(surveyCopy.targets)) {
            surveyCopy.targets = surveyCopy.targets.filter(t => !(t && t.deleted === true));
        }
        const linkedFinds = (Array.isArray(finds) ? finds : []).filter(f => f && f.surveyId === openSurvey.id);
        const findsCopy   = linkedFinds.map(f => JSON.parse(JSON.stringify(f)));

        // Ensure newly added Survey + Find fields exist in the exported JSON (even if blank),
        // so older data exports still round-trip cleanly when importing later.
        const ensureKey = (obj, key, defaultValue) => {
            if (!obj || typeof obj !== 'object') return;
            if (!(key in obj)) obj[key] = defaultValue;
        };

        const normalizeSurveyForExport = (s) => {
            if (!s || typeof s !== 'object') return s;

            // Survey Details fields (optional) - keep as blank/defaults if missing
            ensureKey(s, 'permissionFrom', '');
            ensureKey(s, 'permissionType', '');
            ensureKey(s, 'permissionDateGranted', '');
            ensureKey(s, 'permissionExpiry', '');
            ensureKey(s, 'permissionNotes', '');

            ensureKey(s, 'areaType', '');
            ensureKey(s, 'landUseCurrent', '');

            ensureKey(s, 'soilType', '');
            ensureKey(s, 'groundCondition', '');
            ensureKey(s, 'mineralisationLevel', '');

            ensureKey(s, 'weather', '');
            ensureKey(s, 'recentRain', '');
            ensureKey(s, 'temperature', '');

            ensureKey(s, 'purpose', []);              // multi-select array
            ensureKey(s, 'expectedPeriod', '');

            ensureKey(s, 'accessNotes', '');
            ensureKey(s, 'hazards', []);              // multi-select array

            ensureKey(s, 'overallProductivity', '');
            ensureKey(s, 'wouldDetectAgain', '');
            ensureKey(s, 'surveyObservations', '');

            return s;
        };

        const normalizeFindForExport = (f) => {
            if (!f || typeof f !== 'object') return f;

            // New Find fields (object-focused)
            ensureKey(f, 'identification', '');
            ensureKey(f, 'material', '');
            ensureKey(f, 'condition', '');
            ensureKey(f, 'period', '');
            ensureKey(f, 'weightG', '');
            ensureKey(f, 'dimensionsMm', '');
            ensureKey(f, 'whereKept', '');
            ensureKey(f, 'possibleTreasure', false);
            ensureKey(f, 'disposition', '');

            return f;
        };

        normalizeSurveyForExport(surveyCopy);
        findsCopy.forEach(normalizeFindForExport);


        const cleanEntityForExport = (obj) => {
            if (!obj || typeof obj !== 'object') return obj;
            const o = JSON.parse(JSON.stringify(obj));
            delete o.photoDataUrl;
            delete o.targetPhotoData;
            delete o.surveyPhotoData;
            delete o.exportPhotosDataUrls;
            delete o.exportSurveyPhotoDataUrl;
            return o;
        };

        const payload = {
            version: 'geoFind-survey-zip-v2',
            exportedAt: new Date().toISOString(),
            profile: userProfile,
            survey: cleanEntityForExport(surveyCopy),
            finds: findsCopy.map(cleanEntityForExport)
        };

        const zip = new JSZip();
        const photosFolder  = zip.folder('photos');
        const surveyFolder  = photosFolder.folder('survey');
        const targetsFolder = photosFolder.folder('targets');
        const findsFolder   = photosFolder.folder('finds');

        // Compute total photo refs up front (for progress)
        const refsToExport = [];

        // Survey photos (supports multi-photo surveys)
if (payload.survey) {
    const surveyRefs = Array.isArray(payload.survey.photos) && payload.survey.photos.length
        ? payload.survey.photos
        : (payload.survey.surveyPhotoRef ? [payload.survey.surveyPhotoRef] : []);
    for (const ref of surveyRefs) {
        refsToExport.push({ kind: 'survey', owner: payload.survey, ref });
    }
}

        // Targets photos
        if (!Array.isArray(payload.survey.targets)) payload.survey.targets = [];
        for (const t of payload.survey.targets) {
            const refs = Array.isArray(t.photos) && t.photos.length
                ? t.photos
                : (t.targetPhotoRef ? [t.targetPhotoRef] : []);
            for (const ref of refs) refsToExport.push({ kind: 'target', owner: t, ref });
        }

        // Finds photos
        for (const f of payload.finds) {
            const refs = Array.isArray(f.photos) && f.photos.length
                ? f.photos
                : (f.findPhotoRef ? [f.findPhotoRef] : []);
            for (const ref of refs) refsToExport.push({ kind: 'find', owner: f, ref });
        }

        const totalPhotos = refsToExport.length;
        let donePhotos = 0;

        // Prepare photoFiles arrays
        payload.survey.photoFiles = [];

        for (const t of payload.survey.targets) t.photoFiles = [];
        for (const f of payload.finds) f.photoFiles = [];

        // Export photos one-by-one (bounded memory)
        for (const item of refsToExport) {
            donePhotos++;

            const base = 5;          // start percent for photo pass
            const span = 75;         // photo pass occupies 75% of bar
            const pct = totalPhotos ? base + (donePhotos / totalPhotos) * span : base + span;

            updateProgressOverlay(
                pct,
                `Adding photos ${donePhotos}/${totalPhotos}…`
            );

            const blob = await loadBlobFromRef(item.ref);
            if (!blob) continue;

            const ext = extFromMime(blob.type);

            if (item.kind === 'survey') {
    const sid = String(payload.survey.id ?? 'survey').replace(/[^\w-]/g, '');
    const idx = (payload.survey.photoFiles.length + 1);
    const filename = `${sid}_${idx}.${ext}`;
    surveyFolder.file(filename, blob);
    payload.survey.photoFiles.push(`photos/survey/${filename}`);
}

            if (item.kind === 'target') {
                const t = item.owner;
                const tid = (t.id || `target_${Math.random().toString(16).slice(2)}`).replace(/[^\w-]/g, '');
                const idx = (t.photoFiles.length + 1);
                const filename = `${tid}_${idx}.${ext}`;
                targetsFolder.file(filename, blob);
                t.photoFiles.push(`photos/targets/${filename}`);
            }

            if (item.kind === 'find') {
                const f = item.owner;
                const fid = (f.id || `find_${Math.random().toString(16).slice(2)}`).replace(/[^\w-]/g, '');
                const idx = (f.photoFiles.length + 1);
                const filename = `${fid}_${idx}.${ext}`;
                findsFolder.file(filename, blob);
                f.photoFiles.push(`photos/finds/${filename}`);
            }
        }

        // Strip photo refs from export objects (we recreate them on import)
        delete payload.survey.photos;
        delete payload.survey.surveyPhotoRef;
        delete payload.survey.surveyPhotoData;

        for (const t of payload.survey.targets) {
            delete t.photos;
            delete t.targetPhotoRef;
            delete t.targetPhotoData;
        }
        for (const f of payload.finds) {
            delete f.photos;
            delete f.findPhotoRef;
            delete f.targetPhotoData;
        }

        updateProgressOverlay(82, 'Writing survey.json…');
        zip.file('survey.json', JSON.stringify(payload, null, 2));

        log(`Targets: ${payload.survey.targets.length}`);
        log(`Linked finds: ${payload.finds.length}`);
        log(`Photos included: ${totalPhotos}`);

        updateProgressOverlay(86, 'Compressing ZIP…');

        const zipBlob = await zip.generateAsync(
            { type: 'blob', compression: 'DEFLATE', compressionOptions: { level: 6 } },
            (meta) => {
                // meta.percent goes 0..100 for compression stage
                // map it into the last ~14% of the overlay
                const p = 86 + (meta.percent * 0.14);
                updateProgressOverlay(p, `Compressing… ${Math.round(meta.percent)}%`);
            }
        );

        updateProgressOverlay(99, 'Saving file…');

        const filename = `geoFind_${safeName}_${timestamp}.zip`;
        const url = URL.createObjectURL(zipBlob);

        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);

        setTimeout(() => URL.revokeObjectURL(url), 2000);

        updateProgressOverlay(100, 'Done.');
        setTimeout(() => hideProgressOverlay(), 400);

        log(`Export complete. "${filename}" saved to Downloads.`);
        showMessage('Survey export completed (ZIP with photos).', 'success');

    } catch (e) {
        console.error('Error exporting open survey ZIP:', e);
        log(`ERROR: ${e.message || 'Unknown error'}`);
        showMessage(`Could not export open survey: ${e.message || 'Unknown error'}`, 'error');
        hideProgressOverlay();
    } finally {
        if (btn) {
            btn.disabled = false;
            btn.innerText = originalBtnText || 'Export Open Survey';
        }
    }
}

        
    /**
 * Internal worker to import a survey JSON string  and add it
 * to existing data. Uses a log function to report progress.
 */
async function performSurveyImport(text, filename, log) {
    let payload;

    log(`Parsing "${filename}"...`);
    try {
        payload = JSON.parse(text);
    } catch (e) {
        console.error('Survey import JSON parse error:', e);
        log(`ERROR: Invalid JSON (${e.message})`);
        showMessage(`Import failed: invalid JSON (${e.message})`, 'error');
        return;
    }

    if (!payload || !payload.survey) {
        log('ERROR: This JSON does not look like a survey export.');
        showMessage('Import failed: this JSON does not look like a survey export.', 'error');
        return;
    }

    let importedSurvey = payload.survey;
    let importedFinds  = Array.isArray(payload.finds) ? payload.finds : [];


    // Backwards/forwards compatibility: ensure newly added Survey fields exist (blank if missing)
    const _surveyFieldDefaults = {
        permissionFrom: '',
        permissionType: '',
        permissionDateGranted: '',
        permissionExpiry: '',
        permissionNotes: '',
        areaType: '',
        landUseCurrent: '',
        soilType: '',
        groundCondition: '',
        recentRain: '',
        weather: '',
        mineralisationLevel: ''
    };
    for (const [k, v] of Object.entries(_surveyFieldDefaults)) {
        if (importedSurvey[k] === undefined) importedSurvey[k] = v;
    }

    // Backwards/forwards compatibility: ensure newly added Find fields exist (blank/default if missing)
    const _findFieldDefaults = {
        identification: '',
        material: '',
        condition: '',
        period: '',
        weightG: '',
        dimensionsMm: '',
        whereKept: '',
        possibleTreasure: false,
        disposition: ''
    };
    for (const f of importedFinds) {
        if (!f || typeof f !== 'object') continue;
        for (const [k, v] of Object.entries(_findFieldDefaults)) {
            if (f[k] === undefined) f[k] = v;
        }
        // Coerce boolean if older exports stored strings
        if (typeof f.possibleTreasure !== 'boolean') {
            f.possibleTreasure = String(f.possibleTreasure).toLowerCase() === 'true';
        }
    }
    try {
        // Ensure survey has an id
        if (!importedSurvey.id) {
            importedSurvey.id = generateId();
        }

        log('Restoring survey photo(s)...');
// New multi-photo export: exportSurveyPhotoDataUrls (array)
// Legacy export: exportSurveyPhotoDataUrl (single)
if (Array.isArray(importedSurvey.exportSurveyPhotoDataUrls) && importedSurvey.exportSurveyPhotoDataUrls.length) {
    const refs = await saveDataUrlsAsPhotoRefs(importedSurvey.exportSurveyPhotoDataUrls);
    importedSurvey.photos          = refs.filter(Boolean);
    importedSurvey.surveyPhotoRef  = importedSurvey.photos[0] || '';
    importedSurvey.surveyPhotoData = '';
    delete importedSurvey.exportSurveyPhotoDataUrls;
} else if (importedSurvey.exportSurveyPhotoDataUrl) {
    const refs = await saveDataUrlsAsPhotoRefs([importedSurvey.exportSurveyPhotoDataUrl]);
    importedSurvey.photos          = refs.filter(Boolean);
    importedSurvey.surveyPhotoRef  = importedSurvey.photos[0] || '';
    importedSurvey.surveyPhotoData = refs.length > 0 ? '' : importedSurvey.exportSurveyPhotoDataUrl;
    delete importedSurvey.exportSurveyPhotoDataUrl;
} else if (importedSurvey.surveyPhotoRef) {
    importedSurvey.photos = [importedSurvey.surveyPhotoRef];
} else if (!Array.isArray(importedSurvey.photos)) {
    importedSurvey.photos = [];
}

// 2) Targets: convert exportPhotosDataUrls -> IndexedDB refs
        if (!Array.isArray(importedSurvey.targets)) {
            importedSurvey.targets = [];
        }
// Ensure tracks exist and are well-formed (backwards compatible)
if (!Array.isArray(importedSurvey.tracks)) importedSurvey.tracks = [];
for (const tr of importedSurvey.tracks) {
    if (!tr) continue;
    if (!tr.id) tr.id = generateId();
    tr.name = String(tr.name || 'Track');
    tr.description = String(tr.description || '');
    if (tr.isVisible === undefined) tr.isVisible = true;
    if (!tr.color) tr.color = pickTrackColor(0); // only if missing; won’t override existing colours
    if (!Array.isArray(tr.points)) tr.points = [];
}

        log(`Restoring ${importedSurvey.targets.length} targets...`);
        let tIndex = 0;
        for (const t of importedSurvey.targets) {
            tIndex++;
            log(`  Target ${tIndex}/${importedSurvey.targets.length}: ${t.description || t.id || ''}`);

            const dataUrls = Array.isArray(t.exportPhotosDataUrls) ? t.exportPhotosDataUrls : [];
            let refs = [];

            if (dataUrls.length) {
                refs = await saveDataUrlsAsPhotoRefs(dataUrls);
            }

            t.photos         = refs;
            t.targetPhotoRef = refs[0] || '';
            t.targetPhotoData = refs.length > 0 ? '' : (dataUrls[0] || '');
            delete t.exportPhotosDataUrls;

            if (!t.id) {
                t.id = generateId();
            }
        }

        // 3) Finds: convert exportPhotosDataUrls -> IndexedDB refs
        log(`Restoring ${importedFinds.length} finds...`);
        let fIndex = 0;
        for (const f of importedFinds) {
            fIndex++;
            log(`  Find ${fIndex}/${importedFinds.length}: ${f.description || f.id || ''}`);

            const dataUrls = Array.isArray(f.exportPhotosDataUrls) ? f.exportPhotosDataUrls : [];
            let refs = [];

            if (dataUrls.length) {
                refs = await saveDataUrlsAsPhotoRefs(dataUrls);
            }

            f.photos          = refs;
            f.findPhotoRef    = refs[0] || '';
            f.targetPhotoData = refs.length > 0 ? '' : (dataUrls[0] || '');
            delete f.exportPhotosDataUrls;

            if (!f.id) {
                f.id = generateId();
            }
            if (!f.surveyId) {
                f.surveyId = importedSurvey.id;
            }
        }

              // 4) Merge into live data (ADD, do not overwrite existing)
        log('Merging imported survey into local data...');
        surveys.push(importedSurvey);
        finds = finds.concat(importedFinds);

        saveSurveysToLocalStorage();
        saveFindsToLocalStorage();

        log(`"${filename}" has been successfully imported.`);
        showMessage(
            `Imported survey "${importedSurvey.name || 'Unnamed survey'}" with ` +
            `${Array.isArray(importedSurvey.targets) ? importedSurvey.targets.length : 0} targets and ` +
            `${importedFinds.length} finds.`,
            'success'
        );

        // Stay on Settings so the user can read the log.
        // They can navigate manually when ready.
    } catch (e) {
        console.error('Error importing survey :', e);
        log(`ERROR: ${e.message || 'Unknown error'}`);
        showMessage(`Survey import failed: ${e.message || 'Unknown error'}`, 'error');
    }
}
function renameTrack(trackId, newName) {
    const found = findTrackById(trackId);
    if (!found || !found.survey || !found.track) {
        showMessage('Track not found.', 'error');
        return;
    }

    found.track.name = String(newName || '').trim() || 'Track';
    found.survey.dateLastChanged = Date.now();

    if (typeof saveSurveysToLocalStorage === 'function') {
        saveSurveysToLocalStorage();
    }

    showMessage('Track renamed.', 'success');

    // Refresh UI (Compass list + map)
    if (typeof rerenderCompassIfActive === 'function') {
        rerenderCompassIfActive();
    } else if (typeof render === 'function') {
        render();
    }
}

let navDelegationAttached = false;

function attachNavDelegationOnce() {
    if (navDelegationAttached) return;
    navDelegationAttached = true;

    document.addEventListener('click', (e) => {
        const btn = e.target.closest('.nav-btn');
        if (!btn) return;

        const targetPage = btn.dataset.page;
        if (targetPage && targetPage !== currentPage) {
            currentPage = targetPage;
            render();
        }
    });
}

    
        
    /** Attaches event listeners for dynamically rendered elements */

/**
 * Format a find's logged timestamp as "dd/mm/yy, hh:mm" (UK).
 * Uses dateCreated, createdAt, time, or dateLastChanged (in that order).
 */
function formatFindLoggedDateTime(find) {
    if (!find) return 'Not recorded';
    let ts = find.dateCreated ?? find.createdAt ?? find.time ?? find.dateLastChanged ?? null;

    // ISO string
    if (typeof ts === 'string') {
        const s = ts.trim();
        if (!s) return 'Not recorded';
        const d = new Date(s);
        if (!isFinite(d)) return 'Not recorded';
        return d.toLocaleString('en-GB', {
            day: '2-digit', month: '2-digit', year: '2-digit',
            hour: '2-digit', minute: '2-digit'
        });
    }

    // epoch ms number
    if (typeof ts === 'number' && isFinite(ts) && ts > 0) {
        const d = new Date(ts);
        if (!isFinite(d)) return 'Not recorded';
        return d.toLocaleString('en-GB', {
            day: '2-digit', month: '2-digit', year: '2-digit',
            hour: '2-digit', minute: '2-digit'
        });
    }

    return 'Not recorded';
}

function attachPageEventListeners() {

    const gpsBtn = document.getElementById('toggle-gps-btn');
if (gpsBtn) {
    gpsBtn.addEventListener('click', () => {
        showUserPosition = !showUserPosition;

        // If turning OFF, stop GPS only if nothing else needs it
        if (!needsGpsNow()) {
            if (typeof stopLiveMapLocationWatch === 'function') stopLiveMapLocationWatch();
        } else {
            if (!liveMapWatchId) startLiveMapLocationWatch();
        }

        showMessage(showUserPosition ? 'Showing your position.' : 'Hiding your position.', 'info');

        // Re-render Compass to update button label + map
        if (currentPage === 'Compass') {
            const appContent = document.getElementById('app-content');
            if (appContent) {
                appContent.innerHTML = renderCompassPage(true);
                attachPageEventListeners();
            }
        }
    });
}

    const navClearBtn = document.getElementById('nav-clear-btn');
    if (navClearBtn) {
    navClearBtn.addEventListener('click', () => {
        clearNavigationTarget();
    });
}
const privacyBtn = document.getElementById('open-privacy-btn');
if (privacyBtn) {
    privacyBtn.addEventListener('click', () => {
        location.href = 'privacy.html';
    });
}


    // 1. Navigation Button Listener
//    document.querySelectorAll('.nav-btn').forEach(button => {
//        button.onclick = (e) => {
//            const targetPage = e.currentTarget.dataset.page;
//            if (targetPage && targetPage !== currentPage) {
//                currentPage = targetPage;
//                render();
//            }
//        };
//    });

    

    // 2. Track Delete Buttons
    const trackDeleteButtons = document.querySelectorAll('.track-delete-btn');
    if (trackDeleteButtons && trackDeleteButtons.length > 0) {
        trackDeleteButtons.forEach(btn => {
            btn.addEventListener('click', (e) => {
                e.preventDefault();
                e.stopPropagation();
                const trackId = btn.getAttribute('data-track-id');
                deleteTrack(trackId);
            });
        });
    }
    

// 2c. Track Visibility Toggle Checkboxes
const trackVisibilityToggles = document.querySelectorAll('.track-visibility-toggle');
if (trackVisibilityToggles && trackVisibilityToggles.length > 0) {
    trackVisibilityToggles.forEach(cb => {
        cb.addEventListener('change', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const trackId = cb.getAttribute('data-track-id');
            toggleTrackVisibility(trackId, cb.checked);
        });
    });
}


// --- Map layer toggles (Compass/Map page) ---
const mapTargetsCb = document.getElementById('map-show-targets-cb');
if (mapTargetsCb) {
    mapTargetsCb.addEventListener('change', (e) => {
        e.preventDefault();
        e.stopPropagation();
        showMapTargets = !!mapTargetsCb.checked;
        if (currentPage === 'Compass') render();
    });
}

const mapStakesCb = document.getElementById('map-show-stakes-cb');
if (mapStakesCb) {
    mapStakesCb.addEventListener('change', (e) => {
        e.preventDefault();
        e.stopPropagation();
        showMapStakes = !!mapStakesCb.checked;
        if (currentPage === 'Compass') render();
    });
}

const mapFindsCb = document.getElementById('map-show-finds-cb');
if (mapFindsCb) {
    mapFindsCb.addEventListener('change', (e) => {
        e.preventDefault();
        e.stopPropagation();
        showMapFinds = !!mapFindsCb.checked;
        if (currentPage === 'Compass') render();
    });
}

const mapTracksCb = document.getElementById('map-show-tracks-cb');
if (mapTracksCb) {
    mapTracksCb.addEventListener('change', (e) => {
        e.preventDefault();
        e.stopPropagation();
        showMapTracks = !!mapTracksCb.checked;
        if (currentPage === 'Compass') render();
    });
}


// --- Track Start/Stop buttons (Compass/Map page) ---
    const startTrackBtn = document.getElementById('start-track-btn');
    if (startTrackBtn) {
        startTrackBtn.addEventListener('click', handleStartTrackClick);
    }

    const stopTrackBtn = document.getElementById('stop-track-btn');
    if (stopTrackBtn) {
        stopTrackBtn.addEventListener('click', handleStopTrackClick);
    }

// Track edit (name + description)
document.querySelectorAll('.track-edit-btn').forEach(btn => {
    btn.addEventListener('click', (e) => {
        e.preventDefault();
        e.stopPropagation();
        const trackId = e.currentTarget.getAttribute('data-track-id');
        promptEditTrackMeta(trackId);
    });
});

// 2b. Track Edit Buttons (name + description modal)
const trackEditButtons = document.querySelectorAll('.track-edit-btn');
if (trackEditButtons && trackEditButtons.length > 0) {
    trackEditButtons.forEach(btn => {
        btn.addEventListener('click', (e) => {
            e.preventDefault();
            e.stopPropagation();
            const trackId = btn.getAttribute('data-track-id');
            openEditTrackModal(trackId);
        });
    });
}

  
    // 3. Page Action Buttons (New Survey, Log Target, Export/Import)
    const newSurveyBtn = document.getElementById('new-survey-btn');
    if (newSurveyBtn) newSurveyBtn.addEventListener('click', showNewSurveyModal);

    const addTargetBtn = document.getElementById('add-target-btn');
    if (addTargetBtn) addTargetBtn.addEventListener('click', showNewTargetModal);

    const exportBtn = document.getElementById('export-data-btn');
    if (exportBtn) exportBtn.addEventListener('click', exportData);

    const importBtn = document.getElementById('import-data-btn');
    if (importBtn) importBtn.addEventListener('click', importData);

    const resetBtn = document.getElementById('reset-all-data-btn');
    if (resetBtn) resetBtn.addEventListener('click', resetAllAppData);

    // 4. Photo Settings
    const maxWidthInput = document.getElementById('max-photo-width-input');
    const savePhotoBtn = document.getElementById('save-photo-settings-btn');
    if (maxWidthInput) maxWidthInput.value = String(getMaxPhotoWidth() || 0);
    if (savePhotoBtn && maxWidthInput) {
        savePhotoBtn.addEventListener('click', () => {
            let val = Number((maxWidthInput.value || '').trim());
            if (isNaN(val) || val < 0) val = 1000;
            if (val !== 0) {
                if (val < 200) val = 200;
                if (val > 4000) val = 4000;
            }
            photoSettings.maxWidth = Math.round(val);
            savePhotoSettingsToLocalStorage();
            showMessage(val === 0 ? 'Resizing disabled.' : `Logged: ${photoSettings.maxWidth}px.`, 'success');
        });
    }

// 5. Navigation Overlay Settings
const navAboveInput = document.getElementById('nav-overlay-above-input');
const navBelowInput = document.getElementById('nav-overlay-below-input');
const saveNavOverlayBtn = document.getElementById('save-nav-overlay-settings-btn');

// Pre-fill inputs
if (navAboveInput) navAboveInput.value = String(getNavOverlayAboveOffsetPct());
if (navBelowInput) navBelowInput.value = String(getNavOverlayBelowOffsetPct());

// Save button
if (saveNavOverlayBtn && navAboveInput && navBelowInput) {
    saveNavOverlayBtn.addEventListener('click', () => {
        let above = Number((navAboveInput.value || '').trim());
        let below = Number((navBelowInput.value || '').trim());

        if (isNaN(above)) above = 50;
        if (isNaN(below)) below = 6;

        // Clamp to safe ranges
        if (above < 10) above = 10;
        if (above > 80) above = 80;
        if (below < 0) below = 0;
        if (below > 30) below = 30;

        navOverlaySettings.aboveOffsetPct = Math.round(above);
        navOverlaySettings.belowOffsetPct = Math.round(below);

        saveNavOverlaySettingsToLocalStorage();
        showMessage('Navigation overlay settings saved.', 'success');
    });
}

// Compass: STAKE button (no prompt, no forced tracking)
const stakeBtn = document.getElementById('stake-target-btn');
if (stakeBtn) {
    stakeBtn.addEventListener('click', () => {

        // LIMITS: stakes are targets too
        const r = canCreate('targets');
        if (!r.ok) {
            showMessage(r.reason, 'error');
            return;
        }

        // Create stake immediately (logs GPS only if currently available)
        quickLogTargetByVDI(-100, 'STAKE', { description: 'STAKE', type: 'Something else' });
    });
}
        
    // 5. Finds Page Filter Listeners
    const findsSearchInput = document.getElementById('finds-search-input');
    const findsTypeSelect = document.getElementById('finds-type-select');
    const findsSurveySelect = document.getElementById('finds-survey-select');
    const findsDateSelect = document.getElementById('finds-date-select');
    const clearFindsBtn = document.getElementById('clear-finds-filters-btn');

    if (findsSearchInput) {
        findsSearchInput.addEventListener('input', (e) => {
            findsFilter.query = e.target.value || '';
            render();
        });
    }
    if (findsTypeSelect) {
        findsTypeSelect.addEventListener('change', (e) => {
            findsFilter.type = e.target.value || 'All';
            render();
        });
    }
    if (findsSurveySelect) {
        findsSurveySelect.addEventListener('change', (e) => {
            findsFilter.surveyId = e.target.value || 'All';
            render();
        });
    }
    if (findsDateSelect) {
        findsDateSelect.addEventListener('change', (e) => {
            findsFilter.date = e.target.value || 'All';
            render();
        });
    }
    if (clearFindsBtn) {
        clearFindsBtn.addEventListener('click', () => {
            findsFilter = { query: '', type: 'All', surveyId: 'All', date: 'All' };
            render();
        });
    }

    // 6. Finds Card Buttons
    document.querySelectorAll('.find-card-edit-btn').forEach(btn => {
        btn.addEventListener('click', () => openEditFindModal(btn.getAttribute('data-find-id')));
    });
    document.querySelectorAll('.find-card-delete-btn').forEach(btn => {
        btn.addEventListener('click', () => deleteFind(btn.getAttribute('data-find-id')));
    });

// 7. Compass Page Range Buttons
document.querySelectorAll('.compass-range-btn').forEach(btn => {
    btn.addEventListener('click', () => {
        const min = Number(btn.getAttribute('data-min'));
        const max = Number(btn.getAttribute('data-max'));

        ensureTrackingThen(() => {
            const vdi = randomIntInclusive(min, max);

            // Rainbow targets should be Unidentified
            quickLogTargetByVDI(vdi, `${min}→${max}`, { type: 'Unidentified' });
        });
    });
});

//    });

    // 8. Compass Page Quick Input
    const quickInput = document.getElementById('compass-quick-target-vdi');
    if (quickInput) {
        if (typeof compassQuickTargetIdDraft === 'string' && quickInput.value !== compassQuickTargetIdDraft) {
            quickInput.value = compassQuickTargetIdDraft;
        }
        quickInput.addEventListener('input', () => { compassQuickTargetIdDraft = quickInput.value || ''; });
        quickInput.addEventListener('focus', stopCompassAutoRefresh);
        quickInput.addEventListener('blur', () => { if (currentPage === 'Compass') startCompassAutoRefresh(); });
    } // <--- THIS WAS THE MISSING BRACE IN YOUR FILE

    // 9. Central Listener for ALL Target buttons
    const appContent = document.getElementById('app-content');
    if (appContent) {
        appContent.onclick = (e) => {
            const btn = e.target.closest('button[data-action]');
            if (btn && typeof handleTargetAction === 'function') {
                handleTargetAction(btn);
            }
        };
    }

        const scanTargetQrBtn = document.getElementById('scan-target-qr-btn');
if (scanTargetQrBtn) {
    scanTargetQrBtn.addEventListener('click', openTargetQrScanModal);
}


        const sortByIdBtn = document.getElementById('sort-target-id-btn');
if (sortByIdBtn) {
    sortByIdBtn.addEventListener('click', () => {
        targetSortMode = 'id';
        render();
    });
}

const sortByDateBtn = document.getElementById('sort-target-date-btn');
if (sortByDateBtn) {
    sortByDateBtn.addEventListener('click', () => {
        targetSortMode = 'date';
        render();
    });
}

    const maintenanceBtn = document.getElementById('maintenance-btn');
if (maintenanceBtn) {
  maintenanceBtn.addEventListener('click', () => {
    showConfirmationModal(
      'Run Maintenance',
      'This will permanently remove any leftover deleted items and tidy local data.<br><br>Continue?',
      async () => {
        // call your helper(s) here
        // e.g. purgeDeletedTargetsPermanently(); purgeDeletedFindsPermanently(); etc.
        // then persist:
        saveSurveysToLocalStorage();
        saveFindsToLocalStorage?.();
        showMessage('Maintenance complete.', 'success');
        render();
      }
    );
  });
}



    // 10. Resolve thumbnails
    if (typeof initialiseCardThumbnails === 'function') {
        initialiseCardThumbnails();
    }

    }
        

        

/**
 * Read a chosen .json file and import it as a survey,
 * updating the import log as the process runs.
 */
async function importSurveyWithPhotosFromFile() {
    const fileInput = document.getElementById('import-survey-with-photos-file');
    const logBox    = document.getElementById('import-survey-log');

    const log = (msg) => {
        if (!logBox) return;
        logBox.value += msg + '\n';
        logBox.scrollTop = logBox.scrollHeight;
    };

    if (!fileInput || !fileInput.files || !fileInput.files.length) {
        showMessage('Please choose a survey .json file to import.', 'error');
        return;
    }

    const file = fileInput.files[0];

    // Clear previous log
    if (logBox) {
        logBox.value = '';
    }

    log(`Reading file "${file.name}"...`);

    let text;
    try {
        text = await file.text();
        log('File read successfully. Ready to import.');
    } catch (e) {
       console.error('Error reading survey import file:', e);
        log(`ERROR: Could not read file (${e.message || 'Unknown error'})`);
        showMessage(`Could not read import file: ${e.message || 'Unknown error'}`, 'error');
        return;
    }

    // Now ask for confirmation using the existing modal
    showImportConfirmModal(file.name, async () => {
        log('Starting import...');
        await performSurveyImport(text, file.name, log);
        // We stay on Settings so the user can read the log
    });
}

        // --- INITIALIZATION & EVENT LISTENERS ---

        // Event listener for navigation buttons
        document.querySelectorAll('.nav-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const targetPage = e.currentTarget.dataset.page;
                if (targetPage && targetPage !== currentPage) {
                    currentPage = targetPage;
                    render();
                }
            });
        });
        
    loadDataFromLocalStorage();
    attachNavDelegationOnce();   // your delegated nav handler

    const APP_LIMITS_STORAGE_KEY = 'detekta_app_limits_v1';

function bootstrapAppLimitsIfMissing() {
    if (localStorage.getItem(APP_LIMITS_STORAGE_KEY)) return;

    const testerDefaults = {
        maxSurveys: 3,
        maxTargets: 50,
        maxFinds: 30,
        expiryDate: '2026-06-01'
    };

    localStorage.setItem(APP_LIMITS_STORAGE_KEY, JSON.stringify(testerDefaults));
}

try {
    if (typeof bootStrapAppLimitsIfmissing === 'function') {
        bootStrapAppLimitsIfmissing();
    }
} catch (e) {
    console.warn('bootStrapAppLimitsIfmissing failed:', e);
}

// Optional: count launches (you already have incrementAppRunCount())
try {
    if (typeof incrementAppRunCount === 'function') incrementAppRunCount();
} catch (e) {}

    render();                    // renders Home by default
    updateActiveNavButtons();    // highlights Home

// Hide splash after first render
    hideAppSplash();

// Failsafe in case render never completes
    setTimeout(() => {
    if (document.getElementById('app-splash')) {
    hideAppSplash();
  }
}, 4000);


    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>
<!-- Progress Overlay -->
<div id="progress-overlay" class="fixed inset-0 bg-black/60 hidden items-center justify-center z-50">
  <div class="bg-white rounded-xl shadow-xl p-5 w-[92%] max-w-md">
    <div id="progress-title" class="text-lg font-bold mb-2">Working...</div>
    <div id="progress-message" class="text-sm text-gray-700 mb-3">Please wait.</div>

    <div class="w-full h-3 bg-gray-200 rounded-full overflow-hidden">
      <div id="progress-bar" class="h-3 bg-sky-600" style="width: 0%"></div>
    </div>

    <div class="flex justify-between text-xs text-gray-600 mt-2">
      <div id="progress-detail">Starting…</div>
      <div id="progress-percent">0%</div>
    </div>
  </div>
</div>
<!-- Mobile Bottom Navigation -->
<nav class="fixed bottom-0 left-0 right-0 z-40 bg-white border-t border-gray-200 sm:hidden">
  <div class="container mx-auto max-w-lg">
    <div class="flex items-center justify-between px-1 py-1">

      <button class="nav-btn flex flex-col items-center p-2 text-gray-500 hover:text-primary" data-page="Home">
        <i class="fas fa-home text-lg"></i>
        <span class="text-[10px]">Home</span>
      </button>

      <button class="nav-btn flex flex-col items-center p-2 text-gray-500 hover:text-primary" data-page="Compass">
        <i class="fas fa-compass text-lg"></i>
        <span class="text-[10px]">Map</span>
      </button>

      <button class="nav-btn flex flex-col items-center p-2 text-gray-500 hover:text-primary" data-page="Targets">
        <i class="fas fa-bullseye text-lg"></i>
        <span class="text-[10px]">Targets</span>
      </button>

      <button class="nav-btn flex flex-col items-center p-2 text-gray-500 hover:text-primary" data-page="Finds">
        <i class="fas fa-trophy text-lg"></i>
        <span class="text-[10px]">Finds</span>
      </button>

      <button class="nav-btn flex flex-col items-center p-2 text-gray-500 hover:text-primary" data-page="Export">
        <i class="fas fa-file-export text-lg"></i>
        <span class="text-[10px]">Export</span>
      </button>

      <button class="nav-btn flex flex-col items-center p-2 text-gray-500 hover:text-primary" data-page="Settings">
        <i class="fas fa-cog text-lg"></i>
        <span class="text-[10px]">Settings</span>
      </button>

      <button class="nav-btn flex flex-col items-center p-2 text-gray-500 hover:text-primary" data-page="Help">
        <i class="fas fa-question-circle text-lg"></i>
        <span class="text-[10px]">Help</span>
      </button>

    </div>
  </div>
</nav>

<script>
  // Mobile bottom nav is added after the main script,
  // so run highlighting once the bottom nav exists in the DOM.
  try { if (typeof updateActiveNavButtons === 'function') updateActiveNavButtons(); } catch (e) {}
</script>

          
</body>
</html>
