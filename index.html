<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QR 2 - Metal Detecting Survey Log</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css" />
    
    <style>
        /* Custom colors using CSS variables for guaranteed consistency */
        :root {
            --color-primary: 29 78 216;      /* Blue (For contrast/borders) */
            --color-secondary: 34 197 94;    /* Vibrant Green (For action buttons) */
            --color-background: 243 244 246; /* Light Gray */
            --color-card: 255 255 255;       /* White */
        }

        /* Configure Tailwind to use the custom variables (kept for other classes like text-primary) */
        tailwind-config {
            theme: {
                extend: {
                    colors: {
                        primary: 'rgb(var(--color-primary) / <alpha-value>)',
                        secondary: 'rgb(var(--color-secondary) / <alpha-value>)',
                        background: 'rgb(var(--color-background) / <alpha-value>)',
                        card: 'rgb(var(--color-card) / <alpha-value>)',
                    }
                }
            }
        }

        /* Basic App Styling */
        body {
            font-family: 'Arial', sans-serif;
            background-color: rgb(var(--color-background));
        }

        /* Ensure the modal is hidden by default and handles clicks outside */
        .modal {
            display: none;
            position: fixed;
            z-index: 50;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0, 0, 0, 0.4);
        }
        /* Ensure the photo gallery always sits above other modals */
        .modal.modal-gallery {
    z-index: 100; /* higher than the normal modal z-index (50) */
}

        .modal-content {
            margin: 10vh auto;
            border-radius: 12px;
            max-width: 500px;
        }
    </style>
</head>
<body class="min-h-screen">

    <header class="bg-white shadow-md fixed top-0 left-0 right-0 z-40">
        <div class="container mx-auto max-w-lg">
            <div class="flex items-center justify-between p-4">
                <h1 class="text-xl font-extrabold text-primary">GeoFind Log</h1>
                <div class="flex space-x-2">
                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Home">
                        <i class="fas fa-home text-xl"></i>
                    </button>
                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Targets">
                        <i class="fas fa-bullseye text-xl"></i>
                    </button>
                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Compass">
                        <i class="fas fa-compass text-xl"></i>
                    </button>
                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150"
                    data-page="Finds">
                    <i class="fas fa-trophy text-xl"></i>
                    </button>

                    <button class="nav-btn p-2 rounded-full text-gray-500 hover:text-primary transition duration-150" data-page="Settings">
                        <i class="fas fa-cog text-xl"></i>
                    </button>
                </div>
            </div>
        </div>
    </header>

    <main id="app-content" class="container mx-auto max-w-lg pt-20 pb-4 min-h-screen"></main>

    <div id="message-toast" class="fixed bottom-4 right-4 z-50 p-4 rounded-lg text-white shadow-xl transition-opacity duration-300 opacity-0 pointer-events-none" style="min-width: 250px;"></div>

    <div id="confirmation-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 id="confirm-title" class="text-xl font-bold text-red-600 mb-4">Confirmation</h3>
            <p id="confirm-message" class="text-gray-700 mb-6"></p>
            <div class="flex justify-end space-x-3">
                <button id="confirm-no-btn" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                <button id="confirm-yes-btn" class="px-4 py-2 bg-red-600 text-white rounded-lg hover:bg-red-700 font-semibold">Yes, Proceed</button>
            </div>
        </div>
    </div>
        <div id="photo-gallery-modal" class="modal modal-gallery">
                <div class="modal-content bg-black bg-opacity-90 text-white p-4 shadow-2xl relative max-w-full">
                <!-- Close button -->
                    <button
                    type="button"
                    class="absolute top-3 right-3 w-8 h-8 rounded-full bg-gray-800 bg-opacity-80 hover:bg-opacity-100 flex items-center justify-center"
                    onclick="closePhotoGallery()"
                    >
                    < i class="fas fa-times text-sm"></i>
                    </button>

                    <!-- Image area (swipe here) -->
                    <div id="photo-gallery-image-wrapper" class="flex items-center justify-center mt-4">
                    <img
                        id="photo-gallery-image"
                        alt="Photo"
                        class="max-h-screen w-auto rounded-lg border border-gray-700"
                    >
                </div>

            <!-- “1 of N” text -->
            <p id="photo-gallery-caption" class="mt-3 text-center text-sm text-gray-300"></p>

            <!-- Prev / Next buttons -->
            <div class="mt-4 flex justify-between items-center">
                <button
                    type="button"
                    class="px-4 py-2 rounded-md bg-gray-700 hover:bg-gray-600 text-sm font-semibold"
                    onclick="showGalleryPhoto(-1)"
                >
                    ‹ Previous
                </button>
                <button
                    type="button"
                    class="px-4 py-2 rounded-md bg-gray-700 hover:bg-gray-600 text-sm font-semibold"
                    onclick="showGalleryPhoto(1)"
                >
                    Next ›
                </button>
            </div>
        </div>
    </div>
<!-- Target QR modal -->
<div id="target-qr-modal" class="modal">
  <div class="modal-content bg-white p-6 shadow-2xl max-w-sm">
    <h3 id="target-qr-title" class="text-xl font-bold text-primary mb-4">
      Target QR
    </h3>

    <div
      id="target-qr-code-container"
      class="w-full flex items-center justify-center mb-4"
    >
      <!-- QR code will be inserted here -->
    </div>

    <p class="text-xs text-gray-500 mb-2">
      This QR encodes the main details of this target so it can be imported on another device.
    </p>

    <textarea
      id="target-qr-raw-text"
      class="w-full h-24 text-xs font-mono bg-gray-50 border border-gray-200 rounded-md p-2 mb-4"
      readonly
    ></textarea>

    <div class="flex justify-end">
      <button
        type="button"
        class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
        onclick="closeTargetQrModal()"
      >
        Close
      </button>
    </div>
  </div>
</div>
<!-- Target QR SCAN modal -->
<div id="target-qr-scan-modal" class="modal">
  <div class="modal-content bg-white p-6 shadow-2xl max-w-sm">
    <h3 class="text-xl font-bold text-primary mb-4">
      Import Target via QR
    </h3>

    <p class="text-sm text-gray-600 mb-3">
      The target will be imported into the <strong>currently open survey</strong>.
      Point your camera at a GeoFind Target QR code on another device.
    </p>

    <div class="w-full aspect-video bg-black rounded-lg overflow-hidden mb-3 flex items-center justify-center">
      <video
        id="target-qr-scan-video"
        autoplay
        playsinline
        class="w-full h-full object-cover"
      ></video>
    </div>

    <p
      id="target-qr-scan-status"
      class="text-xs text-gray-500 mb-4"
    >
      Initialising camera…
    </p>

    <div class="flex justify-end">
      <button
        type="button"
        class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
        onclick="closeTargetQrScanModal()"
      >
        Cancel
      </button>
    </div>
  </div>
</div>

<!-- Hidden canvas used internally for QR decoding -->
<canvas id="target-qr-scan-canvas" class="hidden"></canvas>

    
    <div id="new-survey-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 class="text-xl font-bold text-primary mb-4">Create New Survey</h3>
            <form id="new-survey-form">
                <div class="mb-4">
                    <label for="survey-name" class="block text-sm font-medium text-gray-700">Survey Name *</label>
                    <input type="text" id="survey-name" name="surveyName" required 
                           class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                </div>
                <div class="mb-4">
                    <label for="survey-description" class="block text-sm font-medium text-gray-700">Description / Location</label>
                    <textarea id="survey-description" name="surveyDescription" rows="3" 
                              class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"></textarea>
                </div>
                            <!-- Survey photo (optional) -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700">
                    Survey Photo (optional)
                </label>
                <p id="new-survey-photo-status" class="text-xs text-gray-500 mt-1">
                    No photo captured yet.
                </p>

                <div
                    id="new-survey-photo-preview-wrapper"
                    class="mt-2 hidden"
                >
                    <img
                        id="new-survey-photo-preview"
                        alt="Survey photo preview"
                        class="w-full max-h-48 object-cover rounded-lg border border-gray-200"
                    />
                </div>

                <input
                    type="hidden"
                    id="new-survey-photo-data"
                    name="surveyPhotoData"
                >

                <input
                    type="file"
                    id="new-survey-photo-input"
                    accept="image/*"
                    capture="environment"
                    class="hidden"
                    onchange="handleNewSurveyPhotoSelected(event)"
                >

                <button
                    type="button"
                    onclick="triggerNewSurveyPhotoInput()"
                    class="mt-3 inline-flex items-center px-4 py-2 border border-gray-300 rounded-lg shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-100"
                >
                    <i class="fas fa-camera mr-2"></i>
                    Take / Choose Photo
                </button>
            </div>

                <div class="flex justify-end space-x-3 mt-6">
                    <button type="button" onclick="closeNewSurveyModal()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                    <button type="submit" class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
                            style="background-color: rgb(var(--color-secondary));">
                        Create & Open
                    </button>
                </div>
            </form>
        </div>
    </div>

<div id="edit-survey-modal" class="modal">
    <div class="modal-content bg-white p-6 shadow-2xl">
        <h3 class="text-xl font-bold text-primary mb-4">Edit Open Survey</h3>
        <form id="edit-survey-form">
            <input type="hidden" id="edit-survey-id" name="surveyId">

            <div class="mb-4">
                <label for="edit-survey-name" class="block text-sm font-medium text-gray-700">
                    Survey Name *
                </label>
                <input
                    type="text"
                    id="edit-survey-name"
                    name="surveyName"
                    required
                    class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                >
            </div>

            <div class="mb-4">
                <label for="edit-survey-description" class="block text-sm font-medium text-gray-700">
                    Description / Location
                </label>
                <textarea
                    id="edit-survey-description"
                    name="surveyDescription"
                    rows="3"
                    class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary"
                ></textarea>
            </div>

            <!-- Survey Photo -->
            <div class="mb-4">
                <label class="block text-sm font-medium text-gray-700">
                    Survey Photo (optional)
                </label>
                <p id="edit-survey-photo-status" class="text-xs text-gray-500 mt-1">
                    No photo captured yet.
                </p>

                <div
                    id="edit-survey-photo-preview-wrapper"
                    class="mt-2 hidden"
                >
                    <img
                        id="edit-survey-photo-preview"
                        alt="Survey photo preview"
                        class="w-full max-h-48 object-cover rounded-lg border border-gray-200"
                    />
                </div>

                <input
                    type="hidden"
                    id="edit-survey-photo-data"
                    name="surveyPhotoData"
                >

                <input
                    type="file"
                    id="edit-survey-photo-input"
                    accept="image/*"
                    capture="environment"
                    class="hidden"
                    onchange="handleEditSurveyPhotoSelected(event)"
                >

                <button
                    type="button"
                    onclick="triggerEditSurveyPhotoInput()"
                    class="mt-3 inline-flex items-center px-4 py-2 border border-gray-300 rounded-lg shadow-sm text-sm font-medium text-gray-700 bg-white hover:bg-gray-100"
                >
                    <i class="fas fa-camera mr-2"></i>
                    Take / Choose Photo
                </button>
            </div>

            <div class="flex justify-end space-x-3 mt-6">
                <button
                    type="button"
                    onclick="closeEditSurveyModal()"
                    class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300"
                >
                    Cancel
                </button>
                <button
                    type="submit"
                    class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
                    style="background-color: rgb(var(--color-secondary));"
                >
                    Save Changes
                </button>
            </div>
        </form>
    </div>
</div>
<!-- Edit Find Modal (now matches Target modal structure) -->
<div id="edit-find-modal" class="modal">
  <div class="modal-content bg-white p-6 shadow-2xl">

    <!-- Header with close button -->
    <div class="flex items-center justify-between mb-4">
      <h3 class="text-xl font-bold text-primary">Edit Find</h3>
      <button
        type="button"
        class="text-gray-400 hover:text-gray-600 text-xl leading-none"
        aria-label="Close"
        onclick="closeEditFindModal()">
        &times;
      </button>
    </div>

    <form id="edit-find-form" class="space-y-4">
      <!-- Hidden ID -->
      <input type="hidden" id="edit-find-id" name="findId">

           <!-- Description (now a textarea) -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-description">
          Description / Find Name
        </label>
        <textarea
          id="edit-find-description"
          name="findDescription"
          rows="4"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary"
          required></textarea>
      </div>

      <!-- Type -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-type">
          Type
        </label>
        <select
          id="edit-find-type"
          name="findType"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
          <option value="Coin">Coin</option>
          <option value="Relic">Relic</option>
          <option value="Jewellery">Jewellery</option>
          <option value="Modern">Modern</option>
          <option value="Trash">Trash</option>
          <option value="Unknown">Unknown</option>
        </select>
      </div>

      <!-- VDI + Depth -->
      <div class="grid grid-cols-2 gap-3">
        <div>
          <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-vdi">
            Target ID
          </label>
          <input
            type="text"
            id="edit-find-vdi"
            name="findVDI"
            class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
        </div>
        <div>
          <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-depth">
            Depth
          </label>
          <input
            type="text"
            id="edit-find-depth"
            name="findDepth"
            class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
        </div>
      </div>

      <!-- Coordinates -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-coords">
          Coordinates
        </label>
        <input
          type="text"
          id="edit-find-coords"
          name="findCoords"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
      </div>

      <!-- Accuracy -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1" for="edit-find-accuracy">
          Accuracy
        </label>
        <input
          type="text"
          id="edit-find-accuracy"
          name="findAccuracy"
          class="w-full border border-gray-300 rounded-md px-3 py-2 text-sm focus:ring-primary focus:border-primary">
      </div>

      <!-- NEW: Find photograph controls -->
      <div>
        <label class="block text-xs font-semibold text-gray-600 mb-1">
          Find Photograph
        </label>

        <!-- Hidden file input (camera / gallery) -->
       <input
  type="file"
  id="edit-find-photo-input"
  accept="image/*;capture=camera"
  multiple
  class="hidden"
  onchange="handleEditFindPhotoSelected(event)">

        <!-- Hidden field to store the Base64 photo data -->
        <input
          type="hidden"
          id="edit-find-photo-data"
          name="findPhotoData">

        <div class="flex items-center space-x-3 mt-1">
          <button
            type="button"
            class="px-3 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-sm font-semibold"
            onclick="triggerEditFindPhotoInput()">
            <i class="fas fa-camera mr-1"></i> Take / Choose Photo
          </button>
          <span id="edit-find-photo-status" class="text-xs text-gray-500">
            No photo captured yet.
          </span>
        </div>

        <div id="edit-find-photo-preview-wrapper" class="mt-2 hidden flex justify-center">
          <img
            id="edit-find-photo-preview"
            class="w-11/12 h-auto rounded-md border border-gray-300 object-cover"
            alt="Find photo preview">
        </div>
      </div>
      <!-- END NEW: Find photograph controls -->

      <!-- Footer buttons -->
      <div class="pt-2 flex justify-end gap-2">
        <button
          type="button"
          id="cancel-edit-find-btn"
          class="px-3 py-1 rounded-md border border-gray-300 text-gray-700 hover:bg-gray-100"
          onclick="closeEditFindModal()">
          Cancel
        </button>
        <button
          type="submit"
          class="px-4 py-2 rounded-md bg-green-600 text-white text-sm font-semibold hover:bg-green-700 transition">
          Save changes
        </button>
      </div>
    </form>
  </div>
</div>
    
    <div id="new-target-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 class="text-xl font-bold text-primary mb-4">Log New Target</h3>
            <form id="new-target-form">
    <!-- Which survey this target belongs to -->
    <input type="hidden" id="new-target-survey-id" name="targetSurveyId" />

    <div id="target-survey-display"
         class="bg-gray-100 p-2 rounded-md mb-4 text-sm font-semibold text-gray-700">
        Logging for: 
        <span id="current-target-survey-name" class="text-primary">Loading...</span>
    </div>

    <div class="grid grid-cols-2 gap-4">
        <!-- Description -->
        <div class="mb-4 col-span-2">
            <label for="target-description"
                   class="block text-sm font-medium text-gray-700">
                Description / Find Name *
            </label>
            <input type="text"
                   id="target-description"
                   name="targetDescription"
                   required
                   class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2
                          focus:ring-primary focus:border-primary">
        </div>

        <!-- VDI -->
        <div class="mb-4">
            <label for="target-vdi"
                   class="block text-sm font-medium text-gray-700">
                Target ID
            </label>
            <input type="text"
                   id="target-vdi"
                   name="targetVDI"
                   placeholder="e.g., 28"
                   class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2
                          focus:ring-primary focus:border-primary">
        </div>

        <!-- Depth -->
        <div class="mb-4">
            <label for="target-depth"
                   class="block text-sm font-medium text-gray-700">
                Depth
            </label>
            <input type="text"
                   id="target-depth"
                   name="targetDepth"
                   placeholder="e.g., 4 inches"
                   class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2
                          focus:ring-primary focus:border-primary">
        </div>

        <!-- Type -->
        <div class="mb-4">
            <label for="target-type"
                   class="block text-sm font-medium text-gray-700">
                Type
            </label>
            <select id="target-type"
                    name="targetType"
                    class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2
                           focus:ring-primary focus:border-primary">
        <option value="Unidentified" selected>Unidentified</option>
        <option value="Iron Junk">Iron Junk</option>
        <option value="Modern Junk">Modern Junk</option>
         <option value="Coin">Coin</option>
        <option value="Ring">Ring</option>
        <option value="Jewelry">Jewelry</option>
        <option value="Relic">Relic</option>
        <option value="Something else.">Something else</option>
            </select>
        </div>

        <!-- GPS + accuracy -->
        <div class="mb-4 col-span-2">
            <label for="target-coords"
                   class="block text-sm font-medium text-gray-700">
                GPS Location
            </label>
            <input type="text"
                   id="target-coords"
                   name="targetCoords"
                   placeholder="Requesting location..."
                   class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2
                          focus:ring-primary focus:border-primary">
            <input type="hidden"
                   id="target-accuracy"
                   name="targetAccuracy">
            <p id="gps-accuracy-display"
               class="text-xs text-gray-600 mt-1">
                Accuracy (Radius): 
                <span class="font-semibold text-red-600">N/A</span>
            </p>
        </div>

        <!-- Photo section (current single-photo UI) -->
        <div class="mb-4 col-span-2">
            <label class="block text-sm font-medium text-gray-700 mb-1">
                Target Photo
            </label>

            <p id="new-target-photo-status"
               class="text-xs text-gray-600 mb-2">
                No photo captured yet.
            </p>

            <div id="new-target-photo-preview-wrapper"
                 class="hidden mb-2">
                <img id="new-target-photo-preview"
                     alt="Target preview"
                     class="w-full max-h-64 object-contain rounded-lg border border-gray-300" />
            </div>

            <input type="hidden"
                   id="target-photo-data"
                   name="targetPhotoData">

            <input type="file"
                   id="new-target-photo-input"
                   accept="image/*"
                   capture="environment"
                   class="hidden"
                   onchange="handleNewTargetPhotoSelected(event)">

            <button type="button"
                    class="px-3 py-2 text-sm font-semibold rounded-lg shadow
                           text-white"
                    style="background-color: rgb(var(--color-secondary));"
                    onclick="triggerNewTargetPhotoInput()">
                Take / Choose Photo
            </button>
        </div>
    </div>

    <!-- Button bar: force white background -->
    <div class="mt-6 pt-4 flex justify-end space-x-3 bg-white">
        <button type="button"
                onclick="closeNewTargetModal()"
                class="px-4 py-2 text-sm font-semibold bg-gray-200 text-gray-700 rounded-lg
                       hover:bg-gray-300">
            Cancel
        </button>
        <button type="submit"
                class="px-4 py-2 text-sm font-semibold rounded-lg shadow-md hover:opacity-90
                       transition duration-150 text-white"
                style="background-color: rgb(var(--color-secondary));">
            Log Target
        </button>
    </div>
</form>

        </div>
    </div>
    
    <div id="edit-target-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 class="text-xl font-bold text-primary mb-4">Edit Target Details</h3>
            <form id="edit-target-form">
                <input type="hidden" id="edit-target-id" name="targetId">
                <input type="hidden" id="edit-survey-id" name="surveyId">

                <div id="edit-target-survey-display" class="bg-gray-100 p-2 rounded-md mb-4 text-sm font-semibold text-gray-700">
                    Editing target in: <span id="current-edit-survey-name" class="text-primary">Loading...</span>
                </div>

                <div class="grid grid-cols-2 gap-4">
                    <div class="mb-4 col-span-2">
                        <label for="edit-target-description" class="block text-sm font-medium text-gray-700">Description / Find Name *</label>
                        <input type="text" id="edit-target-description" name="targetDescription" required 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                    <div class="mb-4">
                        <label for="edit-target-vdi" class="block text-sm font-medium text-gray-700">Target ID</label>
                        <input type="text" id="edit-target-vdi" name="targetVDI" placeholder="e.g., 28" 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                    <div class="mb-4">
                        <label for="edit-target-depth" class="block text-sm font-medium text-gray-700">Depth</label>
                        <input type="text" id="edit-target-depth" name="targetDepth" placeholder="e.g., 6 inches"
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
 <div class="mb-4 col-span-2">
    <label for="edit-target-type" class="block text-sm font-medium text-gray-700">Type of Find *</label>
    <select id="edit-target-type" name="targetType" required
            class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary bg-white">
        <option value="Unidentified">Unidentified</option>
        <option value="Iron Junk">Iron Junk</option>
        <option value="Modern Junk">Modern Junk</option>
         <option value="Coin">Coin</option>
        <option value="Ring">Ring</option>
        <option value="Jewelry">Jewelry</option>
        <option value="Relic">Relic</option>
        <option value="Something else.">Something else</option>
    </select>
     
</div>
<div class="mb-4 col-span-2">
    <label class="block text-sm font-medium text-gray-700 mb-1">
        Target Photographs
    </label>

    <input
        type="file"
        id="edit-target-photo-input"
        accept="image/*;capture=camera"
        class="hidden"
        multiple
        onchange="handleEditTargetPhotoSelected(event)"
    >

    <input
        type="hidden"
        id="edit-target-photo-data"
        name="targetPhotoData"
    >

    <div class="flex items-center space-x-3">
        <button
            type="button"
            class="px-3 py-2 rounded-md bg-gray-200 hover:bg-gray-300 text-sm font-semibold"
            onclick="triggerEditTargetPhotoInput()"
        >
            <i class="fas fa-camera mr-1"></i> Take / Choose Photo(s)
        </button>
        <span id="edit-target-photo-status" class="text-xs text-gray-500">
            No photo captured yet.
        </span>
    </div>

    <!-- Thumbnails (stacked, nearly full width) -->
    <div id="edit-target-photo-preview-wrapper" class="mt-2 hidden w-full"></div>
</div>
                    
<div class="mb-4 col-span-2">
                        <label for="edit-target-coords" class="block text-sm font-medium text-gray-700">GPS Coordinates</label>
                        <input type="text" id="edit-target-coords" name="targetCoords" placeholder="e.g., 50.2568, -5.2345" 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                    <div class="mb-4 col-span-2">
                        <label for="edit-target-accuracy" class="block text-sm font-medium text-gray-700">GPS Accuracy (m)</label>
                        <input type="text" id="edit-target-accuracy" name="targetAccuracy" placeholder="e.g., 5.0" 
                               class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                    </div>
                </div>

                <div class="flex justify-end space-x-3 mt-6">
                    <button type="button" onclick="closeEditTargetModal()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                    <button type="submit" class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
                            style="background-color: rgb(var(--color-secondary));">
                        Save Target Changes
                    </button>
                </div>
            </form>
        </div>
    </div>
    
    <div id="edit-profile-modal" class="modal">
        <div class="modal-content bg-white p-6 shadow-2xl">
            <h3 class="text-xl font-bold text-primary mb-4">Edit Detectorist Profile</h3>
            <form id="edit-profile-form">
                <div class="mb-4">
                    <label for="profile-name" class="block text-sm font-medium text-gray-700">Detectorist Name *</label>
                    <input type="text" id="profile-name" name="profileName" required 
                           class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                </div>
                <div class="mb-4">
                    <label for="profile-detector" class="block text-sm font-medium text-gray-700">Detector Used</label>
                    <input type="text" id="profile-detector" name="profileDetector" required
                           class="mt-1 block w-full border border-gray-300 rounded-md shadow-sm p-2 focus:ring-primary focus:border-primary">
                </div>
                <div class="flex justify-end space-x-3 mt-6">
                    <button type="button" onclick="closeEditProfileModal()" class="px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300">Cancel</button>
                    <button type="submit" class="px-4 py-2 text-white font-semibold rounded-lg shadow-md hover:opacity-90 transition duration-150"
                            style="background-color: rgb(var(--color-secondary));">
                        Save Changes
                    </button>
                </div>
            </form>
        </div>
    </div>


    <script>
        // --- GLOBAL STATE & INITIALIZATION ---
        
// --- GLOBAL STATE & INITIALIZATION ---
let surveys = [];
let finds = [];  // permanent library of Finds
let currentPage = 'Home';
let isMapFullscreen = false;
let targetWatchId = null;

// Simple filter state for the Finds page
let findsFilter = {
    query: '',
    type: 'All',
    surveyId: 'All'
};

// NEW: holds photos while the Edit Find modal is open
let currentEditFindPhotos = [];

// NEW: holds photos while the New Target modal is open
let currentNewTargetPhotos = [];

// NEW: holds photos while the Edit Target modal is open
let currentEditTargetPhotos = [];

// Shared gallery state
let currentGalleryPhotos = [];
let currentGalleryIndex = 0;
let gallerySwipeInitialized = false;
let galleryTouchStartX = null;

     
        // Profile initialized with default data
        let userProfile = {
            name: "New User",
            detector: "Default Machine"
        };
        let userId;

      // --- NEW REAL-TIME LOCATION STATE ---
        let autoRefreshIntervalId = null; 
        let currentUserCoords = null;
        let currentUserAccuracy = null;
        let bestLiveAccuracy = Infinity;
        let liveMapWatchId = null;
        let navigationTargetId = null;

                // --- MOVEMENT HISTORY FOR DIRECTION-OF-TRAVEL GUIDANCE ---
        // Stores recent smoothed GPS positions so we can estimate which way
        // you're walking and give "left / right / ahead" style guidance.
        let movementHistory = [];
        const MOVEMENT_HISTORY_MAX_AGE_MS = 60000;     // keep ~60s of movement
        const MOVEMENT_HISTORY_MAX_LENGTH = 30;        // max number of points
        const MOVEMENT_MIN_DISTANCE_METERS = 2;        // need at least ~2m of motion


// NEW: smoothed position for the live map
        let smoothedUserCoords = null;
        const USER_SMOOTHING_ALPHA = 0.15; // 0 < alpha ≤ 1 (lower = smoother, slower)
// --- TRACK RECORDING STATE ---
        let activeTrackSurveyId = null;
        let activeTrackId = null;
        const TRACK_POINT_MIN_DISTANCE_METERS = 3; // only log a point if you've moved at least this far

        function updateSmoothedUserCoords(newLat, newLon) {
    // First reading: snap straight to the new value
    if (!smoothedUserCoords) {
        smoothedUserCoords = { lat: newLat, lon: newLon };
        return;
    }

    // Exponential moving average
    smoothedUserCoords.lat =
        smoothedUserCoords.lat + USER_SMOOTHING_ALPHA * (newLat - smoothedUserCoords.lat);
    smoothedUserCoords.lon =
        smoothedUserCoords.lon + USER_SMOOTHING_ALPHA * (newLon - smoothedUserCoords.lon);
}

// =====================
//  INDEXEDDB FOR PHOTOS
// =====================

// DB / store names
const PHOTO_DB_NAME    = 'geoFindDB';
const PHOTO_DB_VERSION = 1;
const PHOTO_STORE_NAME = 'photos';

// Simple prefix to mark "this is an IndexedDB photo reference"
const PHOTO_REF_PREFIX = 'idb:';

function resetAllAppData() {
    if (!confirm("⚠️ WARNING:\n\nThis will permanently delete ALL saved Surveys, Targets, Finds and Photos stored locally on THIS device.\n\nThis cannot be undone.\n\nDo you want to continue?")) {
        return;
    }

    try {
        // Clear localStorage keys
        localStorage.clear();

        // Clear IndexedDB photo database
        indexedDB.deleteDatabase('geoFindDB');

        alert("All local app data has been deleted.\nThe app will now restart.");
        location.reload();
    } catch (e) {
        console.error("Failed to reset app data:", e);
        alert("Could not reset app data.");
    }
}
        
/**
 * Opens (or creates) our photo database.
 * Returns a Promise that resolves to the DB instance.
 */
function openPhotoDB() {
    return new Promise((resolve, reject) => {
        const request = indexedDB.open(PHOTO_DB_NAME, PHOTO_DB_VERSION);

        request.onupgradeneeded = (event) => {
            const db = event.target.result;
            if (!db.objectStoreNames.contains(PHOTO_STORE_NAME)) {
                // Simple auto-increment numeric key: 1, 2, 3, ...
                db.createObjectStore(PHOTO_STORE_NAME, { keyPath: 'id', autoIncrement: true });
            }
        };

        request.onsuccess = () => resolve(request.result);
        request.onerror   = () => reject(request.error);
    });
}

/**
 * Save a Blob (photo) into IndexedDB.
 * Resolves to the numeric ID.
 */
async function savePhotoBlob(blob) {
    const db = await openPhotoDB();
    return new Promise((resolve, reject) => {
        const tx    = db.transaction(PHOTO_STORE_NAME, 'readwrite');
        const store = tx.objectStore(PHOTO_STORE_NAME);

        const request = store.add({
            blob,
            createdAt: Date.now()
        });

        request.onsuccess = () => resolve(request.result); // numeric ID
        request.onerror   = () => reject(request.error);
    });
}

/**
 * Load a Blob (photo) from IndexedDB by ID.
 * Resolves to the Blob or null.
 */
async function loadPhotoBlob(id) {
    const db = await openPhotoDB();
    return new Promise((resolve, reject) => {
        const tx    = db.transaction(PHOTO_STORE_NAME, 'readonly');
        const store = tx.objectStore(PHOTO_STORE_NAME);

        const request = store.get(id);
        request.onsuccess = () => {
            const record = request.result;
            resolve(record ? record.blob : null);
        };
        request.onerror = () => reject(request.error);
    });
}

/**
 * Optional: delete a photo blob by ID (for when you delete targets/finds later).
 */
async function deletePhotoBlob(id) {
    const db = await openPhotoDB();
    return new Promise((resolve, reject) => {
        const tx    = db.transaction(PHOTO_STORE_NAME, 'readwrite');
        const store = tx.objectStore(PHOTO_STORE_NAME);

        const request = store.delete(id);
        request.onsuccess = () => resolve(true);
        request.onerror   = () => reject(request.error);
    });
}


// ========================
//  PHOTO REFERENCE HELPERS
// ========================

/**
 * Build a reference string from a numeric ID, eg "idb:5".
 */
function makePhotoRef(id) {
    return `${PHOTO_REF_PREFIX}${id}`;
}

/**
 * Check if a string is an IndexedDB photo reference.
 */
function isIndexedDbPhotoRef(ref) {
    return typeof ref === 'string' && ref.startsWith(PHOTO_REF_PREFIX);
}

/**
 * Extract the numeric ID from a reference string, eg "idb:5" -> 5.
 */
function parsePhotoRef(ref) {
    if (!isIndexedDbPhotoRef(ref)) return null;
    const num = Number(ref.slice(PHOTO_REF_PREFIX.length));
    return Number.isFinite(num) ? num : null;
}

/**
 * Convert a data URL (base64) to a Blob using fetch.
 * Works offline because it's a data: URL.
 */
async function dataUrlToBlob(dataUrl) {
    const response = await fetch(dataUrl);
    return await response.blob();
}

/**
 * Given an array of data URLs, store them in IndexedDB and
 * return an array of references, e.g. ["idb:1", "idb:2"].
 */
async function saveDataUrlsAsPhotoRefs(dataUrls) {
    const refs = [];
    for (const url of dataUrls) {
        if (typeof url !== 'string' || !url) continue;
        const blob = await dataUrlToBlob(url);
        const id   = await savePhotoBlob(blob);
        refs.push(makePhotoRef(id));
    }
    return refs;
}

/**
 * Given a single reference ("idb:5"), return an object URL you can use as img.src.
 * Resolves to null if not found.
 */
async function getPhotoUrlFromRef(ref) {
    // If we ever had plain data URLs in refs, we could handle them here:
    if (typeof ref !== 'string' || !ref) return null;

    // In the new world we only use "idb:NNN"
    const id = parsePhotoRef(ref);
    if (id == null) {
        // If you *later* want to support old base64 refs, you could:
        // if (ref.startsWith('data:image/')) return ref;
        return null;
    }

    const blob = await loadPhotoBlob(id);
    if (!blob) return null;

    return URL.createObjectURL(blob);
}

/**
 * For galleries: turn ["idb:1", "idb:2"] into an array of object URLs.
 */
async function loadPhotoUrlsFromRefs(refs) {
    const urls = [];
    for (const ref of refs || []) {
        const url = await getPhotoUrlFromRef(ref);
        if (url) urls.push(url);
    }
    return urls;
}

 // ======================================
// SHARED STORAGE HELPERS
// ======================================

// Helper: return only non-deleted targets for a survey
function getActiveTargets(survey) {
    if (!survey || !Array.isArray(survey.targets)) return [];
    return survey.targets.filter(t => !t.deleted);
}

function saveCollectionToStorage(key, data) {
    try {
        localStorage.setItem(key, JSON.stringify(data));
    } catch (err) {
        console.error(`Error saving ${key} to localStorage:`, err);

        // Detect quota errors across different browsers
        const isQuotaError =
            err &&
            (
                err.name === 'QuotaExceededError' ||
                err.name === 'NS_ERROR_DOM_QUOTA_REACHED' ||
                err.code === 22 ||          // some WebKit
                err.code === 1014           // some Firefox
            );

        if (isQuotaError) {
            showMessage(
                "Storage quota exceeded. Consider exporting and clearing old data.",
                'error'
            );
        } else {
            // For other errors, just log them.
            // If you really want a toast, you could downgrade it to 'warning':
            // showMessage(`Problem saving ${key}. See console for details.`, 'warning');
        }
    }
}

function loadCollectionFromStorage(key, fallback = []) {
    try {
        const raw = localStorage.getItem(key);
        if (!raw) return fallback;

        const parsed = JSON.parse(raw);
        return Array.isArray(parsed) ? parsed : fallback;
    } catch (err) {
        console.error(`Error loading ${key} from localStorage:`, err);
        showMessage(`Could not load ${key} from local storage. Using defaults.`, 'warning');
        return fallback;
    }
}
       
// --- GEOGRAPHY HELPER FUNCTIONS ---

/** Converts degrees to radians. */
function toRad(degrees) {
    return degrees * (Math.PI / 180);
}

/** Converts radians to degrees. */
function toDeg(radians) {
    return radians * (180 / Math.PI);
}

/**
 * Normalises a longitude delta to the range [-180, 180] degrees.
 * This is what makes things behave correctly across the International Date Line.
 */
function normaliseDeltaLonDegrees(lon1Deg, lon2Deg) {
    let d = lon2Deg - lon1Deg; // in degrees
    if (d > 180) d -= 360;
    if (d < -180) d += 360;
    return d;
}

/**
 * Returns the great-circle distance between two WGS84 coordinates in metres.
 * Works globally (north/south of equator, across date line, any hemisphere).
 */
function distanceMeters(lat1Deg, lon1Deg, lat2Deg, lon2Deg) {
    const R = 6371000; // mean Earth radius in metres

    const φ1 = toRad(lat1Deg);
    const φ2 = toRad(lat2Deg);
    const Δφ = toRad(lat2Deg - lat1Deg);
    const Δλ = toRad(normaliseDeltaLonDegrees(lon1Deg, lon2Deg));

    const sinΔφ2 = Math.sin(Δφ / 2);
    const sinΔλ2 = Math.sin(Δλ / 2);

    const a =
        sinΔφ2 * sinΔφ2 +
        Math.cos(φ1) * Math.cos(φ2) * sinΔλ2 * sinΔλ2;

    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));

    return R * c;
}

/**
 * Returns the initial bearing (forward azimuth) from point 1 to point 2
 * in degrees from true North, normalised to [0, 360).
 *
 * This also uses the normalised longitude delta so it behaves
 * correctly when crossing the date line.
 */
function initialBearingDegrees(lat1Deg, lon1Deg, lat2Deg, lon2Deg) {
    const φ1 = toRad(lat1Deg);
    const φ2 = toRad(lat2Deg);
    const Δλ = toRad(normaliseDeltaLonDegrees(lon1Deg, lon2Deg));

    const y = Math.sin(Δλ) * Math.cos(φ2);
    const x =
        Math.cos(φ1) * Math.sin(φ2) -
        Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);

    let θ = Math.atan2(y, x); // in radians, -π..+π
    let bearing = (toDeg(θ) + 360) % 360; // into [0, 360)
    return bearing;
}

/**
 * Converts a bearing in degrees into a human-friendly compass label.
 * precision:
 *   4  -> N, E, S, W
 *   8  -> N, NE, E, SE, S, SW, W, NW
 *   16 -> N, NNE, NE, ENE, E, ... (default)
 */
function bearingToCompassPoint(bearingDeg, precision = 16) {
    const dirs =
        precision === 4
            ? ['N', 'E', 'S', 'W']
            : precision === 8
            ? ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW']
            : [
                  'N', 'NNE', 'NE', 'ENE',
                  'E', 'ESE', 'SE', 'SSE',
                  'S', 'SSW', 'SW', 'WSW',
                  'W', 'WNW', 'NW', 'NNW'
              ];

    const step = 360 / dirs.length;
    const normalised = ((bearingDeg % 360) + 360) % 360; // 0..360
    const index = Math.round(normalised / step) % dirs.length;
    return dirs[index];
}

/** Clamps a number between a minimum and maximum value. */
const clamp = (num, min, max) => Math.min(Math.max(num, min), max);

/** Calculates the diameter (in meters) for the confidence circle: Accuracy * 2. */
function getCircleDiameter(accuracyInMeters) {
    if (typeof accuracyInMeters === 'number' && accuracyInMeters > 0) {
        return (accuracyInMeters * 2).toFixed(1); // Diameter = 2 * radius
    }
    return 'N/A';
}

// --- MOVEMENT & GUIDANCE HELPER FUNCTIONS ---

/**
 * Records a new smoothed movement sample.
 * Called from the live map GPS watch each time we get a new reading.
 */
function recordMovementSample(lat, lon) {
    const now = Date.now();
    movementHistory.push({ lat, lon, time: now });

    // Trim to recent history only
    if (movementHistory.length > MOVEMENT_HISTORY_MAX_LENGTH) {
        movementHistory.shift();
    }
}

/**
 * Computes the bearing of recent movement based on the movementHistory array.
 * Returns:
 *   - a bearing in degrees [0, 360) if we have enough motion
 *   - null if we don't have enough recent movement yet
 */
/**
 * Computes the bearing of recent movement based on the movementHistory array.
 * Returns:
 *   - a bearing in degrees [0, 360) if we have enough motion
 *   - null if we don't have enough recent movement yet
 */
function computeMovementBearingDegrees() {
    if (!movementHistory || movementHistory.length < 2) {
        return null;
    }

    const now = Date.now();

    // Keep only samples from the recent window
    movementHistory = movementHistory.filter(p => now - p.time <= MOVEMENT_HISTORY_MAX_AGE_MS);

    if (movementHistory.length < 2) {
        return null;
    }

    const first = movementHistory[0];
    const last = movementHistory[movementHistory.length - 1];

    // Distance moved in metres (use existing distanceMeters helper)
    const dist = distanceMeters(first.lat, first.lon, last.lat, last.lon);

    if (dist < MOVEMENT_MIN_DISTANCE_METERS) {
        // Too little movement to get a stable direction
        return null;
    }

    // Bearing of travel from first point in history to the most recent
    return initialBearingDegrees(first.lat, first.lon, last.lat, last.lon);
}
        
// --- END GEOGRAPHY HELPER FUNCTIONS ---


        // --- HELPER FUNCTIONS ---

// ======================================
// SHARED MODAL HELPERS
// ======================================
function openModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;

    modal.style.display = 'block';

    // Make sure we start at the top of the modal + page
    setTimeout(() => {
        modal.scrollTop = 0;
        window.scrollTo({ top: 0, behavior: 'smooth' });
    }, 50);
}

function closeModal(modalId) {
    const modal = document.getElementById(modalId);
    if (!modal) return;
    modal.style.display = 'none';
}
// ======================================
// SHARED FORM HELPERS
// ======================================

function attachFormSubmitHandler(formId, handler) {
    const form = document.getElementById(formId);
    if (!form) return null;

    form.removeEventListener('submit', handler);
    form.addEventListener('submit', handler);

    return form;
}

        
async function openEditFindModal(findId) {
    const find = finds.find(f => f.id === findId);
    if (!find) {
        showMessage('Find not found.', 'error');
        return;
    }

    const modal = document.getElementById('edit-find-modal');
    const form  = document.getElementById('edit-find-form');
    if (!modal || !form) return;

    // Core fields
    form['findId'].value           = find.id;
    form['findDescription'].value  = find.description || '';
    form['findType'].value         = find.type || 'Unknown';
    form['findVDI'].value          = find.vdi || '';
    form['findDepth'].value        = find.depth || '';
    form['findCoords'].value       = find.coordinates || '';
    form['findAccuracy'].value     = find.accuracy || '';

    // Photos for editing: resolve IndexedDB refs -> object URLs, or use existing data URLs
    try {
        if (Array.isArray(find.photos) && find.photos.length > 0) {
            const first = find.photos[0];
            if (isIndexedDbPhotoRef(first)) {
                // Load from IndexedDB
                currentEditFindPhotos = await loadPhotoUrlsFromRefs(find.photos);
            } else {
                // Legacy: direct data URLs
                currentEditFindPhotos = find.photos.slice();
            }
        } else if (find.targetPhotoData) {
            currentEditFindPhotos = [find.targetPhotoData];
        } else if (find.photoData) {
            currentEditFindPhotos = [find.photoData];
        } else {
            currentEditFindPhotos = [];
        }
    } catch (e) {
        console.error('Error preparing edit find photos:', e);
        currentEditFindPhotos = [];
    }

    // Update preview + hidden field from currentEditFindPhotos
    updateEditFindPhotoPreview();

    // Attach the submit handler via shared helper
    attachFormSubmitHandler('edit-find-form', handleEditFindSubmit);

    // Show the modal
    openModal('edit-find-modal');
}
function closeEditFindModal() {
    closeModal('edit-find-modal');
}

/**
 * Save changes from Edit Find form back into the find object.
 * This now supports multiple photos via find.photos.
 */
async function handleEditFindSubmit(event) {
    event.preventDefault();
    const form = event.target;

    const id = form['findId'].value;
    const find = finds.find(f => f.id === id);
    if (!find) {
        showMessage('Find not found.', 'error');
        closeEditFindModal();
        return;
    }

    const desc = form['findDescription'].value.trim();
    if (!desc) {
        showMessage('Description is required.', 'error');
        return;
    }

    // Core fields
    find.description = desc;
    find.type        = form['findType'].value || 'Unknown';
    find.vdi         = form['findVDI'].value.trim();
    find.depth       = form['findDepth'].value.trim();
    find.coordinates = form['findCoords'].value.trim();
    find.accuracy    = form['findAccuracy'].value.trim();

    // --- Photos: read JSON array from hidden field, then save into IndexedDB ---
    let photosDataUrls = [];
    if (form['findPhotoData']) {
        const raw = form['findPhotoData'].value;

        if (raw) {
            try {
                const temp = JSON.parse(raw);
                if (Array.isArray(temp)) {
                    photosDataUrls = temp.filter(p => typeof p === 'string' && p.length > 0);
                } else if (typeof temp === 'string' && temp.length > 0) {
                    photosDataUrls = [temp];
                }
            } catch (e) {
                // If it's not valid JSON, fall back to treating it as a single URL
                if (typeof raw === 'string' && raw.length > 0) {
                    photosDataUrls = [raw];
                }
            }
        }
    }

    let photoRefs = [];
    try {
        photoRefs = await saveDataUrlsAsPhotoRefs(photosDataUrls);
    } catch (e) {
        console.error('Error saving edited find photos to IndexedDB:', e);
        photoRefs = [];
    }

    const primaryDataUrl = photosDataUrls[0] || '';
    const primaryRef     = photoRefs[0] || '';

    // Store new IndexedDB-backed structure
    find.photos         = photoRefs;
    find.findPhotoRef   = primaryRef;
    find.targetPhotoData = photoRefs.length > 0 ? '' : primaryDataUrl;

    find.updatedAt = Date.now();

    saveFindsToLocalStorage();

    closeEditFindModal();
    showMessage('Find updated.', 'success');
    render();
}
 function deleteFind(findId) {
    const find = finds.find(f => f.id === findId);
    if (!find) {
        showMessage('Find not found.', 'error');
        return;
    }

    const executeDelete = () => {
        finds = finds.filter(f => f.id !== findId);
        saveFindsToLocalStorage();
        showMessage('Find deleted.', 'success');
        render();
    };

    const title = `Confirm Delete Find: ${find.description || 'this find'}`;
    const body  = `
        Are you sure you want to permanently delete this find?<br>
        <span class="text-sm text-gray-600">This cannot be undone.</span>
    `;

    showConfirmationModal(title, body, executeDelete);
}


        /** Generates a simple unique ID. */
        function generateId() {
            return Date.now().toString(36) + Math.random().toString(36).substring(2, 5);
        }

        /** Formats a timestamp into a readable date string. */
        function formatDate(timestamp) {
            const date = new Date(timestamp);
            return date.toLocaleDateString();
        }
/**
 * Takes a target + its parent survey and snapshots it into the permanent Finds library.
 * The Find is independent: if the survey/target are later deleted, this record remains.
 */
/**
 * Takes a target + its parent survey and snapshots it into the permanent Finds library.
 * The Find is independent: if the survey/target are later deleted, this record remains.
 */
        /** Saves the current surveys and profile data to Local Storage. */
function saveFindsToLocalStorage() {
    try {
        localStorage.setItem('geoFindFinds', JSON.stringify(finds));
    } catch (e) {
        console.error("Error saving Finds to Local Storage:", e);
        // No toast here – we don't want to confuse the user
    }
}

function createFindFromTarget(target, survey) {
    // Photos from the target (we now prefer IndexedDB refs)
    let photoRefs = [];
    let thumbDataUrl = '';

    if (Array.isArray(target.photos) && target.photos.length) {
        const first = target.photos[0];

        if (isIndexedDbPhotoRef(first)) {
            // New style: photos already refer to IndexedDB blobs
            photoRefs = target.photos.slice();
            thumbDataUrl = '';
        } else {
            // Legacy style: target.photos are data URLs (very rare now)
            photoRefs = []; // we won't convert them here
            thumbDataUrl = target.photos[0] || target.targetPhotoData || target.photoDataUrl || '';

        }
    } else if (target.targetPhotoData || target.photoDataUrl) {
        // No array, just a single thumbnail
        thumbDataUrl = target.targetPhotoData || target.photoDataUrl;
    }

    const primaryRef = photoRefs[0] || '';

    const find = {
        id: generateId(),

        // Links back to original context (not required to still exist)
        surveyId: survey.id,
        surveyName: survey.name || 'Untitled survey',
        surveyDescription: survey.description || '',
        targetId: target.id,

        // Core fields
        description: target.description || 'Unnamed Find',
        vdi: target.vdi || '',
        depth: target.depth || '',
        type: target.type || 'Unknown',
        coordinates: target.coordinates || '',
        accuracy: target.accuracy || '',
        centerOnMap: !!target.centerOnMap,

        // Media
        targetPhotoData: thumbDataUrl,  // thumbnail for UI
        photos: photoRefs,              // IndexedDB references
        findPhotoRef: primaryRef,       // first ref for convenience

        // Metadata
        statusAtSave: target.status || '',
        user: target.user || userProfile.name || '',
        detector: target.detector || userProfile.detector || ''
    };

    finds.push(find);

    // Save finds separately (no scary warnings)
    saveFindsToLocalStorage();

    // Optional small vibration for mobile feedback (safe no-op on unsupported devices)
    if (navigator.vibrate) {
        navigator.vibrate(120);
    }
}
        
function saveSurveysToLocalStorage() {
    try {
        localStorage.setItem('geoFindSurveys', JSON.stringify(surveys));
        localStorage.setItem('geoFindProfile', JSON.stringify(userProfile));
        localStorage.setItem('geoFindUserId', userId);
        // CRITICAL: Also save finds here to ensure they persist on refresh
        localStorage.setItem('geoFindFinds', JSON.stringify(finds));
    } catch (e) {
        console.error("Error saving to Local Storage:", e);
        // Only show message for actual localStorage errors (like quota exceeded)
        if (e.name === 'QuotaExceededError') {
            showMessage("Storage quota exceeded. Consider exporting and clearing old data.", 'error');
        }
    }
}        /** Loads data from Local Storage. Initializes if no data found. */
    function loadDataFromLocalStorage() {
    try {
        const storedSurveys = localStorage.getItem('geoFindSurveys');
        const storedFinds   = localStorage.getItem('geoFindFinds');   // <--- NEW
        const storedProfile = localStorage.getItem('geoFindProfile');
        const storedUserId  = localStorage.getItem('geoFindUserId');

                if (storedSurveys) {
                    surveys = JSON.parse(storedSurveys);
                } else {
                    // Initialize with sample data if nothing is found
                    surveys = [
                        {
                            id: generateId(),
                            name: "Sample Grid Survey 2025",
                            description: "Testing a 10x10 metre grid near the old oak tree.",
                            status: 'Open',
                            creationDate: Date.now(),
                            dateLastChanged: Date.now(),
                            targets: [
                                // Sample targets with valid coordinates and accuracy for mapping
                                { id: generateId(), description: "Small Copper Coin", vdi: "28", depth: "4in", type: "Coin", status: "Signal Detected", time: Date.now(), coordinates: "50.256800, -5.234500", accuracy: "5.5", user: userProfile.name, detector: userProfile.detector },
                                { id: generateId(), description: "Lead Button", vdi: "30", depth: "6in", type: "Relic", status: "Signal Detected", time: Date.now() - 100000, coordinates: "50.257000, -5.234100", accuracy: "2.1", user: userProfile.name, detector: userProfile.detector },
                                { id: generateId(), description: "Iron Spike", vdi: "8", depth: "12in", type: "Iron Junk", status: "Signal Ignored", time: Date.now() - 3600000, coordinates: "50.256700, -5.234800", accuracy: "10.0", user: userProfile.name, detector: userProfile.detector }
                            ],
                            surveyPhotoData: ''
                        }
                    ];
                }
        // Load Finds (can be empty even if surveys exist)
        if (storedFinds) {
            finds = JSON.parse(storedFinds);
        } else {
            finds = [];
        }

                if (storedProfile) {
                    // Update userProfile only if storedProfile exists and is valid
                    const tempProfile = JSON.parse(storedProfile);
                    if (tempProfile && tempProfile.name && tempProfile.detector) {
                         userProfile = tempProfile;
                    }
                } else {
                    // Re-initialize sample profile if needed
                    userProfile = { name: "Sample Dectorist", detector: "Minelab Equinox" };
                }

                if (storedUserId) {
                    userId = storedUserId;
                } else {
                    userId = generateId();
                }

                saveSurveysToLocalStorage(); // Ensure initial data and ID are saved
                refreshActiveTrackFromSurveys(); // NEW: hydrate any persisted active track

            } catch (e) {
                console.error("Error loading from Local Storage:", e);
                showMessage("Error loading data. Data may be reset.", 'error');
            }
        }

        /** Renders the current page content into the main container. */
        function render() {
            const appContent = document.getElementById('app-content');
            let contentHtml = '';

            // Update navigation button styles
            document.querySelectorAll('.nav-btn').forEach(btn => {
                if (btn.dataset.page === currentPage) {
                    btn.classList.add('text-primary', 'bg-gray-100');
                    btn.classList.remove('text-gray-500', 'hover:text-primary');
                } else {
                    btn.classList.remove('text-primary', 'bg-gray-100');
                    btn.classList.add('text-gray-500', 'hover:text-primary');
                }
            });

// In the render function...
        
        // Cleanup: Always clear the interval and GPS watch when rendering a new page content,
        // the Compass page will restart it if needed.
        if (autoRefreshIntervalId) {
            clearInterval(autoRefreshIntervalId);
            autoRefreshIntervalId = null;
            console.log("Auto-refresh stopped.");
        }
        // ADDED: Clear the live map GPS watch
        if (liveMapWatchId) {
            navigator.geolocation.clearWatch(liveMapWatchId);
            liveMapWatchId = null;
            bestLiveAccuracy = Infinity;
            smoothedUserCoords = null;
            console.log("Live Map GPS Watch stopped.");
        }
// If we leave the Compass page, clear any "recording" flag
        if (activeTrackId && activeTrackSurveyId && currentPage !== 'Compass') {
            const active = getActiveTrack();
            if (active && active.track) {
                active.track.isRecording = false;
                saveSurveysToLocalStorage();
            }
            activeTrackId = null;
            activeTrackSurveyId = null;
            console.log("Active track recording stopped because Compass page was left.");
        }


switch (currentPage) {
    case 'Home':
        contentHtml = renderHomePage();
        break;
    case 'Targets':
        contentHtml = renderTargetsPage();
        break;
    case 'Finds':                           // <--- NEW
        contentHtml = renderFindsPage();
        break;
    case 'Compass':
        contentHtml = renderCompassPage(false);
        break;
    case 'Settings':
        contentHtml = renderSettingsPage();
        break;
    default:
        contentHtml = `<div class="p-4 text-center">Page Not Found</div>`;
}
            appContent.innerHTML = contentHtml;
            // Re-attach event listeners specific to the rendered page
            attachPageEventListeners();
        }

/** Attaches event listeners for dynamically rendered elements */
function attachPageEventListeners() {
    // Home Page (New Survey Button)
    const newSurveyBtn = document.getElementById('new-survey-btn');
    if (newSurveyBtn) {
        newSurveyBtn.addEventListener('click', showNewSurveyModal);
    }

    // Targets Page (Log New Target Button)
    const addTargetBtn = document.getElementById('add-target-btn');
    if (addTargetBtn) {
        addTargetBtn.addEventListener('click', showNewTargetModal);
    }

    // Settings Page (Export/Import Buttons)
    const exportBtn = document.getElementById('export-data-btn');
    if (exportBtn) {
        exportBtn.addEventListener('click', exportData);
    }
    const importBtn = document.getElementById('import-data-btn');
    if (importBtn) {
        importBtn.addEventListener('click', importData);
    }
    const resetBtn = document.getElementById('reset-all-data-btn');
    if (resetBtn) {
    resetBtn.addEventListener('click', resetAllAppData);
}


    // --- FINDS PAGE: search + filters ---
    const findsSearchInput  = document.getElementById('finds-search-input');
    const findsTypeSelect   = document.getElementById('finds-type-select');
    const findsSurveySelect = document.getElementById('finds-survey-select');
    const clearFindsBtn     = document.getElementById('clear-finds-filters-btn');

    if (findsSearchInput || findsTypeSelect || findsSurveySelect || clearFindsBtn) {
        if (findsSearchInput) {
            findsSearchInput.addEventListener('input', (e) => {
                findsFilter.query = e.target.value || '';
                render();
            });
        }
        if (findsTypeSelect) {
            findsTypeSelect.addEventListener('change', (e) => {
                findsFilter.type = e.target.value || 'All';
                render();
            });
        }
        if (findsSurveySelect) {
            findsSurveySelect.addEventListener('change', (e) => {
                findsFilter.surveyId = e.target.value || 'All';
                render();
            });
        }
        if (clearFindsBtn) {
            clearFindsBtn.addEventListener('click', () => {
                findsFilter = { query: '', type: 'All', surveyId: 'All' };
                render();
            });
        }
    }

    // --- FINDS PAGE: card Edit / Delete buttons ---
    const findEditButtons = document.querySelectorAll('.find-card-edit-btn');
    findEditButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-find-id');
            if (!id) return;
            openEditFindModal(id);
        });
    });

    const findDeleteButtons = document.querySelectorAll('.find-card-delete-btn');
    findDeleteButtons.forEach(btn => {
        btn.addEventListener('click', () => {
            const id = btn.getAttribute('data-find-id');
            if (!id) return;
            deleteFind(id);
        });
    });

    // --- COMPASS PAGE: track controls ---
    const startTrackBtn = document.getElementById('start-track-btn');
    if (startTrackBtn) {
        startTrackBtn.addEventListener('click', handleStartTrackClick);
    }

    const stopTrackBtn = document.getElementById('stop-track-btn');
    if (stopTrackBtn) {
        stopTrackBtn.addEventListener('click', handleStopTrackClick);
    }

    const trackCheckboxes = document.querySelectorAll('.track-visibility-toggle');
    if (trackCheckboxes && trackCheckboxes.length > 0) {
        trackCheckboxes.forEach(cb => {
            cb.addEventListener('change', (e) => {
                const trackId = e.target.getAttribute('data-track-id');
                toggleTrackVisibility(trackId, e.target.checked);
            });
        });
    }
        // After wiring up page-specific buttons, resolve any thumbnails
    if (typeof initialiseCardThumbnails === 'function') {
        initialiseCardThumbnails();
    }
}



        
function startTargetLocationWatch() {
    // 1. Get references to the HTML elements
    const coordsInput     = document.getElementById('target-coords');
    const accuracyInput   = document.getElementById('target-accuracy');

    const accuracyDisplayP = document.getElementById('gps-accuracy-display');
    const accuracyValueSpan = accuracyDisplayP
        ? accuracyDisplayP.querySelector('.font-semibold')
        : null;

    // This element is OPTIONAL – it may not exist
    const loadingIndicator = document.getElementById('gps-loading-indicator');

    // Local variable to track the best accuracy received so far
    let bestAccuracy = Infinity;

    // 2. Reset UI state for a new acquisition process
    if (coordsInput) {
        coordsInput.value = '';
        coordsInput.placeholder = 'Waiting for GPS lock...';
        coordsInput.disabled = true;
    }
    if (accuracyInput) {
        accuracyInput.value = '';
    }

    if (accuracyValueSpan) {
        accuracyValueSpan.textContent = 'N/A';
        accuracyValueSpan.className = 'font-semibold text-red-600';
    }
    if (accuracyDisplayP) {
        accuracyDisplayP.classList.add('hidden'); // Hide the visible P tag
    }
    if (loadingIndicator) {
        loadingIndicator.classList.remove('hidden'); // Only if it exists
    }

    if (!navigator.geolocation) {
        showMessage('Geolocation is not supported on this device.', 'error');
        if (coordsInput) {
            coordsInput.placeholder = 'Geolocation not supported';
            coordsInput.disabled = false;
        }
        return;
    }

    // 3. Start Watching (Stream)
    targetWatchId = navigator.geolocation.watchPosition(
        // Success Callback
        (position) => {
            const accuracy = position.coords.accuracy;

            // Only update if this reading is more accurate
            if (accuracy < bestAccuracy) {
                bestAccuracy = accuracy;

                const lat = position.coords.latitude.toFixed(6);
                const lon = position.coords.longitude.toFixed(6);

                if (coordsInput) {
                    coordsInput.value = `${lat}, ${lon}`;
                    coordsInput.placeholder = 'GPS Locked';
                    coordsInput.disabled = false;
                }

                if (accuracyInput) {
                    accuracyInput.value = accuracy.toFixed(2);
                }

                if (accuracyValueSpan) {
                    accuracyValueSpan.textContent = `${accuracy.toFixed(1)} meters`;

                    if (accuracy < 5) {
                        accuracyValueSpan.className = 'font-semibold text-green-600';
                    } else if (accuracy < 15) {
                        accuracyValueSpan.className = 'font-semibold text-yellow-600';
                    } else {
                        accuracyValueSpan.className = 'font-semibold text-red-600';
                    }
                }

                console.log(`New Best Accuracy: ${accuracy.toFixed(1)}m`);
            }

            // Hide loading / show accuracy display
            if (loadingIndicator) {
                loadingIndicator.classList.add('hidden');
            }
            if (accuracyDisplayP) {
                accuracyDisplayP.classList.remove('hidden');
            }
        },

        // Error Callback
  (error) => {
    console.error('GPS Watch Error:', error);

    if (loadingIndicator) {
        loadingIndicator.classList.add('hidden');
    }
    if (accuracyDisplayP && accuracyValueSpan) {
        accuracyDisplayP.classList.remove('hidden');
        accuracyValueSpan.textContent = 'Error';
        accuracyValueSpan.className = "font-semibold text-red-600";
    }
    if (coordsInput) {
        coordsInput.placeholder = 'GPS Error (Type Manually)';
        coordsInput.disabled = false;
    }

    // Quiet the UI: no toast, just console + placeholder guidance
    // (User sees "GPS Error (Type Manually)" in the field itself.)
},

        // Options
        {
            enableHighAccuracy: true,
            timeout: 30000,
            maximumAge: 0
        }
    );
}
        
        function stopTargetLocationWatch() {
    if (targetWatchId !== null) {
        navigator.geolocation.clearWatch(targetWatchId);
        targetWatchId = null;
        console.log("Target GPS Watch stopped.");
    }
}
        
// --- LIVE MAP GPS WATCH FUNCTIONS (New/Modified Logic) ---

        /** Starts a continuous, high-accuracy GPS stream that only updates the state when a reading is more accurate. 
         * Also starts the 5-second rendering interval.
         */
/** Starts a continuous, high-accuracy GPS stream that only updates the state when a reading is more accurate. 
 * Also starts the 5-second rendering interval.
 */
/** Starts a continuous, high-accuracy GPS stream for the live map. */
// --- LIVE MAP GPS WATCH FUNCTIONS (New/Modified Logic) ---

/** Starts a continuous, high-accuracy GPS stream for the live map
 *  and starts the auto-refresh interval to redraw the map.
 */
function startLiveMapLocationWatch() {
    if (!navigator.geolocation) {
        currentUserCoords = null;
        currentUserAccuracy = null;
        smoothedUserCoords = null;
        showMessage('Geolocation is not supported on this device.', 'error');
        return;
    }

    // Fresh run each time we arrive on the Compass page
    bestLiveAccuracy = Infinity;
    smoothedUserCoords = null;
    movementHistory = [];

    // Start / restart the GPS watch
    if (liveMapWatchId !== null) {
        navigator.geolocation.clearWatch(liveMapWatchId);
        liveMapWatchId = null;
    }

liveMapWatchId = navigator.geolocation.watchPosition(
        (position) => {
            const accuracy = position.coords.accuracy;

            // Raw latest reading
            currentUserCoords = {
                lat: position.coords.latitude,
                lon: position.coords.longitude
            };
            currentUserAccuracy = accuracy;

            // Update smoothed position used by the map
            updateSmoothedUserCoords(currentUserCoords.lat, currentUserCoords.lon);

            // Record this smoothed point into the movement history
            if (smoothedUserCoords) {
                recordMovementSample(smoothedUserCoords.lat, smoothedUserCoords.lon);
            }

            // NEW: if we’re recording a track, log a point using the smoothed location
            if (smoothedUserCoords && activeTrackId && activeTrackSurveyId) {
                logPointToActiveTrack(smoothedUserCoords.lat, smoothedUserCoords.lon, accuracy);
            }

            // Track best accuracy (for logging/info)
            if (accuracy < bestLiveAccuracy) {
                bestLiveAccuracy = accuracy;
            }

            // ... rest of your logging code stays the same ...

            console.log(
                `Live Map position (raw): ${currentUserCoords.lat.toFixed(6)}, ` +
                `${currentUserCoords.lon.toFixed(6)} (acc: ${accuracy.toFixed(1)}m, best: ${bestLiveAccuracy.toFixed(1)}m)`
            );

            if (smoothedUserCoords) {
                console.log(
                    `Live Map position (smoothed): ${smoothedUserCoords.lat.toFixed(6)}, ` +
                    `${smoothedUserCoords.lon.toFixed(6)}`
                );
            }
        },
        (error) => {
            currentUserCoords = null;
            currentUserAccuracy = null;
            smoothedUserCoords = null;
            console.error('Live Map GPS Watch Error:', error);
        },
        {
            enableHighAccuracy: true,
            maximumAge: 0
        }
    );

    // Start the auto-refresh interval (if not already running)
    if (autoRefreshIntervalId === null) {
        autoRefreshIntervalId = setInterval(() => {
            updateMapWithUserLocationAndRender();
        }, 3000); // 3 seconds
        console.log('Live Map GPS Watch and auto-refresh interval started.');
    }
}

/** Wrapper function to re-render Compass page for auto-refresh using the latest watched GPS data. */
function triggerImportSurvey() {
    importSurveyWithPhotosFromFile();
}

        
    function updateMapWithUserLocationAndRender() {
    // The GPS data is updated asynchronously by startLiveMapLocationWatch().
    // We just trigger the re-render here.
    const appContent = document.getElementById('app-content');

    // Only re-render if we are still on the Compass page
    if (currentPage === 'Compass') {
        appContent.innerHTML = renderCompassPage(true);
        attachPageEventListeners();
    }
}
        // --- MODAL & TOAST FUNCTIONS ---

        /** Shows a temporary notification toast. */
/** Shows a temporary, highly visible notification toast (top-centre). */
/** Shows a temporary, highly visible notification toast (top-centre). */
function showMessage(message, type = 'info') {
    const toast = document.getElementById('message-toast');
    if (!toast) return;

    // Clear any old fade timers
    if (toast._hideTimer) {
        clearTimeout(toast._hideTimer);
        toast._hideTimer = null;
    }
    if (toast._removeTimer) {
        clearTimeout(toast._removeTimer);
        toast._removeTimer = null;
    }

    toast.textContent = message;

    // Strong background colours
    const bgColor =
        type === 'success' ? 'bg-green-600'
        : type === 'error' ? 'bg-red-700'
        : type === 'warning' ? 'bg-yellow-600'
        : 'bg-gray-900';

    toast.className = [
        'fixed',
        'top-20',
        'left-1/2',
        '-translate-x-1/2',
        'z-50',
        'px-5',
        'py-3',
        'rounded-xl',
        'text-white',
        'font-semibold',
        'shadow-2xl',
        'border',
        'border-white/30',
        'opacity-100',
        'transition-opacity',
        'duration-400'
    ].join(' ') + ' ' + bgColor;

    // Fade out after 2.5 seconds
    toast._hideTimer = setTimeout(() => {
        toast.classList.add('opacity-0');
    }, 2500);

    // Remove (display:none) after the fade finishes
    toast._removeTimer = setTimeout(() => {
        toast.style.display = 'none';
    }, 3000);

    // Ensure it's visible again on next message
    toast.style.display = 'block';
}

        
      /** Shows the generic confirmation modal. */
        function showConfirmationModal(title, message, onConfirmCallback) {
            const modal = document.getElementById('confirmation-modal');
            document.getElementById('confirm-title').innerHTML = title;
            document.getElementById('confirm-message').innerHTML = message;
            
            const yesBtn = document.getElementById('confirm-yes-btn');
            const noBtn = document.getElementById('confirm-no-btn');

            const handleYes = () => {
                onConfirmCallback();
                closeConfirmationModal();
                yesBtn.removeEventListener('click', handleYes);
            };

            yesBtn.onclick = handleYes;
            noBtn.onclick = closeConfirmationModal;
            
            modal.style.display = 'block';
        }

        /** Closes the generic confirmation modal. */
        function closeConfirmationModal() {
            document.getElementById('confirmation-modal').style.display = 'none';
        }

    /** Shows the New Survey Modal and attaches the submit listener. */
function showNewSurveyModal() {
    // Reset the form whenever the modal is opened
    const form = document.getElementById('new-survey-form');
    if (form) {
        form.reset();
    }

    // Reset photo UI using shared helper
    initPhotoUI('', {
        statusId:  'new-survey-photo-status',
        wrapperId: 'new-survey-photo-preview-wrapper',
        imgId:     'new-survey-photo-preview',
        hiddenId:  'new-survey-photo-data'
    }, {
        empty: 'No photo captured yet.'
    });

    // Use shared helper to attach the submit listener safely
    attachFormSubmitHandler('new-survey-form', handleNewSurveySubmit);

    // Show the modal via shared helper
    openModal('new-survey-modal');
}

/** Closes the New Survey Modal. */
function closeNewSurveyModal() {
    closeModal('new-survey-modal');
}

async function handleNewSurveySubmit(event) {
    event.preventDefault();

    const form = event.target;
    const name = form['surveyName'].value.trim();
    const description = form['surveyDescription'].value.trim() || 'No description provided.';
    const now = Date.now();

    if (!name) {
        showMessage('Survey Name is required.', 'error');
        return;
    }

    // Convert survey photo to IndexedDB reference
    const surveyPhotoDataUrl = form['surveyPhotoData']?.value || '';
    let surveyPhotoRef = '';
    
    if (surveyPhotoDataUrl) {
        try {
            const photoRefs = await saveDataUrlsAsPhotoRefs([surveyPhotoDataUrl]);
            surveyPhotoRef = photoRefs[0] || '';
        } catch (e) {
            console.error('Error saving survey photo to IndexedDB:', e);
        }
    }

    // 1. Close any currently open survey
    surveys.forEach(s => {
        if (s.status === 'Open') {
            s.status = 'Active';
            s.dateLastChanged = now;
        }
    });

    // 2. Create the new survey object
    const newSurvey = {
        id: generateId(),
        name: name,
        description: description,
        status: 'Open',
        creationDate: now,
        dateLastChanged: now,
        targets: [],
        surveyPhotoRef: surveyPhotoRef,           // NEW: IndexedDB reference
        surveyPhotoData: surveyPhotoRef ? '' : surveyPhotoDataUrl
  };

    // 3. Add the new survey to the start of the list
    surveys.unshift(newSurvey);

    // 4. Save and re-render
    saveSurveysToLocalStorage();
    closeNewSurveyModal();
    showMessage(`New Survey '${name}' created and is now OPEN!`, 'success');
    render();
}
        // ============================
// EDIT OPEN SURVEY (NAME + PHOTO)
// ============================

async function showEditSurveyModal() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('There is no open survey to edit.', 'warning');
        return;
    }

    const form = document.getElementById('edit-survey-form');
    if (!form) return;

    // Populate fields
    form['surveyId'].value = openSurvey.id;
    form['surveyName'].value = openSurvey.name || '';
    form['surveyDescription'].value = openSurvey.description || '';

    // Load photo from IndexedDB if needed
    let displayPhotoUrl = openSurvey.surveyPhotoData || '';
    
    if (openSurvey.surveyPhotoRef && isIndexedDbPhotoRef(openSurvey.surveyPhotoRef)) {
        try {
            const photoUrl = await getPhotoUrlFromRef(openSurvey.surveyPhotoRef);
            if (photoUrl) {
                displayPhotoUrl = photoUrl;
            }
        } catch (e) {
            console.error('Error loading survey photo for editing:', e);
        }
    }

    // Initialize photo UI
    initPhotoUI(
        displayPhotoUrl,
        {
            statusId: 'edit-survey-photo-status',
            wrapperId: 'edit-survey-photo-preview-wrapper',
            imgId: 'edit-survey-photo-preview',
            hiddenId: 'edit-survey-photo-data'
        },
        {
            existing: 'Existing survey photo loaded. Tap "Take / Choose Photo" to replace.',
            empty: 'No survey photo captured yet.'
        }
    );

    // Safely attach submit handler
    attachFormSubmitHandler('edit-survey-form', handleEditSurveySubmit);

    openModal('edit-survey-modal');
}
function closeEditSurveyModal() {
    closeModal('edit-survey-modal');
}

async function handleEditSurveySubmit(event) {
    event.preventDefault();
    const form = event.target;

    const id = form['surveyId'].value;
    const survey = surveys.find(s => s.id === id);

    // Enforce "only edit the Open survey"
    if (!survey || survey.status !== 'Open') {
        showMessage('Only the open survey can be edited.', 'error');
        closeEditSurveyModal();
        return;
    }

    const name = form['surveyName'].value.trim();
    if (!name) {
        showMessage('Survey Name is required.', 'error');
        return;
    }

    const description = form['surveyDescription'].value.trim() || 'No description provided.';
    const photoDataUrl = form['surveyPhotoData']?.value || '';

    // Convert to IndexedDB reference
    let surveyPhotoRef = survey.surveyPhotoRef || ''; // Keep existing ref if no change
    
    if (photoDataUrl && photoDataUrl !== survey.surveyPhotoData) {
        // New photo selected - save to IndexedDB
        try {
            const photoRefs = await saveDataUrlsAsPhotoRefs([photoDataUrl]);
            surveyPhotoRef = photoRefs[0] || '';
        } catch (e) {
            console.error('Error saving edited survey photo to IndexedDB:', e);
        }
    }

    survey.name = name;
    survey.description = description;
    survey.surveyPhotoRef  = surveyPhotoRef;                       // NEW: IndexedDB reference
    survey.surveyPhotoData = surveyPhotoRef ? '' : photoDataUrl;   // Keep base64 only if IDB failed
    survey.dateLastChanged = Date.now();

    saveSurveysToLocalStorage();
    closeEditSurveyModal();
    showMessage('Open survey updated.', 'success');
    render();
}
        
        /** Shows the New Target Modal. */
/** Shows the New Target Modal. */
function showNewTargetModal() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        return showMessage(
            'Cannot log target. Please open a survey first on the Home page.',
            'warning'
        );
    }

    // 1. Set survey name + id in the modal
    const headerSpan = document.getElementById('current-target-survey-name');
    if (headerSpan) {
        headerSpan.textContent = openSurvey.name;
    }
    const surveyIdHidden = document.getElementById('new-target-survey-id');
    if (surveyIdHidden) {
        surveyIdHidden.value = openSurvey.id;
    }

    // 2. Reset the form
    const form = document.getElementById('new-target-form');
    if (form) {
        form.reset();
    }

    // 3. Reset NEW TARGET photo state + UI (IMPORTANT!)
    currentNewTargetPhotos = [];

    const statusSpan  = document.getElementById('new-target-photo-status');
    const wrapper     = document.getElementById('new-target-photo-preview-wrapper');
    const hiddenField = document.getElementById('target-photo-data');
    const fileInput   = document.getElementById('new-target-photo-input');

    if (statusSpan) {
        statusSpan.textContent = 'No photo captured yet.';
    }
    if (wrapper) {
        wrapper.classList.add('hidden');
        wrapper.innerHTML = ''; // clear any old thumbnails
    }
    if (hiddenField) {
        // store an empty array, ready for JSON.parse
        hiddenField.value = '[]';
    }
    if (fileInput) {
        fileInput.value = ''; // clear any previous selection
    }

    // 4. Request GPS location
    startTargetLocationWatch();

    // 5. Attach the submit listener via shared helper
    attachFormSubmitHandler('new-target-form', handleNewTargetSubmit);

    // 6. Display modal via shared helper
    openModal('new-target-modal');
}

/** Closes the New Target Modal. */
function closeNewTargetModal() {
    stopTargetLocationWatch();
    closeModal('new-target-modal');
}

// NOTE: now async because we talk to IndexedDB
async function handleNewTargetSubmit(event) {
    event.preventDefault();
    const form = event.target;

    // Which survey are we saving to?
    const surveyId = form['targetSurveyId']?.value;
    const survey = surveys.find(s => s.id === surveyId);

    if (!survey) {
        showMessage('Error: Survey not found for this target.', 'error');
        return;
    }

    const newDescription = form['targetDescription'].value.trim();
    const newVDI         = form['targetVDI'].value.trim() || 'N/A';
    const newDepth       = form['targetDepth'].value.trim() || 'Unknown';
    const newType        = form['targetType'].value;
    const newCoords      = form['targetCoords'].value.trim() || 'No GPS logged';
    const newAccuracy    = form['targetAccuracy'].value.trim() || 'N/A';

    if (!newDescription) {
        showMessage('Description / Find Name is required.', 'error');
        return;
    }

    // Centre on Map radios may or may not exist
    let centerOnMap = false;
    const centerField = form['targetCenterOnMap'];
    if (centerField) {
        const centerOnMapValue = centerField.value;
        centerOnMap = (centerOnMapValue === 'Yes');
    }

    // --- PHOTO HANDLING (Step 1: still uses data URLs in memory) ---

    // Hidden field currently stores JSON.stringify(currentNewTargetPhotos)
    let photosDataUrls = [];
    const rawPhotoField = form['targetPhotoData']?.value;

    if (rawPhotoField) {
        try {
            const parsed = JSON.parse(rawPhotoField);
            if (Array.isArray(parsed)) {
                photosDataUrls = parsed.filter(p => typeof p === 'string' && p.length > 0);
            } else if (typeof parsed === 'string' && parsed.length > 0) {
                photosDataUrls = [parsed];
            }
        } catch (e) {
            // Not valid JSON? Treat as single data URL
            if (typeof rawPhotoField === 'string' && rawPhotoField.length > 0) {
                photosDataUrls = [rawPhotoField];
            }
        }
    }

    // Save these data URLs into IndexedDB and get back lightweight references
    let photoRefs = [];
    try {
        photoRefs = await saveDataUrlsAsPhotoRefs(photosDataUrls);
    } catch (e) {
        console.error('Error saving photos to IndexedDB:', e);
        // We can still proceed, just without IDB refs.
        photoRefs = [];
    }

 const primaryDataUrl = photosDataUrls[0] || '';
const primaryRef     = photoRefs[0] || '';

const newTarget = {
    id: generateId(),
    description: newDescription,
    vdi: newVDI,
    depth: newDepth,
    type: newType,
    status: 'Hole Dug',
    time: Date.now(),
    coordinates: newCoords,
    accuracy: newAccuracy,
    user: userProfile.name,
    detector: userProfile.detector,
    centerOnMap,

    // Photos: use IndexedDB refs as the truth
    photos: photoRefs,
    targetPhotoRef: primaryRef,

    // IMPORTANT:
    // If we successfully saved to IndexedDB (photoRefs.length > 0),
    // DO NOT keep a base64 copy in localStorage.
    // Only keep base64 if IDB save failed.
    targetPhotoData: photoRefs.length > 0 ? '' : primaryDataUrl
};
  
    if (!Array.isArray(survey.targets)) {
        survey.targets = [];
    }
    survey.targets.unshift(newTarget);
    survey.dateLastChanged = Date.now();

    // Clear temp buffer so it doesn't leak into the next target
    currentNewTargetPhotos = [];

    saveSurveysToLocalStorage();
    closeNewTargetModal();

    // Make sure we land back on the Targets screen
    currentPage = 'Targets';
    showMessage(`New Target (${newDescription}) logged successfully!`, 'success');
    render();
}

        
// Now async, so it can talk to IndexedDB
async function openTargetPhotoGallery(targetId, surveyId) {
    const survey = surveys.find(s => s.id === surveyId);
    if (!survey) {
        showMessage('Survey not found for this target.', 'error');
        return;
    }

    const target = survey.targets.find(t => t.id === targetId);
    if (!target) {
        showMessage('Target not found.', 'error');
        return;
    }

    let photos = [];

    if (Array.isArray(target.photos) && target.photos.length) {
        const first = target.photos[0];

        // NEW: if these are IndexedDB refs ("idb:..."), load blobs and make real URLs
        if (isIndexedDbPhotoRef(first)) {
            try {
                photos = await loadPhotoUrlsFromRefs(target.photos);
            } catch (e) {
                console.error('Error loading target photos from IndexedDB:', e);
                photos = [];
            }
        } else {
            // Old style: already data URLs, just copy them
            photos = target.photos.slice();
        }
    } else if (target.targetPhotoData || target.photoDataUrl) {
        const basePhoto = target.targetPhotoData || target.photoDataUrl;
        if (basePhoto) {
            photos = [basePhoto];
        }
    }

    if (!photos.length) {
        showMessage('This target has no photos yet.', 'info');
        return;
    }

    openPhotoGallery(photos, 0);
}
// Also async, to be ready for IndexedDB-backed find photos
async function openFindPhotoGallery(findId) {
    const find = finds.find(f => f.id === findId);
    if (!find) {
        showMessage('Find not found.', 'error');
        return;
    }

    let photos = [];

    if (Array.isArray(find.photos) && find.photos.length) {
        const first = find.photos[0];

        if (isIndexedDbPhotoRef(first)) {
            try {
                photos = await loadPhotoUrlsFromRefs(find.photos);
            } catch (e) {
                console.error('Error loading find photos from IndexedDB:', e);
                photos = [];
            }
        } else {
            // Old style: direct data URLs
            photos = find.photos.slice();
        }
    } else if (find.targetPhotoData || find.photoData) {
        const basePhoto = find.targetPhotoData || find.photoData;
        if (basePhoto) {
            photos = [basePhoto];
        }
    }

    if (!photos.length) {
        showMessage('This find has no photos yet.', 'info');
        return;
    }

    openPhotoGallery(photos, 0);
}
function openPhotoGallery(photos, startIndex) {
    if (!Array.isArray(photos) || !photos.length) return;

    currentGalleryPhotos = photos.slice();
    currentGalleryIndex = Math.max(0, Math.min(startIndex || 0, currentGalleryPhotos.length - 1));

    const modal   = document.getElementById('photo-gallery-modal');
    const img     = document.getElementById('photo-gallery-image');
    const caption = document.getElementById('photo-gallery-caption');

    if (!modal || !img || !caption) return;

    // Ensure swipe handlers are attached
    ensureGallerySwipeHandlers();

    // Update the displayed image
    img.src = currentGalleryPhotos[currentGalleryIndex];
    caption.textContent = `${currentGalleryIndex + 1} of ${currentGalleryPhotos.length}`;

    openModal('photo-gallery-modal');
}

function showGalleryPhoto(delta) {
    if (!currentGalleryPhotos.length) return;
    if (typeof delta !== 'number' || delta === 0) return;

    const nextIndex = (currentGalleryIndex + delta + currentGalleryPhotos.length) % currentGalleryPhotos.length;
    currentGalleryIndex = nextIndex;

    const img     = document.getElementById('photo-gallery-image');
    const caption = document.getElementById('photo-gallery-caption');
    if (!img || !caption) return;

    img.src = currentGalleryPhotos[currentGalleryIndex];
    caption.textContent = `${currentGalleryIndex + 1} of ${currentGalleryPhotos.length}`;
}

function closePhotoGallery() {
    closeModal('photo-gallery-modal');
}

function ensureGallerySwipeHandlers() {
    if (gallerySwipeInitialized) return;

    const wrapper = document.getElementById('photo-gallery-image-wrapper');
    if (!wrapper) return;

    wrapper.addEventListener('touchstart', (e) => {
        if (!e.touches || !e.touches.length) return;
        galleryTouchStartX = e.touches[0].clientX;
    });

    wrapper.addEventListener('touchend', (e) => {
        if (galleryTouchStartX === null || !e.changedTouches || !e.changedTouches.length) return;
        const dx = e.changedTouches[0].clientX - galleryTouchStartX;
        galleryTouchStartX = null;

        if (Math.abs(dx) > 40) {
            // Swipe left => next, swipe right => previous
            showGalleryPhoto(dx < 0 ? 1 : -1);
        }
    });

    gallerySwipeInitialized = true;
}

// --- SHARED PHOTO HELPERS ---
// ======================================
// SHARED PHOTO-UI INITIALISER
// ======================================
function initPhotoUI(photoData, {
    statusId,
    wrapperId,
    imgId,
    hiddenId
}, messages = {}) {
    const statusSpan     = statusId   ? document.getElementById(statusId)   : null;
    const previewWrapper = wrapperId  ? document.getElementById(wrapperId)  : null;
    const previewImg     = imgId      ? document.getElementById(imgId)      : null;
    const hiddenField    = hiddenId   ? document.getElementById(hiddenId)   : null;

    const existingMessage = messages.existing || 'Existing photo loaded. Tap "Take / Choose Photo" to replace.';
    const emptyMessage    = messages.empty    || 'No photo captured yet.';

    // Valid Base64 data URLs are usually fairly long strings
    const hasValidPhoto = photoData && typeof photoData === 'string' && photoData.length > 50;

    if (hasValidPhoto) {
        if (hiddenField)    hiddenField.value = photoData;
        if (previewImg)     previewImg.src = photoData;
        if (previewWrapper) previewWrapper.classList.remove('hidden');
        if (statusSpan)     statusSpan.textContent = existingMessage;
    } else {
        if (hiddenField)    hiddenField.value = '';
        if (previewImg)     previewImg.src = '';
        if (previewWrapper) previewWrapper.classList.add('hidden');
        if (statusSpan)     statusSpan.textContent = emptyMessage;
    }
}

    // ======================================
// CARD THUMBNAIL INITIALISER (Targets & Finds)
// ======================================
async function initialiseCardThumbnails() {
    const thumbImgs = document.querySelectorAll('img[data-photo-ref]');
    if (!thumbImgs.length) return;

    thumbImgs.forEach(async (img) => {
        const ref = img.getAttribute('data-photo-ref');
        if (!ref) return;

        try {
            let url = '';

            // New style: an IndexedDB reference like "idb:123"
            if (typeof isIndexedDbPhotoRef === 'function' && isIndexedDbPhotoRef(ref)) {
                if (typeof getPhotoUrlFromRef === 'function') {
                    url = await getPhotoUrlFromRef(ref);
                }
            } else {
                // Legacy: direct data URL or normal URL
                url = ref;
            }

            if (url) {
                img.src = url;
            } else {
                // If we couldn't resolve anything, hide the broken image
                const container = img.closest('.mt-3');
                if (container) {
                    container.classList.add('hidden');
                }
            }
        } catch (e) {
            console.error('Error resolving thumbnail for ref', ref, e);
        }
    });
}

/**
 * Generic helper to trigger a hidden file input by ID.
 * Clears any previous selection before opening.
 */
function triggerPhotoInput(inputId) {
    const fileInput = document.getElementById(inputId);
    if (!fileInput) return;

    fileInput.value = '';   // clear previous selection
    fileInput.click();      // open camera / gallery
}

/**
 * Generic helper to handle a selected photo and update:
 * - status text
 * - preview wrapper + image
 * - hidden data field
 */
function handlePhotoSelected(event, {
    statusId,
    wrapperId,
    imgId,
    hiddenId
}) {
    const fileInput = event.target;
    const file = fileInput.files && fileInput.files[0];

    const statusSpan     = statusId   ? document.getElementById(statusId)   : null;
    const previewWrapper = wrapperId  ? document.getElementById(wrapperId)  : null;
    const previewImg     = imgId      ? document.getElementById(imgId)      : null;
    const hiddenField    = hiddenId   ? document.getElementById(hiddenId)   : null;

    if (!file) {
        if (statusSpan)     statusSpan.textContent = 'No photo captured yet.';
        if (previewWrapper) previewWrapper.classList.add('hidden');
        if (hiddenField)    hiddenField.value = '';
        return;
    }

    const reader = new FileReader();
    reader.onload = (e) => {
        const dataUrl = e.target.result;
        if (hiddenField)    hiddenField.value = dataUrl;
        if (statusSpan)     statusSpan.textContent = 'Photo captured.';
        if (previewImg)     previewImg.src = dataUrl;
        if (previewWrapper) previewWrapper.classList.remove('hidden');
    };
    reader.onerror = () => {
        console.error('Error reading photo file:', reader.error);
        showMessage('Could not read the photo file.', 'error');
        if (statusSpan)     statusSpan.textContent = 'Error capturing photo.';
        if (previewWrapper) previewWrapper.classList.add('hidden');
        if (hiddenField)    hiddenField.value = '';
    };
    reader.readAsDataURL(file);
}

// --- TARGET PHOTO HELPERS (new target form) ---
// --- EDIT SURVEY PHOTO HELPERS ---

function triggerEditSurveyPhotoInput() {
    triggerPhotoInput('edit-survey-photo-input');
}

function handleEditSurveyPhotoSelected(event) {
    handlePhotoSelected(event, {
        statusId:  'edit-survey-photo-status',
        wrapperId: 'edit-survey-photo-preview-wrapper',
        imgId:     'edit-survey-photo-preview',
        hiddenId:  'edit-survey-photo-data'
    });
}

// --- NEW: MULTI-PHOTO SUPPORT FOR NEW TARGET MODAL ---

function updateNewTargetPhotoPreview() {
    const statusSpan  = document.getElementById('new-target-photo-status');
    const wrapper     = document.getElementById('new-target-photo-preview-wrapper');
    const hiddenField = document.getElementById('target-photo-data');

    if (!statusSpan || !wrapper || !hiddenField) return;

    const photos = currentNewTargetPhotos || [];

    // Store as JSON in the hidden field
    hiddenField.value = JSON.stringify(photos);

    if (!photos.length) {
        statusSpan.textContent = 'No photo captured yet.';
        wrapper.classList.add('hidden');
        wrapper.innerHTML = '';
        return;
    }

    statusSpan.textContent = photos.length === 1
        ? '1 photo selected.'
        : `${photos.length} photos selected.`;

    const thumbsHtml = photos.map((src, index) => `
        <div class="relative mb-2 flex justify-center">
            <img
                src="${src}"
                alt="Target photo ${index + 1}"
                class="w-11/12 max-h-64 object-cover rounded-lg border border-gray-300 cursor-pointer"
                onclick="openNewTargetPhotoGallery(${index})"
            />
            <button
                type="button"
                class="absolute top-2 right-6 bg-black bg-opacity-60 text-white rounded-full w-7 h-7 flex items-center justify-center text-xs"
                onclick="event.stopPropagation(); removeNewTargetPhoto(${index});"
            >
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
    `).join('');

    wrapper.innerHTML = `
        <div class="flex flex-col items-center w-full">
            ${thumbsHtml}
        </div>
    `;
    wrapper.classList.remove('hidden');
}

function handleNewTargetPhotoSelected(event) {
    const files = Array.from(event.target.files || []);
    if (!files.length) return;

    // Allow selecting the same file again later
    event.target.value = '';

    let remaining = files.length;

    files.forEach(file => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const dataUrl = e.target.result;
            if (typeof dataUrl === 'string') {
                currentNewTargetPhotos.push(dataUrl);
            }
            remaining -= 1;
            if (remaining === 0) {
                updateNewTargetPhotoPreview();
            }
        };
        reader.onerror = () => {
            console.error('Error reading target photo file:', reader.error);
            remaining -= 1;
            if (remaining === 0) {
                updateNewTargetPhotoPreview();
            }
        };
        reader.readAsDataURL(file);
    });
}

function removeNewTargetPhoto(index) {
    if (!Array.isArray(currentNewTargetPhotos)) return;
    currentNewTargetPhotos.splice(index, 1);
    updateNewTargetPhotoPreview();
}

// Called from button in the New Target form
function triggerNewTargetPhotoInput() {
    // This matches the actual <input id="new-target-photo-input">
    triggerPhotoInput('new-target-photo-input');
}

function openNewTargetPhotoGallery(startIndex) {
    if (!currentNewTargetPhotos.length) return;
    openPhotoGallery(currentNewTargetPhotos, startIndex || 0);
}

// --- NEW: MULTI-PHOTO SUPPORT FOR EDIT TARGET MODAL ---

function updateEditTargetPhotoPreview() {
    const statusSpan  = document.getElementById('edit-target-photo-status');
    const wrapper     = document.getElementById('edit-target-photo-preview-wrapper');
    const hiddenField = document.getElementById('edit-target-photo-data');

    if (!statusSpan || !wrapper || !hiddenField) return;

    const photos = currentEditTargetPhotos || [];
    hiddenField.value = JSON.stringify(photos);

    if (!photos.length) {
        statusSpan.textContent = 'No photo captured yet.';
        wrapper.classList.add('hidden');
        wrapper.innerHTML = '';
        return;
    }

    statusSpan.textContent = photos.length === 1
        ? '1 photo selected.'
        : `${photos.length} photos selected.`;

    const thumbsHtml = photos.map((src, index) => `
        <div class="relative mb-2 flex justify-center">
            <img
                src="${src}"
                alt="Target photo ${index + 1}"
                class="w-11/12 max-h-64 object-cover rounded-lg border border-gray-300 cursor-pointer"
                onclick="openEditTargetPhotoGallery(${index})"
            />
            <button
                type="button"
                class="absolute top-2 right-6 bg-black bg-opacity-60 text-white rounded-full w-7 h-7 flex items-center justify-center text-xs"
                onclick="event.stopPropagation(); removeEditTargetPhoto(${index});"
            >
                <i class="fas fa-trash-alt"></i>
            </button>
        </div>
    `).join('');

    wrapper.innerHTML = `
        <div class="flex flex-col items-center w-full">
            ${thumbsHtml}
        </div>
    `;
    wrapper.classList.remove('hidden');
}

function handleEditTargetPhotoSelected(event) {
    const files = Array.from(event.target.files || []);
    if (!files.length) return;

    // Allow selecting the same file again later
    event.target.value = '';

    let remaining = files.length;

    files.forEach(file => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const dataUrl = e.target.result;
            if (typeof dataUrl === 'string') {
                currentEditTargetPhotos.push(dataUrl);
            }
            remaining -= 1;
            if (remaining === 0) {
                updateEditTargetPhotoPreview();
            }
        };
        reader.onerror = () => {
            console.error('Error reading edit target photo file:', reader.error);
            remaining -= 1;
            if (remaining === 0) {
                updateEditTargetPhotoPreview();
            }
        };
        reader.readAsDataURL(file);
    });
}

function removeEditTargetPhoto(index) {
    if (!Array.isArray(currentEditTargetPhotos)) return;
    currentEditTargetPhotos.splice(index, 1);
    updateEditTargetPhotoPreview();
}

// Called from button in the Edit Target form
function triggerEditTargetPhotoInput() {
    triggerPhotoInput('edit-target-photo-input');
}

function openEditTargetPhotoGallery(startIndex) {
    if (!currentEditTargetPhotos.length) return;
    openPhotoGallery(currentEditTargetPhotos, startIndex || 0);
}

// --- EDIT FIND PHOTO HELPERS ---

function triggerEditFindPhotoInput() {
    triggerPhotoInput('edit-find-photo-input');
}

// === MULTI-PHOTO SUPPORT FOR EDIT FIND MODAL ===

/**
 * Re-renders the thumbnails + status text for the Edit Find modal,
 * based on currentEditFindPhotos.
 */
function updateEditFindPhotoPreview() {
    const statusSpan  = document.getElementById('edit-find-photo-status');
    const wrapper     = document.getElementById('edit-find-photo-preview-wrapper');
    const hiddenField = document.getElementById('edit-find-photo-data');

    if (!statusSpan || !wrapper || !hiddenField) return;

    const photos = currentEditFindPhotos || [];

    // Store the array as JSON in the hidden field
    hiddenField.value = JSON.stringify(photos);

    if (!photos.length) {
        statusSpan.textContent = 'No photo captured yet.';
        wrapper.classList.add('hidden');
        wrapper.innerHTML = '';
        return;
    }

    statusSpan.textContent = photos.length === 1
        ? '1 photo selected.'
        : `${photos.length} photos selected.`;

    const thumbsHtml = photos.map((src, index) => `
        <div class="relative">
            <img
                src="${src}"
                alt="Find photo ${index + 1}"
                class="w-24 h-24 object-cover rounded-md border border-gray-300"
            />
        </div>
    `).join('');

    wrapper.innerHTML = `
        <div class="flex flex-wrap gap-2 justify-center w-full">
            ${thumbsHtml}
        </div>
    `;
    wrapper.classList.remove('hidden');
}

/**
 * Called when the user picks one or more photos in the Edit Find modal.
 * Appends them to currentEditFindPhotos and refreshes the preview.
 */
function handleEditFindPhotoSelected(event) {
    const files = Array.from(event.target.files || []);
    if (!files.length) {
        return;
    }

    // Allow picking again later (including the same file)
    event.target.value = '';

    let remaining = files.length;

    files.forEach(file => {
        const reader = new FileReader();
        reader.onload = (e) => {
            const dataUrl = e.target.result;
            if (typeof dataUrl === 'string') {
                currentEditFindPhotos.push(dataUrl);
            }
            remaining -= 1;
            if (remaining === 0) {
                updateEditFindPhotoPreview();
            }
        };
        reader.onerror = () => {
            console.error('Error reading find photo file:', reader.error);
            remaining -= 1;
            if (remaining === 0) {
                updateEditFindPhotoPreview();
            }
        };
        reader.readAsDataURL(file);
    });
}

        // --- NEW SURVEY PHOTO HELPERS ---

function triggerNewSurveyPhotoInput() {
    triggerPhotoInput('new-survey-photo-input');
}

function handleNewSurveyPhotoSelected(event) {
    handlePhotoSelected(event, {
        statusId:  'new-survey-photo-status',
        wrapperId: 'new-survey-photo-preview-wrapper',
        imgId:     'new-survey-photo-preview',
        hiddenId:  'new-survey-photo-data'
    });
}

        
async function showEditTargetModal(targetId, surveyId) {
    const survey = surveys.find(s => s.id === surveyId);
    if (!survey) {
        showMessage('Error: Survey not found.', 'error');
        return;
    }

    const target = survey.targets.find(t => t.id === targetId);
    if (!target) {
        showMessage('Error: Target not found.', 'error');
        return;
    }

    // 1. Populate the form fields
    document.getElementById('edit-target-id').value = target.id;
    document.getElementById('edit-survey-id').value = survey.id;
    document.getElementById('current-edit-survey-name').textContent = survey.name;

    document.getElementById('edit-target-description').value =
        typeof target.description === 'string' ? target.description : '';

    document.getElementById('edit-target-vdi').value =
        target.vdi === 'N/A' || target.vdi == null ? '' : String(target.vdi);

    document.getElementById('edit-target-depth').value =
        target.depth === 'Unknown' || target.depth == null ? '' : String(target.depth);

    document.getElementById('edit-target-type').value = target.type || 'Coin';

    document.getElementById('edit-target-coords').value =
        target.coordinates === 'No GPS logged' || !target.coordinates
            ? ''
            : String(target.coordinates);

    // Accuracy
    document.getElementById('edit-target-accuracy').value =
        target.accuracy === 'N/A' || target.accuracy == null ? '' : String(target.accuracy);

    // Centre on map radios
    const shouldCenterOnMap = target.centerOnMap === true;
    const yesRadio = document.getElementById('edit-target-center-yes');
    const noRadio  = document.getElementById('edit-target-center-no');

    if (yesRadio && noRadio) {
        yesRadio.checked = shouldCenterOnMap;
        noRadio.checked  = !shouldCenterOnMap;
    }

    // 2. Photos: convert stored data into displayable thumbnails
    try {
        if (Array.isArray(target.photos) && target.photos.length > 0) {
            const first = target.photos[0];

            if (isIndexedDbPhotoRef(first)) {
                // NEW: load from IndexedDB, get object URLs
                currentEditTargetPhotos = await loadPhotoUrlsFromRefs(target.photos);
            } else {
                // Old style: already data URLs
                currentEditTargetPhotos = target.photos.slice();
            }
        } else if (target.targetPhotoData) {
            currentEditTargetPhotos = [target.targetPhotoData];
        } else if (target.photoDataUrl) {
            currentEditTargetPhotos = [target.photoDataUrl];
        } else {
            currentEditTargetPhotos = [];
        }
    } catch (e) {
        console.error('Error preparing edit target photos:', e);
        currentEditTargetPhotos = [];
    }

    updateEditTargetPhotoPreview();

    // 3. Attach the submit listener (via your shared helper)
    attachFormSubmitHandler('edit-target-form', handleEditTargetSubmit);

    // 4. Show the modal
    openModal('edit-target-modal');
}
        
function closeEditTargetModal() {
    closeModal('edit-target-modal');
}
        /** Handles the submission of the Edit Target form. */
/** Handles the submission of the Edit Target form. */
/** Handles the submission of the Edit Target form. */
async function handleEditTargetSubmit(event) {
    event.preventDefault();

    // Always grab the real form element by ID (more robust on mobile)
    const form = document.getElementById('edit-target-form');
    if (!form) {
        showMessage('Error: Edit Target form not found.', 'error');
        console.error('Edit Target form not found in DOM.');
        return;
    }

    // Read IDs directly from the hidden inputs
    const targetIdInput = document.getElementById('edit-target-id');
    const surveyIdInput = document.getElementById('edit-survey-id');

    const targetId = targetIdInput?.value;
    const surveyId = surveyIdInput?.value;

    if (!targetId || !surveyId) {
        console.error('Missing targetId or surveyId in edit form.', {
            targetId,
            surveyId,
            targetIdInput,
            surveyIdInput
        });
        showMessage('Error: Target or Survey not found (missing IDs in form).', 'error');
        return;
    }

    const newDescription = form['targetDescription'].value.trim();
    if (!newDescription) {
        showMessage('Description / Find Name is required.', 'error');
        return;
    }

    const newVDI      = form['targetVDI'].value.trim() || 'N/A';
    const newDepth    = form['targetDepth'].value.trim() || 'Unknown';
    const newType     = form['targetType'].value;
    const newCoords   = form['targetCoords'].value.trim() || 'No GPS logged';
    const newAccuracy = form['targetAccuracy'].value.trim() || 'N/A';

    // --- Photos: parse JSON array (or single string) from hidden field ---
    let photosDataUrls = [];
    const rawPhotoField = form['targetPhotoData']?.value;

    if (rawPhotoField) {
        try {
            const parsed = JSON.parse(rawPhotoField);
            if (Array.isArray(parsed)) {
                photosDataUrls = parsed.filter(p => typeof p === 'string' && p.length > 0);
            } else if (typeof parsed === 'string' && parsed.length > 0) {
                photosDataUrls = [parsed];
            }
        } catch (e) {
            // Not valid JSON? Treat it as a single URL (data: or blob:)
            if (typeof rawPhotoField === 'string' && rawPhotoField.length > 0) {
                photosDataUrls = [rawPhotoField];
            }
        }
    }

    // Save these URLs into IndexedDB and get back lightweight references
    let photoRefs = [];
    try {
        photoRefs = await saveDataUrlsAsPhotoRefs(photosDataUrls);
    } catch (e) {
        console.error('Error saving edited target photos to IndexedDB:', e);
        // We can still proceed, but with no IDB refs
        photoRefs = [];
    }

    const primaryDataUrl = photosDataUrls[0] || '';
    const primaryRef     = photoRefs[0] || '';

    // Look up survey + target
    const survey = surveys.find(s => s.id === surveyId);
    if (!survey) {
        showMessage('Error: Survey not found.', 'error');
        return;
    }

    const target = survey.targets.find(t => t.id === targetId);
    if (!target) {
        showMessage('Error: Target not found.', 'error');
        return;
    }

    // Update core fields
    target.description = newDescription;
    target.vdi         = newVDI;
    target.depth       = newDepth;
    target.type        = newType;
    target.coordinates = newCoords;
    target.accuracy    = newAccuracy;

    // Update photos (new IndexedDB-backed structure)
    target.photos          = photoRefs;
    target.targetPhotoRef  = primaryRef;
    target.targetPhotoData = photoRefs.length > 0 ? '' : primaryDataUrl;

    // Centre-on-map handling (only one per survey)
    const yesRadio = document.getElementById('edit-target-center-yes');
    const noRadio  = document.getElementById('edit-target-center-no');

    if (yesRadio && noRadio) {
        const centerOnMap = !!yesRadio.checked;

        if (centerOnMap) {
            // Ensure only this target is centred in this survey
            survey.targets.forEach(t => {
                if (t.id !== targetId) {
                    t.centerOnMap = false;
                }
            });
        }

        target.centerOnMap = centerOnMap;
    }
    // If radios are missing, we leave target.centerOnMap unchanged

    survey.dateLastChanged = Date.now();
    saveSurveysToLocalStorage();
    closeEditTargetModal();
    showMessage(`Target ${target.description} updated successfully.`, 'success');
    render();
}

        /** Shows the Edit Profile Modal and loads current data. */
        function showEditProfileModal() {
            const modal = document.getElementById('edit-profile-modal');
            // Pre-fill the form with current profile data
            document.getElementById('profile-name').value = userProfile.name;
            document.getElementById('profile-detector').value = userProfile.detector;
            modal.style.display = 'block';

            // Attach the submit listener
            const form = document.getElementById('edit-profile-form');
            form.removeEventListener('submit', handleEditProfileSubmit); 
            form.addEventListener('submit', handleEditProfileSubmit); 
            showMessage("Edit Profile modal opened. Please enter your name and detector and click 'Save Changes'.", 'info');
        }

        /** Closes the Edit Profile Modal. */
        function closeEditProfileModal() {
            document.getElementById('edit-profile-modal').style.display = 'none';
        }

        /** Handles the submission of the Edit Profile form. */
        function handleEditProfileSubmit(event) {
            event.preventDefault();

            const form = event.target;
            const newName = form['profileName'].value.trim();
            const newDetector = form['profileDetector'].value.trim();

            if (!newName || !newDetector) {
                showMessage('Both Name and Detector are required.', 'error');
                return;
            }

            // Update global state
            userProfile.name = newName;
            userProfile.detector = newDetector;

            // Update user/detector in existing targets 
            surveys.forEach(survey => {
                survey.targets.forEach(target => {
                    if (target.user === userProfile.name) {
                        target.user = newName;
                    }
                    if (target.detector === userProfile.detector) {
                        target.detector = newDetector;
                    }
                });
            });


            // Save and re-render
            saveSurveysToLocalStorage();
            closeEditProfileModal();
            showMessage(`Profile updated to "${newName}" using "${newDetector}" successfully!`, 'success');
            // Re-render the current page (Settings) to reflect the new profile data
            render();
        }

        // --- SURVEY & TARGET LOGIC (Action Handlers) ---

        /** Handles actions like 'open', 'close', 'archive', 'restore', 'delete'. */
 async function handleSurveyAction(button) {
    const id = button.dataset.id;
    const action = button.dataset.action;
    const name = button.dataset.name;
    const survey = surveys.find(s => s.id === id);
    if (!survey) return;

    const executeAction = async () => {
        const now = Date.now();
        switch (action) {
            case 'open':
                // Close any currently open survey first
                surveys.forEach(s => {
                    if (s.status === 'Open') {
                        s.status = 'Active';
                        s.dateLastChanged = now;
                    }
                });
                survey.status = 'Open';
                showMessage(`Survey '${name}' is now OPEN.`, 'success');
                break;
            case 'close':
                survey.status = 'Active';
                showMessage(`Survey '${name}' is now CLOSED (Active).`, 'info');
                break;
            case 'archive':
                survey.status = 'Archived';
                showMessage(`Survey '${name}' has been Archived.`, 'info');
                break;
            case 'restore':
                survey.status = 'Active';
                showMessage(`Survey '${name}' Restored to Active.`, 'success');
                break;
            case 'delete':
                surveys = surveys.filter(s => s.id !== id);
                showMessage(`Survey '${name}' permanently deleted.`, 'error');
                break;
        }
        survey.dateLastChanged = now;
        saveSurveysToLocalStorage();
        render();
    };

    // Use confirmation modal for irreversible or significant actions
    if (action === 'delete') {
        showConfirmationModal(
            `Confirm Delete: ${name}`,
            `Are you sure you want to permanently delete the survey **${name}** and all its targets? This action cannot be undone.`,
            executeAction
        );
    } else if (action === 'archive') {
        showConfirmationModal(
            `Confirm Archive: ${name}`,
            `Are you sure you want to Archive the survey **${name}**? You can restore it later.`,
            executeAction
        );
    } else {
        await executeAction();
    }
}       /** Handles actions on individual targets. */
function handleMapTargetClick(event, targetId) {
    // Don’t let this click bubble up to the map container,
    // so it does NOT trigger toggleMapFullscreen().
    event.stopPropagation();

    if (!targetId) {
        console.warn('Map target click without a valid targetId');
        return;
    }

    // Save the selected target ID for navigation
    navigationTargetId = targetId;
    console.log('Navigation target selected from map:', navigationTargetId);

    // Give the user some feedback
    showMessage('Navigation target selected on map.', 'info');

    // If we're on the Compass page, re-render it so the panel updates
    if (currentPage === 'Compass') {
        const appContent = document.getElementById('app-content');
        appContent.innerHTML = renderCompassPage(true);
        attachPageEventListeners();

    }
}

            function clearNavigationTarget() {
    navigationTargetId = null;
    showMessage('Navigation target cleared.', 'info');

    // If we are on the Compass page, re-render so the panel updates
    if (currentPage === 'Compass') {
        const appContent = document.getElementById('app-content');
        appContent.innerHTML = renderCompassPage(true);
        attachPageEventListeners();
    }
}
// ------------------------------------------------------
// Target QR helpers
// ------------------------------------------------------

/**
 * Build a compact JSON string representing a single target
 * plus minimal survey + profile info.
 */
function buildTargetQrPayload(target, survey) {
    const payload = {
        kind: 'geoFind-target',
        version: 1,

        surveyId: survey.id,
        surveyName: survey.name || '',
        surveyDescription: survey.description || '',

        targetId: target.id,
        description: target.description || '',
        type: target.type || '',
        vdi: target.vdi || '',
        depth: target.depth || '',
        coordinates: target.coordinates || '',
        accuracy: target.accuracy || '',
        status: target.status || '',
        createdAt: target.createdAt || target.timestamp || null,

        user: (userProfile && userProfile.name) ? userProfile.name : '',
        detector: (userProfile && userProfile.detector) ? userProfile.detector : ''
    };

    // Keep it compact for QR efficiency
    return JSON.stringify(payload);
}

/**
 * Given a target + survey, populate and show the QR modal.
 */
function showTargetQrModalFor(target, survey) {
    const modal        = document.getElementById('target-qr-modal');
    const titleEl      = document.getElementById('target-qr-title');
    const codeContainer = document.getElementById('target-qr-code-container');
    const textArea     = document.getElementById('target-qr-raw-text');

    if (!modal || !titleEl || !codeContainer) {
        console.error('Target QR modal elements not found.');
        showMessage('QR modal not found in page.', 'error');
        return;
    }

    const qrText = buildTargetQrPayload(target, survey);

    // Title
    titleEl.textContent = `Target QR: ${target.description || 'Unnamed target'}`;

    // Raw JSON text (for debugging / copy-paste)
    if (textArea) {
        textArea.value = qrText;
    }

    // Clear any previous QR code
    codeContainer.innerHTML = '';

    // Use the QRCode library if available
    if (typeof QRCode === 'function') {
        try {
            new QRCode(codeContainer, {
                text: qrText,
                width: 256,
                height: 256,
                correctLevel: QRCode.CorrectLevel.M
            });
        } catch (e) {
            console.error('Error creating QR code:', e);
            codeContainer.innerHTML =
                '<p class="text-xs text-red-600">Could not generate QR code.</p>';
        }
    } else {
        // Fallback if library not loaded
        codeContainer.innerHTML =
            '<p class="text-xs text-red-600">QR library not loaded. The raw text below can be copied manually.</p>';
    }

    openModal('target-qr-modal');
}

function closeTargetQrModal() {
    closeModal('target-qr-modal');
}
// ------------------------------------------------------
// Target QR SCAN helpers (import into OPEN survey)
// ------------------------------------------------------

let qrScanStream = null;
let qrScanAnimationFrameId = null;
let qrScanActive = false;

/**
 * Open the scan modal and start the camera.
 * Imports into the currently OPEN survey only.
 */
function openTargetQrScanModal() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('Please open a survey first before importing a target via QR.', 'warning');
        return;
    }

    const statusEl = document.getElementById('target-qr-scan-status');
    if (statusEl) {
        statusEl.textContent = 'Initialising camera…';
    }

    openModal('target-qr-scan-modal');
    startTargetQrScan();
}

/** Close the scan modal and stop the camera. */
function closeTargetQrScanModal() {
    stopTargetQrScan();
    closeModal('target-qr-scan-modal');
}

/** Start camera and begin scanning frames for a QR code. */
async function startTargetQrScan() {
    const video   = document.getElementById('target-qr-scan-video');
    const canvas  = document.getElementById('target-qr-scan-canvas');
    const statusEl = document.getElementById('target-qr-scan-status');

    if (!video || !canvas) {
        console.error('QR scan elements not found.');
        if (statusEl) statusEl.textContent = 'QR scan not available on this page.';
        return;
    }

    // Stop any previous scan, just in case
    stopTargetQrScan();

    if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
        if (statusEl) {
            statusEl.textContent = 'Camera is not available in this browser.';
        }
        return;
    }

    try {
        const constraints = {
            video: {
                facingMode: 'environment'   // Prefer rear camera on phones
            }
        };

        qrScanActive = true;
        const stream = await navigator.mediaDevices.getUserMedia(constraints);
        qrScanStream = stream;

        video.srcObject = stream;

        if (statusEl) {
            statusEl.textContent = 'Point your camera at a GeoFind Target QR code…';
        }

        const ctx = canvas.getContext('2d');

        const tick = () => {
            if (!qrScanActive) return;

            if (video.readyState === video.HAVE_ENOUGH_DATA) {
                const width  = video.videoWidth;
                const height = video.videoHeight;

                if (width && height) {
                    canvas.width  = width;
                    canvas.height = height;
                    ctx.drawImage(video, 0, 0, width, height);
                    const imageData = ctx.getImageData(0, 0, width, height);

                    if (typeof jsQR === 'function') {
                        const qrResult = jsQR(
                            imageData.data,
                            width,
                            height,
                            { inversionAttempts: 'dontInvert' }
                        );

                        if (qrResult && qrResult.data) {
                            // We found a QR code – handle it
                            handleTargetQrScanned(qrResult.data);
                            return; // Stop scanning
                        }
                    }
                }
            }

            // Keep scanning
            qrScanAnimationFrameId = requestAnimationFrame(tick);
        };

        qrScanAnimationFrameId = requestAnimationFrame(tick);
    } catch (err) {
        console.error('Error starting QR scan:', err);
        if (statusEl) {
            statusEl.textContent = 'Could not access camera: ' + (err.message || 'unknown error');
        }
    }
}

/** Stop any active QR scan and release the camera. */
function stopTargetQrScan() {
    qrScanActive = false;

    if (qrScanAnimationFrameId != null) {
        cancelAnimationFrame(qrScanAnimationFrameId);
        qrScanAnimationFrameId = null;
    }

    if (qrScanStream) {
        qrScanStream.getTracks().forEach(track => track.stop());
        qrScanStream = null;
    }
}

/**
 * Called when a QR code has been successfully decoded.
 * Parses payload and imports as a NEW target into the OPEN survey.
 */
function handleTargetQrScanned(text) {
    qrScanActive = false;
    stopTargetQrScan();
    closeTargetQrScanModal();

    let payload;
    try {
        payload = JSON.parse(text);
    } catch (e) {
        console.error('Scanned QR is not valid JSON:', e);
        showMessage('Scanned QR is not a valid GeoFind target.', 'error');
        return;
    }

    if (!payload || payload.kind !== 'geoFind-target') {
        showMessage('The QR code is not a GeoFind Target QR.', 'error');
        return;
    }

    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('No open survey found to import into.', 'error');
        return;
    }

    const description = payload.description || 'Imported target';

    const confirmTitle = 'Import Target from QR';
    const confirmMessage = `
        Import this target into the currently open survey?<br><br>
        <strong>${description}</strong><br>
        <span class="text-sm text-gray-600">
            Survey: ${openSurvey.name || 'Untitled survey'}
        </span>
    `;

    const doImport = () => {
        const now = Date.now();

        const newTarget = {
            id: generateId(),

            description: payload.description || 'Imported target',
            vdi: payload.vdi || 'N/A',
            depth: payload.depth || 'Unknown',
            type: payload.type || 'Unidentified',

            status: payload.status || 'Hole Dug',
            time: now,

            coordinates: payload.coordinates || 'No GPS logged',
            accuracy: payload.accuracy || 'N/A',

            user: payload.user || userProfile.name || '',
            detector: payload.detector || userProfile.detector || '',

            centerOnMap: false,

            // No photos via QR – you can add them later
            photos: [],
            targetPhotoRef: '',
            targetPhotoData: ''
        };

        if (!Array.isArray(openSurvey.targets)) {
            openSurvey.targets = [];
        }
        openSurvey.targets.unshift(newTarget);
        openSurvey.dateLastChanged = now;

        saveSurveysToLocalStorage();

        showMessage(`Imported target "${newTarget.description}" into open survey.`, 'success');
        render();   // Re-render current page (likely Settings)
    };

    // Use your existing generic confirmation modal
    showConfirmationModal(confirmTitle, confirmMessage, doImport);
}


function handleTargetAction(element) {
    const action   = element.dataset.action;
    const targetId = element.dataset.id;
    const surveyId = element.dataset.surveyId;

    const survey = surveys.find(s => s.id === surveyId);
    if (!survey) return;

    const target = survey.targets.find(t => t.id === targetId);
    if (!target) return;

    // Special case: open the edit modal
    if (action === 'edit') {
        showEditTargetModal(targetId, surveyId);
        return;
    }

    const executeAction = () => {
          switch (action) {
            case 'setStatus': {
                const newStatus = element.dataset.status;
                target.status = newStatus;
                showMessage(`Target status updated to: ${newStatus}`, 'success');
                break;
            }

            case 'saveFind': {
                target.isFind = true;
                createFindFromTarget(target, survey);
                break;
            }

            case 'navigate': {
                navigationTargetId = targetId;
                showMessage(`Navigation target set: "${target.description}".`, 'success');
                currentPage = 'Compass';
                break;
            }

            case 'centerOnMap': {
                survey.targets.forEach(t => {
                    t.centerOnMap = (t.id === targetId);
                });
                showMessage('Centre on map updated for this target.', 'success');
                break;
            }

            case 'showQr': {
                // No state change — just show the QR modal
                showTargetQrModalFor(target, survey);
                break;
            }

            case 'delete': {
                target.deleted = true;
                if (navigationTargetId === targetId) {
                    navigationTargetId = null;
                }
                showMessage('Target deleted.', 'error');
                break;
            }
        }

        survey.dateLastChanged = Date.now();
        saveSurveysToLocalStorage();
        render();
    };

    // Use confirmation modal for significant actions
    if (action === 'delete') {
        showConfirmationModal(
            `Confirm Delete Target: ${target.description}`,
            `Are you sure you want to permanently delete this target?`,
            executeAction
        );
    } else if (action === 'saveFind') {
        showConfirmationModal(
            'Promote to Find',
            `Save <strong>${target.description}</strong> to your Finds library?<br>
             <span class="text-sm text-gray-600">
                 You can review and edit it later on the <strong>Finds</strong> tab.
             </span>`,
            executeAction
        );
    } else {
        executeAction();
    }
}
        // --- PAGE RENDER FUNCTIONS ---

function renderHomePage() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    const activeSurveys = surveys.filter(s => s.status === 'Active');
    const archivedSurveys = surveys.filter(s => s.status === 'Archived');

    const renderSurveyList = (list) => {
        if (list.length === 0) {
            return `<p class="text-gray-500 italic p-4">No surveys in this section.</p>`;
        }
        // Pass the openSurvey ID to highlight the currently open survey card in the list
        return list.map(s => renderSurveyCard(s, s.id === (openSurvey ? openSurvey.id : null))).join('');
    };

    // CRITICAL FIX: The template literal must start on the same line as 'return'
    return `<div class="p-4">
        <h2 class="text-3xl font-bold text-primary mb-6">Survey Dashboard</h2>

        <div class="bg-white p-4 rounded-xl shadow-lg mb-6 border-l-4 border-yellow-500">
            <h3 class="text-xl font-bold text-yellow-700 mb-2">
                ${openSurvey ? openSurvey.name : 'No Open Survey'}
            </h3>
            ${openSurvey ? 
                `<p class="text-gray-700">Open since: ${formatDate(openSurvey.creationDate)} (${getActiveTargets(openSurvey).length} targets logged)</p>

                 ${renderSurveyCard(openSurvey, true)}` 
                : 
                '<p class="text-gray-600">You must open or create a survey to log new targets.</p>'
            }
        </div>

        <button id="new-survey-btn" class="w-full text-center text-white font-bold py-3 px-4 rounded-lg shadow-md hover:opacity-90 transition duration-150 mb-6" style="background-color: rgb(var(--color-secondary));">
            <i class="fas fa-plus-circle mr-2"></i> Create New Survey
        </button>

        <h3 class="text-2xl font-bold text-gray-700 mb-3">Active/Closed Surveys (${activeSurveys.length})</h3>
        <div id="active-surveys-list" class="space-y-4 mb-8">
            ${renderSurveyList(activeSurveys)}
        </div>

        <h3 class="text-2xl font-bold text-gray-700 mb-3">Archived Surveys (${archivedSurveys.length})</h3>
        <div id="archived-surveys-list" class="space-y-4">
            ${renderSurveyList(archivedSurveys)}
        </div>
    </div>`; // Note the closing backtick here
}        
        /** Renders a single survey card with action buttons based on status. */
function renderSurveyCard(survey, isOpen = false) {
    let actions = '';
    let statusBadge = '';
    const secondaryColor = 'rgb(var(--color-secondary))';

    switch (survey.status) {
        case 'Open':
            statusBadge = `<span class="bg-green-100 text-green-800 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full">OPEN</span>`;
            // Only the OPEN survey can be edited
            actions = `
                <button
                    class="survey-action-btn bg-indigo-500 hover:bg-indigo-600 p-2 text-white text-sm font-semibold rounded-md shadow-sm"
                    onclick="showEditSurveyModal('${survey.id}')">
                    Edit
                </button>
                <button
                    class="survey-action-btn bg-yellow-500 hover:bg-yellow-600 p-2 text-black text-sm font-semibold rounded-md shadow-sm"
                    onclick="handleSurveyAction(this)"
                    data-id="${survey.id}"
                    data-action="close"
                    data-name="${survey.name}">
                    Close
                </button>
                <button
                    class="survey-action-btn bg-red-500 hover:bg-red-600 p-2 text-white text-sm font-semibold rounded-md shadow-sm"
                    onclick="handleSurveyAction(this)"
                    data-id="${survey.id}"
                    data-action="archive"
                    data-name="${survey.name}">
                    Archive
                </button>
            `;
            break;

        case 'Active': // Active but Closed
            statusBadge = `<span class="bg-blue-100 text-blue-800 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full">ACTIVE</span>`;
            actions = `
                <button
                    class="survey-action-btn bg-green-500 hover:bg-green-600 p-2 text-white text-sm font-semibold rounded-md shadow-sm"
                    onclick="handleSurveyAction(this)"
                    data-id="${survey.id}"
                    data-action="open"
                    data-name="${survey.name}">
                    Open
                </button>
                <button
                    class="survey-action-btn bg-gray-500 hover:bg-gray-600 p-2 text-white text-sm font-semibold rounded-md shadow-sm"
                    onclick="handleSurveyAction(this)"
                    data-id="${survey.id}"
                    data-action="archive"
                    data-name="${survey.name}">
                    Archive
                </button>
                <button
                    class="survey-action-btn bg-red-500 hover:bg-red-600 p-2 text-white text-sm font-semibold rounded-md shadow-sm"
                    onclick="handleSurveyAction(this)"
                    data-id="${survey.id}"
                    data-action="delete"
                    data-name="${survey.name}">
                    Delete
                </button>
            `;
            break;

        case 'Archived':
            statusBadge = `<span class="bg-gray-100 text-gray-800 text-xs font-medium mr-2 px-2.5 py-0.5 rounded-full">ARCHIVED</span>`;
            actions = `
                <button
                    class="survey-action-btn bg-blue-500 hover:bg-blue-600 p-2 text-white text-sm font-semibold rounded-md shadow-sm"
                    onclick="handleSurveyAction(this)"
                    data-id="${survey.id}"
                    data-action="restore"
                    data-name="${survey.name}">
                    Restore
                </button>
                <button
                    class="survey-action-btn bg-red-500 hover:bg-red-600 p-2 text-white text-sm font-semibold rounded-md shadow-sm"
                    onclick="handleSurveyAction(this)"
                    data-id="${survey.id}"
                    data-action="delete"
                    data-name="${survey.name}">
                    Delete
                </button>
            `;
            break;
    }

    // Photo display logic - load from IndexedDB if available
    let photoHtml = '';
    
    // Check if we have an IndexedDB reference first
    if (survey.surveyPhotoRef && isIndexedDbPhotoRef(survey.surveyPhotoRef)) {
        // Load from IndexedDB asynchronously
        photoHtml = `
            <div class="mt-3" id="survey-photo-${survey.id}">
                <div class="w-full h-40 bg-gray-100 rounded-lg border border-gray-200 flex items-center justify-center">
                    <span class="text-xs text-gray-500">Loading photo...</span>
                </div>
            </div>
        `;
        
        // Load the photo asynchronously
        (async () => {
            try {
                const photoUrl = await getPhotoUrlFromRef(survey.surveyPhotoRef);
                const photoContainer = document.getElementById(`survey-photo-${survey.id}`);
                if (photoContainer && photoUrl) {
                    photoContainer.innerHTML = `
                        <img
                            src="${photoUrl}"
                            alt="Survey photo"
                            class="w-full max-h-40 object-cover rounded-lg border border-gray-200"
                        />
                    `;
                }
            } catch (e) {
                console.error('Error loading survey photo:', e);
            }
        })();
    } else if (survey.surveyPhotoData) {
        // Fallback to data URL (for old surveys or immediate display)
        photoHtml = `
            <div class="mt-3">
                <img
                    src="${survey.surveyPhotoData}"
                    alt="Survey photo"
                    class="w-full max-h-40 object-cover rounded-lg border border-gray-200"
                />
            </div>
        `;
    }

    // For the Open survey card on the dashboard, we don't repeat the name
    const titleName = isOpen ? '' : survey.name;

    return `
        <div class="bg-white p-4 rounded-xl shadow-lg border-l-4 ${isOpen ? 'border-yellow-500' : 'border-primary'}">
            <div class="flex justify-between items-start mb-2">
                <h4 class="text-lg font-bold text-gray-800">
                    ${statusBadge}${titleName}
                </h4>
                <div class="flex space-x-2">
                    ${actions}
                </div>
            </div>
            <p class="text-sm text-gray-600 mb-2">${survey.description}</p>
            ${photoHtml}
            <div class="flex justify-between text-xs text-gray-400 border-t border-gray-100 pt-2 mt-2">
                <span>Created: ${formatDate(survey.creationDate)}</span>
                <span>Targets: ${getActiveTargets(survey).length}</span>
                <span>Last Change: ${formatDate(survey.dateLastChanged)}</span>
            </div>
        </div>
    `;
}    
        /** Renders the content for the Targets page. */
        function renderTargetsPage() {
            const openSurvey = surveys.find(s => s.status === 'Open');

            if (!openSurvey) {
                return `
                    <div class="p-4">
                        <h2 class="text-3xl font-bold text-primary mb-6">Survey Targets</h2>
                        <div class="bg-white p-6 rounded-xl shadow-lg border-l-4 border-red-500">
                            <h3 class="text-xl font-bold text-red-600 mb-3">No Open Survey</h3>
                            <p class="text-gray-700">Please open a survey on the **Home** page to view or log targets.</p>
                        </div>
                    </div>
                `;
            }

            const targets = getActiveTargets(openSurvey);


            return `
                <div class="p-4">
                    <h2 class="text-3xl font-bold text-primary mb-6">Targets: ${openSurvey.name}</h2>
                    
                    <button id="add-target-btn" class="w-full text-center text-white font-bold py-3 px-4 rounded-lg shadow-md hover:opacity-90 transition duration-150 mb-6" style="background-color: rgb(var(--color-secondary));">
                        <i class="fas fa-crosshairs mr-2"></i> Log New Target
                    </button>

                    <h3 class="text-2xl font-bold text-gray-700 mb-3">Target Log (${targets.length})</h3>
                    <div id="targets-list" class="space-y-4">
                        ${targets.length === 0 ? 
                            '<p class="text-gray-500 italic p-4 bg-white rounded-xl shadow-lg">No targets logged in this survey yet.</p>' : 
                            targets.map(t => renderTargetCard(t, openSurvey.id)).join('')}
                    </div>
                </div>
            `;
        }

function renderFindsPage() {
    const hasFinds = Array.isArray(finds) && finds.length > 0;

    // Build distinct Type options
    const typeSet = new Set();
    finds.forEach(f => {
        if (f.type) typeSet.add(f.type);
    });
    const typeOptions = Array.from(typeSet).sort();

    // Build distinct Survey options (by ID)
    const surveyMap = new Map();
    finds.forEach(f => {
        const id   = f.surveyId   || 'unknown';
        const name = f.surveyName || 'Unknown survey';
        if (!surveyMap.has(id)) {
            surveyMap.set(id, name);
        }
    });
    const surveyOptions = Array.from(surveyMap.entries())
        .map(([id, name]) => ({ id, name }))
        .sort((a, b) => a.name.localeCompare(b.name));

    // Apply filters
    const filteredFinds = finds.filter(f => {
        // Text search (in several fields)
        if (findsFilter.query) {
            const q = findsFilter.query.toLowerCase();
            const haystack = [
                f.description,
                f.vdi,
                f.depth,
                f.type,
                f.surveyName,
                f.surveyDescription
            ]
                .filter(Boolean)
                .join(' ')
                .toLowerCase();

            if (!haystack.includes(q)) return false;
        }

        // Type filter
        if (findsFilter.type !== 'All') {
            const t = f.type || 'Unknown';
            if (t !== findsFilter.type) return false;
        }

        // Survey filter
        if (findsFilter.surveyId !== 'All') {
            const id = f.surveyId || 'unknown';
            if (id !== findsFilter.surveyId) return false;
        }

        return true;
    });

    const totalCount    = finds.length;
    const filteredCount = filteredFinds.length;

    const cardsHtml = filteredFinds.map(find => {
        const dateText  = find.createdAt ? formatDate(find.createdAt) : '';
        const typeLabel = find.type || 'Unknown';

        // --- Thumbnail + photo count (IndexedDB-aware, like Targets) ---
        let thumbRef    = '';
        let photosCount = 0;

        if (Array.isArray(find.photos) && find.photos.length) {
            // New style: array of refs or data URLs
            thumbRef    = find.photos[0];
            photosCount = find.photos.length;
        } else if (find.targetPhotoData || find.photoData) {
            // Legacy / fallback
            thumbRef    = find.targetPhotoData || find.photoData;
            photosCount = thumbRef ? 1 : 0;
        }

        const photoHtml = thumbRef
            ? `
                <div class="mt-3">
                    <div class="flex justify-center">
                        <img
                            src=""
                            data-photo-ref="${thumbRef}"
                            data-photo-kind="find"
                            data-find-id="${find.id}"
                            alt="Find photo"
                            class="w-11/12 max-h-48 object-cover rounded-lg border border-gray-200 cursor-pointer"
                            onclick="openFindPhotoGallery('${find.id}')"
                        />
                    </div>
                    ${
                        photosCount > 1
                            ? `<p class="mt-1 text-xs text-gray-600 text-center">
                                   ${photosCount} photos — tap to view gallery.
                               </p>`
                            : ''
                    }
                </div>
              `
            : '';

        const coordsText = find.coordinates || 'No GPS logged';
        const accText    = find.accuracy   || 'N/A';

        return `
            <div class="bg-white rounded-xl shadow-md p-4 mb-4 border border-gray-100">
                <div class="flex items-start justify-between">
                    <div>
                        <h3 class="text-lg font-bold text-primary">
                            ${find.description || 'Unnamed Find'}
                        </h3>
                        <p class="text-xs text-gray-500 mt-1">
                            ${find.surveyName || 'Unknown survey'}
                        </p>
                        ${
                            dateText
                                ? `<p class="text-xs text-gray-400 mt-1">Saved: ${dateText}</p>`
                                : ''
                        }
                    </div>
                    <span class="inline-flex items-center px-2 py-1 text-xs font-semibold rounded-full bg-gray-100 text-gray-800">
                        ${typeLabel}
                    </span>
                </div>

                ${photoHtml}

                <div class="mt-3 grid grid-cols-2 gap-2 text-xs text-gray-700">
                    <div>
                        <span class="font-semibold">VDI:</span> ${find.vdi || '—'}
                    </div>
                    <div>
                        <span class="font-semibold">Depth:</span> ${find.depth || '—'}
                    </div>
                    <div>
                        <span class="font-semibold">Coords:</span>
                        <span class="break-all">${coordsText}</span>
                    </div>
                    <div>
                        <span class="font-semibold">Accuracy:</span> ${accText}
                    </div>
                </div>

                <!-- Actions row: Edit / Delete (same style language as Targets) -->
                <div class="mt-4 grid grid-cols-2 gap-2">
                    <button
                        type="button"
                        class="find-card-edit-btn w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-purple-100 text-purple-800 hover:bg-purple-200
                               border border-purple-300
                               text-xs sm:text-sm font-semibold"
                        data-find-id="${find.id}">
                        Edit details
                    </button>

                    <button
                        type="button"
                        class="find-card-delete-btn w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-red-600 text-white hover:bg-red-700
                               text-xs sm:text-sm font-semibold"
                        data-find-id="${find.id}">
                        Delete Find
                    </button>
                </div>
            </div>
        `;
    }).join('');

    const typesOptionsHtml = [
        '<option value="All">All Types</option>',
        ...typeOptions.map(t =>
            `<option value="${t}" ${findsFilter.type === t ? 'selected' : ''}>${t}</option>`
        )
    ].join('');

    const surveyOptionsHtml = [
        '<option value="All">All Surveys</option>',
        ...surveyOptions.map(({ id, name }) =>
            `<option value="${id}" ${findsFilter.surveyId === id ? 'selected' : ''}>${name}</option>`
        )
    ].join('');

    return `
        <div class="p-4">
            <h2 class="text-3xl font-bold text-primary mb-2">Finds Library</h2>
            <p class="text-sm text-gray-600 mb-4">
             ${
                 hasFinds
                ? `Showing ${filteredCount} of ${totalCount} finds.`
                : 'No finds have been saved yet.'
                }

            </p>

            <div class="mb-4 bg-white rounded-xl shadow-sm border border-gray-100 p-3">
                <div class="flex flex-col gap-2 sm:flex-row sm:items-center">
                    <div class="flex-1">
                        <label class="block text-xs font-semibold text-gray-600 mb-1" for="finds-search-input">
                            Search description / notes
                        </label>
                        <input
                            id="finds-search-input"
                            type="text"
                            class="w-full px-3 py-2 rounded-lg border border-gray-300 text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary"
                            placeholder="Search finds..."
                            value="${findsFilter.query || ''}"
                        />
                    </div>
                    <div class="flex-1">
                        <label class="block text-xs font-semibold text-gray-600 mb-1" for="finds-type-select">
                            Filter by type
                        </label>
                        <select
                            id="finds-type-select"
                            class="w-full px-3 py-2 rounded-lg border border-gray-300 text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary"
                        >
                            ${typesOptionsHtml}
                        </select>
                    </div>
                    <div class="flex-1">
                        <label class="block text-xs font-semibold text-gray-600 mb-1" for="finds-survey-select">
                            Filter by survey
                        </label>
                        <select
                            id="finds-survey-select"
                            class="w-full px-3 py-2 rounded-lg border border-gray-300 text-sm focus:outline-none focus:ring-2 focus:ring-primary focus:border-primary"
                        >
                            ${surveyOptionsHtml}
                        </select>
                    </div>
                </div>
                <div class="mt-3 flex justify-end">
                    <button
                        id="clear-finds-filters-btn"
                        type="button"
                        class="px-3 py-1 rounded-lg text-xs font-semibold border border-gray-300 text-gray-700 hover:bg-gray-100"
                    >
                        Clear filters
                    </button>
                </div>
            </div>

            <div id="finds-list">
                ${
                    cardsHtml
                        || (hasFinds
                            ? '<p class="text-sm text-gray-600">No finds match your filters.</p>'
                            : ''
                           )
                }
            </div>
        </div>
    `;
}
        
/** Renders a single target card. */
function renderTargetCard(target, surveyId) {
    // --- Type icon & colour chip ---
    let typeColor = 'bg-primary';
    let typeIcon  = 'fas fa-gem';

    switch (target.type) {
        case 'Coin':
            typeColor = 'bg-yellow-500';
            typeIcon  = 'fas fa-coins';
            break;
        case 'Relic':
            typeColor = 'bg-red-500';
            typeIcon  = 'fas fa-shield-alt';
            break;
        case 'Jewelry':
            typeColor = 'bg-pink-500';
            typeIcon  = 'fas fa-ring';
            break;
        case 'Modern Junk':
            typeColor = 'bg-gray-500';
            typeIcon  = 'fas fa-trash';
            break;
        case 'Iron Junk':
            typeColor = 'bg-gray-700';
            typeIcon  = 'fas fa-magnet';
            break;
        case 'Unidentified':
            typeColor = 'bg-purple-500';
            typeIcon  = 'fas fa-question';
            break;
    }

    // --- Status badge styling ---
    let statusClass = 'bg-green-100 text-green-800';
    let statusIcon  = `
        <svg class="w-4 h-4 mr-1 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24"
             xmlns="http://www.w3.org/2000/svg">
            <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                  d="M9 12l2 2 4-4m6 2a9 9 0 11-18 0 9 9 0 0118 0z"></path>
        </svg>`;

    switch (target.status) {
        case 'Signal Detected':
            statusClass = 'bg-green-100 text-green-800';
            break;
        case 'Hole Dug':
            statusClass = 'bg-amber-100 text-amber-800';
            statusIcon  = `
                <svg class="w-4 h-4 mr-1 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                     xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                          d="M4 6h16M4 10h16M4 14h10"></path>
                </svg>`;
            break;
        case 'Hole Refilled':
            statusClass = 'bg-blue-100 text-blue-800';
            statusIcon  = `
                <svg class="w-4 h-4 mr-1 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                     xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                          d="M5 13l4 4L19 7"></path>
                </svg>`;
            break;
        case 'Signal Ignored':
            statusClass = 'bg-gray-100 text-gray-800';
            statusIcon  = `
                <svg class="w-4 h-4 mr-1 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24"
                     xmlns="http://www.w3.org/2000/svg">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2"
                          d="M6 18L18 6M6 6l12 12"></path>
                </svg>`;
            break;
    }

    // --- Photo thumbnail block (IndexedDB-aware) ---
    let thumbRef    = '';
    let photosCount = 0;

    // Prefer the new structure: an array of refs or data URLs
    if (Array.isArray(target.photos) && target.photos.length) {
        thumbRef    = target.photos[0];
        photosCount = target.photos.length;
    } else if (target.targetPhotoRef) {
        // Single ref field
        thumbRef    = target.targetPhotoRef;
        photosCount = 1;
    } else if (target.targetPhotoData || target.photoDataUrl) {
        // Legacy base64 / URL fallback
        thumbRef    = target.targetPhotoData || target.photoDataUrl;
        photosCount = thumbRef ? 1 : 0;
    }

    let photoHtml = '';
    if (thumbRef) {
        const captionHtml = photosCount > 1
            ? `<p class="mt-1 text-xs text-gray-600 text-center">
                    ${photosCount} photos — tap to view gallery.
               </p>`
            : '';

        photoHtml = `
            <div class="mt-3">
                <div class="flex justify-center">
                    <img
                        src=""
                        data-photo-ref="${thumbRef}"
                        data-photo-kind="target"
                        data-target-id="${target.id}"
                        data-survey-id="${surveyId}"
                        alt="Target photo"
                        class="w-11/12 max-h-48 object-cover rounded-lg border border-gray-200 cursor-pointer"
                        onclick="openTargetPhotoGallery('${target.id}', '${surveyId}')"
                    />
                </div>
                ${captionHtml}
            </div>
        `;
    }

    const vdiText   = target.vdi ?? 'N/A';
    const depthText = target.depth ?? 'Unknown';

    const coordsText = target.coordinates && target.coordinates !== 'No GPS logged'
        ? target.coordinates
        : 'No GPS logged';

    const accuracyText = target.accuracy && target.accuracy !== 'N/A'
        ? `${target.accuracy} m`
        : 'N/A';

    return `
        <div class="bg-white rounded-xl shadow-md p-4 border border-gray-100">
            <div class="flex items-start justify-between mb-2">
                <div class="flex items-center space-x-2">
                    <span class="inline-flex items-center justify-center w-9 h-9 rounded-full ${typeColor} text-white">
                        <i class="${typeIcon} text-lg"></i>
                    </span>
                    <div>
                        <h3 class="text-lg font-bold text-gray-800">
                            ${target.description || 'Unnamed Target'}
                        </h3>
                        <p class="text-xs text-gray-500">
                            VDI: <span class="font-semibold">${vdiText}</span> ·
                            Depth: <span class="font-semibold">${depthText}</span>
                        </p>
                    </div>
                </div>

                <span class="inline-flex items-center px-2 py-1 text-xs font-semibold rounded-full ${statusClass}">
                    ${statusIcon}
                    <span>${target.status || 'Signal Detected'}</span>
                </span>
            </div>

            ${photoHtml}

            <div class="mt-3 grid grid-cols-2 gap-2 text-xs text-gray-600">
                <div>
                    <p class="font-semibold">Coordinates</p>
                    <p class="break-words">${coordsText}</p>
                </div>
                <div>
                    <p class="font-semibold">Accuracy</p>
                    <p>${accuracyText}</p>
                </div>
            </div>

            <div class="mt-3 text-xs text-gray-500 flex justify-between">
                <span>Logged: ${formatDate(target.time)}</span>
                <span>${target.user || userProfile.name} · ${target.detector || userProfile.detector}</span>
            </div>

            <!-- Actions -->
            <div class="mt-4 space-y-2">
                <!-- Row 1: Hole status buttons -->
                <div class="grid grid-cols-3 gap-2">
                    <button
                        type="button"
                        class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-amber-100 text-amber-800 hover:bg-amber-200
                               text-xs sm:text-sm font-semibold"
                        data-action="setStatus"
                        data-status="Hole Dug"
                        data-id="${target.id}"
                        data-survey-id="${surveyId}"
                        onclick="handleTargetAction(this)">
                        Hole Dug
                    </button>
                    <button
                        type="button"
                        class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-blue-100 text-blue-800 hover:bg-blue-200
                               text-xs sm:text-sm font-semibold"
                        data-action="setStatus"
                        data-status="Hole Refilled"
                        data-id="${target.id}"
                        data-survey-id="${surveyId}"
                        onclick="handleTargetAction(this)">
                        Hole Refilled
                    </button>
                    <button
                        type="button"
                        class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-gray-100 text-gray-800 hover:bg-gray-200
                               text-xs sm:text-sm font-semibold"
                        data-action="setStatus"
                        data-status="Signal Ignored"
                        data-id="${target.id}"
                        data-survey-id="${surveyId}"
                        onclick="handleTargetAction(this)">
                        Ignore Signal
                    </button>
                </div>

                <!-- Row 2: Navigation -->
                     <!-- Row 2: QR + Navigation -->
                <div class="grid grid-cols-3 gap-2">
                    <button
                        type="button"
                        class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-gray-800 text-white hover:bg-gray-900
                               text-xs sm:text-sm font-semibold"
                        data-action="showQr"
                        data-id="${target.id}"
                        data-survey-id="${surveyId}"
                        onclick="handleTargetAction(this)">
                        Show QR
                    </button>

                    <button
                        type="button"
                        class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-emerald-600 text-white hover:bg-emerald-700
                               text-xs sm:text-sm font-semibold"
                        data-action="navigate"
                        data-id="${target.id}"
                        data-survey-id="${surveyId}"
                        onclick="handleTargetAction(this)">
                        Navigate to Target
                    </button>

                    <button
                        type="button"
                        class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-sky-600 text-white hover:bg-sky-700
                               text-xs sm:text-sm font-semibold"
                        data-action="centerOnMap"
                        data-id="${target.id}"
                        data-survey-id="${surveyId}"
                        onclick="handleTargetAction(this)">
                        Centre on Map
                    </button>
                </div>

                <!-- Row 3: Edit / Copy / Delete -->
                <div class="grid grid-cols-3 gap-2">
                    <button
                        type="button"
                        class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-purple-100 text-purple-800 hover:bg-purple-200
                               border border-purple-300
                               text-xs sm:text-sm font-semibold"
                        data-action="edit"
                        data-id="${target.id}"
                        data-survey-id="${surveyId}"
                        onclick="handleTargetAction(this)">
                        Edit details
                    </button>

                    <button
                        type="button"
                        class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-indigo-600 text-white hover:bg-indigo-700
                               text-xs sm:text-sm font-semibold"
                        data-action="saveFind"
                        data-id="${target.id}"
                        data-survey-id="${surveyId}"
                        onclick="handleTargetAction(this)">
                        Copy to finds
                    </button>

                    <button
                        type="button"
                        class="w-full inline-flex items-center justify-center px-3 py-2 rounded-md
                               bg-red-600 text-white hover:bg-red-700
                               text-xs sm:text-sm font-semibold"
                        data-action="delete"
                        data-id="${target.id}"
                        data-survey-id="${surveyId}"
                        onclick="handleTargetAction(this)">
                        Delete Target
                    </button>
                </div>
            </div>
        </div>
    `;
}

        
            // --- MAP ZOOM & PAN STATE ---

let mapZoom = 1;
let mapOffsetX = 0; // in %
let mapOffsetY = 0; // in %

const MAP_ZOOM_MIN = 0.5;
const MAP_ZOOM_MAX = 3;
const MAP_ZOOM_STEP = 0.25;

let isMapDragging = false;
let mapDragStartX = 0;
let mapDragStartY = 0;
let mapDragStartOffsetX = 0;
let mapDragStartOffsetY = 0;

/** Re-render the Compass page if it is the active page. */
function rerenderCompassIfActive() {
    if (typeof currentPage !== 'undefined' && currentPage === 'Compass') {
        const appContent = document.getElementById('app-content');
        if (appContent && typeof renderCompassPage === 'function') {
            appContent.innerHTML = renderCompassPage(true);
            if (typeof attachPageEventListeners === 'function') {
                attachPageEventListeners();
            }
        }
    }
}

function zoomMapIn(event) {
    if (event) event.stopPropagation();
    mapZoom = Math.min(MAP_ZOOM_MAX, mapZoom + MAP_ZOOM_STEP);
    rerenderCompassIfActive();
}

function zoomMapOut(event) {
    if (event) event.stopPropagation();
    mapZoom = Math.max(MAP_ZOOM_MIN, mapZoom - MAP_ZOOM_STEP);
    rerenderCompassIfActive();
}

function resetMapView(event) {
    if (event) event.stopPropagation();
    mapZoom = 1;
    mapOffsetX = 0;
    mapOffsetY = 0;
    rerenderCompassIfActive();
}

/** Start dragging the map to pan it. */
function startMapDrag(event) {
    // Don't start a drag when clicking on zoom controls or a pin
    if (
        event.target.closest &&
        (event.target.closest('.map-zoom-controls') ||
         event.target.closest('.map-pin'))
    ) {
        return;
    }

    const e = event.touches ? event.touches[0] : event;
    event.preventDefault();

    isMapDragging = true;
    mapDragStartX = e.clientX;
    mapDragStartY = e.clientY;
    mapDragStartOffsetX = mapOffsetX;
    mapDragStartOffsetY = mapOffsetY;

    document.addEventListener('mousemove', onMapDrag, { passive: false });
    document.addEventListener('mouseup', endMapDrag);
    document.addEventListener('touchmove', onMapDrag, { passive: false });
    document.addEventListener('touchend', endMapDrag);
}

function onMapDrag(event) {
    if (!isMapDragging) return;

    const e = event.touches ? event.touches[0] : event;
    event.preventDefault();

    const container = document.getElementById('target-map-container');
    if (!container) return;

    const rect = container.getBoundingClientRect();
    if (!rect.width || !rect.height) return;

    const dx = e.clientX - mapDragStartX;
    const dy = e.clientY - mapDragStartY;

    const dxPercent = (dx / rect.width) * 100;
    const dyPercent = (dy / rect.height) * 100;

    mapOffsetX = mapDragStartOffsetX + dxPercent;
    mapOffsetY = mapDragStartOffsetY + dyPercent;

    // Update transform live without a full re-render
    const inner = container.querySelector('.map-inner-layer');
    if (inner) {
        inner.style.transform =
            `translate(${mapOffsetX}%, ${mapOffsetY}%) scale(${mapZoom})`;
    }
}

function endMapDrag() {
    if (!isMapDragging) return;
    isMapDragging = false;

    document.removeEventListener('mousemove', onMapDrag);
    document.removeEventListener('mouseup', endMapDrag);
    document.removeEventListener('touchmove', onMapDrag);
    document.removeEventListener('touchend', endMapDrag);
}
        
/** Renders a static plot of targets based on relative coordinates, with optional centre target, grid, and nav line. */
function renderTargetPlot(targets) {
    // Haversine approximation constants
    const M_PER_DEG_LAT = 110574; // meters per degree latitude (relatively constant)
    const M_PER_DEG_LON_AT_EQUATOR = 111320; // meters per degree longitude (at equator)
    
    // Prefer smoothed coords if available, fall back to raw
    const effectiveUserCoords = smoothedUserCoords || currentUserCoords;
    const hasUserGPS = !!effectiveUserCoords && typeof currentUserAccuracy === 'number';
    const userAccuracy = hasUserGPS ? (currentUserAccuracy || 0) : 0;
    const diameterInMeters = userAccuracy * 2;
    const bufferPercentage = 0.05; // 5% buffer around the entire calculated area

    // 1. Parse targets and prepare for Bounding Box calculation
    const parsedCoords = targets.map(t => {
        const parts = t.coordinates.split(',').map(c => parseFloat(c.trim()));
        return {
            id: t.id,
            lat: parts[0],
            lon: parts[1],
            description: t.description,
            type: t.type,
            vdi: t.vdi,
            status: t.status,
            accuracy: parseFloat(t.accuracy) || 0,
            centerOnMap: !!t.centerOnMap,
            isUser: false
        };
    }).filter(c => !isNaN(c.lat) && !isNaN(c.lon));

    let allCoords = [...parsedCoords];
    let userCoord = null;

    // NEW: include any visible track points from the open survey in the bounding box
    let visibleTracks = [];
    const openSurveyForMap = surveys.find(s => s.status === 'Open');
    if (openSurveyForMap && Array.isArray(openSurveyForMap.tracks)) {
        visibleTracks = openSurveyForMap.tracks.filter(t =>
            t && t.isVisible !== false && Array.isArray(t.points) && t.points.length > 1
        );

        visibleTracks.forEach(track => {
            track.points.forEach(p => {
                if (
                    p &&
                    typeof p.lat === 'number' &&
                    typeof p.lon === 'number' &&
                    !isNaN(p.lat) &&
                    !isNaN(p.lon)
                ) {
                    allCoords.push({
                        id: track.id,
                        lat: p.lat,
                        lon: p.lon,
                        description: track.name || 'Track',
                        type: 'Track',
                        vdi: '',
                        status: '',
                        accuracy: p.accuracy || 0,
                        centerOnMap: false,
                        isUser: false,
                        isTrackPoint: true
                    });
                }
            });
        });
    }

    // Add user's location if available (smoothed preferred)
    if (hasUserGPS && effectiveUserCoords) {
        userCoord = {
            lat: effectiveUserCoords.lat,
            lon: effectiveUserCoords.lon,
            description: 'Your Current Location',
            type: 'User',
            vdi: 'N/A',
            accuracy: userAccuracy,
            isUser: true
        };
        allCoords.push(userCoord);
    }

    if (allCoords.length === 0) {
        return `
            <div class="p-4 text-center bg-gray-100 rounded-lg">
                <p class="text-lg text-gray-500 italic">
                    No valid GPS coordinates found to plot (targets or user location).
                </p>
            </div>
        `;
    }

    // --- Find the target (if any) that should be centered on the map ---
    let centerTargetLat = null;
    let centerTargetLon = null;

    const centreTarget = targets.find(t => 
        t.centerOnMap === true &&
        t.coordinates &&
        t.coordinates.includes(',')
    );

    if (centreTarget) {
        const parts = centreTarget.coordinates.split(',').map(c => parseFloat(c.trim()));
        if (!isNaN(parts[0]) && !isNaN(parts[1])) {
            centerTargetLat = parts[0];
            centerTargetLon = parts[1];
        }
    }

    // --- Build bounding box ---
    let minLat, maxLat, minLon, maxLon;
    let latRange, lonRange;
    let mapHeightMeters, mapWidthMeters;

    const toRad = deg => (deg * Math.PI) / 180;

    if (centerTargetLat !== null && centerTargetLon !== null) {
        // ============================================================
        // CASE 1: Use centre target as map centre
        // ============================================================
        minLat = maxLat = centerTargetLat;
        minLon = maxLon = centerTargetLon;

        let maxLatDelta = 0;
        let maxLonDelta = 0;

        allCoords.forEach(c => {
            const dLat = Math.abs(c.lat - centerTargetLat);
            const dLon = Math.abs(c.lon - centerTargetLon);
            if (dLat > maxLatDelta) maxLatDelta = dLat;
            if (dLon > maxLonDelta) maxLonDelta = dLon;
        });

        if (maxLatDelta < 0.00001) maxLatDelta = 0.00001;
        if (maxLonDelta < 0.00001) maxLonDelta = 0.00001;

        let targetLatRange = maxLatDelta * 2;
        let targetLonRange = maxLonDelta * 2;

        let circleLatRange = 0;
        let circleLonRange = 0;

        if (hasUserGPS && userAccuracy > 0) {
            const requiredMeters = diameterInMeters * 1.1; // 10% padding
            const meanLatForConversion = toRad(centerTargetLat);
            const metersPerDegreeLonForConversion = M_PER_DEG_LON_AT_EQUATOR * Math.cos(meanLatForConversion);

            circleLatRange = requiredMeters / M_PER_DEG_LAT;
            circleLonRange = requiredMeters / metersPerDegreeLonForConversion;
        }

        const finalLatRange = Math.max(targetLatRange, circleLatRange);
        const finalLonRange = Math.max(targetLonRange, circleLonRange);

        const latBuffer = finalLatRange * bufferPercentage;
        const lonBuffer = finalLonRange * bufferPercentage;

        minLat = centerTargetLat - (finalLatRange / 2) - latBuffer;
        maxLat = centerTargetLat + (finalLatRange / 2) + latBuffer;
        minLon = centerTargetLon - (finalLonRange / 2) - lonBuffer;
        maxLon = centerTargetLon + (finalLonRange / 2) + lonBuffer;

        latRange = maxLat - minLat;
        lonRange = maxLon - minLon;

        const finalMeanLat = toRad((minLat + maxLat) / 2);
        const metersPerDegreeLon = M_PER_DEG_LON_AT_EQUATOR * Math.cos(finalMeanLat);

        mapHeightMeters = latRange * M_PER_DEG_LAT;
        mapWidthMeters = lonRange * metersPerDegreeLon;
    } else {
        // ============================================================
        // CASE 2: Auto-fit all points + user circle
        // ============================================================
        minLat = maxLat = allCoords[0].lat; 
        minLon = maxLon = allCoords[0].lon;

        allCoords.forEach(c => {
            minLat = Math.min(minLat, c.lat);
            maxLat = Math.max(maxLat, c.lat);
            minLon = Math.min(minLon, c.lon);
            maxLon = Math.max(maxLon, c.lon);
        });

        let targetLatRange = maxLat - minLat;
        let targetLonRange = maxLon - minLon;

        if (targetLatRange < 0.00001) targetLatRange = 0.00002;
        if (targetLonRange < 0.00001) targetLonRange = 0.00002;

        let userLatRange = 0;
        let userLonRange = 0;

        if (hasUserGPS && userAccuracy > 0) {
            const requiredMeters = diameterInMeters * 1.1;
            const meanLatForConversion = toRad(effectiveUserCoords.lat);
            const metersPerDegreeLonForConversion = M_PER_DEG_LON_AT_EQUATOR * Math.cos(meanLatForConversion);

            userLatRange = requiredMeters / M_PER_DEG_LAT;
            userLonRange = requiredMeters / metersPerDegreeLonForConversion;
        }

        const finalLatRange = Math.max(targetLatRange, userLatRange);
        const finalLonRange = Math.max(targetLonRange, userLonRange);

        const centerLat = (minLat + maxLat) / 2;
        const centerLon = (minLon + maxLon) / 2;

        const latBuffer = finalLatRange * bufferPercentage;
        const lonBuffer = finalLonRange * bufferPercentage;

        minLat = centerLat - (finalLatRange / 2) - latBuffer; 
        maxLat = centerLat + (finalLatRange / 2) + latBuffer;
        minLon = centerLon - (finalLonRange / 2) - lonBuffer;
        maxLon = centerLon + (finalLonRange / 2) + lonBuffer;

        latRange = maxLat - minLat;
        lonRange = maxLon - minLon;

        const finalMeanLat = toRad((minLat + maxLat) / 2);
        const metersPerDegreeLon = M_PER_DEG_LON_AT_EQUATOR * Math.cos(finalMeanLat);

        mapHeightMeters = latRange * M_PER_DEG_LAT;
        mapWidthMeters = lonRange * metersPerDegreeLon;
    }

    // ---------------------------------------------------------------------------------------
    // Normalise and draw
    const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

let userXPercent = 0;
let userYPercent = 0;
let userPinAndLabelHtml = '';
let userConfidenceCircleHtml = '';

let navTargetXPercent = null;
let navTargetYPercent = null;
let navTargetLat = null;
let navTargetLon = null;
let navTargetAccuracy = null;

// NEW: SVG overlay for any selected tracks
// NEW: SVG overlay for any selected tracks
let trackSvgHtml = '';

// Precompute SVG polylines for each visible track (if we have a valid map window)
if (visibleTracks && visibleTracks.length > 0 && latRange > 0 && lonRange > 0) {
    // Palette used to colour different tracks
    const trackColors = [
        'rgba(239, 68, 68, 0.9)',   // red
        'rgba(34, 197, 94, 0.9)',   // green
        'rgba(59, 130, 246, 0.9)',  // blue
        'rgba(234, 179, 8, 0.9)',   // amber
        'rgba(168, 85, 247, 0.9)',  // purple
        'rgba(16, 185, 129, 0.9)'   // teal
    ];

    const trackPolylines = visibleTracks.map((track, index) => {
        if (!Array.isArray(track.points) || track.points.length < 2) return '';

        // Use stored colour if ever added in future, otherwise pick from palette
        const strokeColor = track.color || trackColors[index % trackColors.length];

        const pointsAttr = track.points.map(p => {
            if (
                typeof p.lat !== 'number' ||
                typeof p.lon !== 'number' ||
                isNaN(p.lat) ||
                isNaN(p.lon)
            ) {
                return null;
            }

            const xRaw = ((p.lon - minLon) / lonRange) * 100;
            const yRaw = ((maxLat - p.lat) / latRange) * 100;

            const xPercent = clamp(xRaw, 0, 100);
            const yPercent = clamp(yRaw, 0, 100);

            return `${xPercent.toFixed(2)},${yPercent.toFixed(2)}`;
        }).filter(Boolean);

        if (pointsAttr.length < 2) return '';

        return `
            <polyline
                fill="none"
                stroke="${strokeColor}"
                stroke-width="0.8"
                stroke-linecap="round"
                stroke-linejoin="round"
                points="${pointsAttr.join(' ')}"
            ></polyline>
        `;
    }).filter(Boolean).join('');

    if (trackPolylines) {
        trackSvgHtml = `
            <svg
                class="absolute inset-0 w-full h-full pointer-events-none"
                viewBox="0 0 100 100"
                preserveAspectRatio="none"
            >
                ${trackPolylines}
            </svg>
        `;
    }
}

// 2. Normalize and generate pins HTML (targets + user)
const coordsForPins = [...parsedCoords];
if (userCoord) {
    coordsForPins.push(userCoord);
}

const pinsHtml = coordsForPins.map(t => {
    const xRaw = ((t.lon - minLon) / lonRange) * 100;
    const yRaw = ((maxLat - t.lat) / latRange) * 100;

    const xPercent = clamp(xRaw, 0, 100);
    const yPercent = clamp(yRaw, 0, 100);


        if (t.isUser) {
            // Store user position for circle and pin positioning
            userXPercent = xPercent;
            userYPercent = yPercent;

            const pinSize = 'w-3 h-3';

            // User pin
            userPinAndLabelHtml = `
                <div
                    class="absolute"
                    style="left: ${userXPercent.toFixed(2)}%; top: ${userYPercent.toFixed(2)}%; transform: translate(-50%, -50%); z-index: 20;"
                    title="Your Current Location (Acc: ${userAccuracy.toFixed(1)}m)"
                >
                    <div class="relative">
                    <div class="${pinSize} bg-blue-500 border-2 border-white shadow-lg rounded-full"></div>
                    </div>
                </div>
            `;
            return '';
        } else {
            // Target pin
            let pinColor = 'bg-primary';
            let pinSize = 'w-2 h-2';

            switch (t.status) {
                case 'Signal Detected':
                    pinColor = 'bg-green-600';
                    pinSize = 'w-3 h-3';
                    break;
                case 'Hole Dug':
                    pinColor = 'bg-yellow-500';
                    break;
                case 'Hole Refilled':
                    pinColor = 'bg-blue-600';
                    break;
                case 'Signal Ignored':
                    pinColor = 'bg-gray-500';
                    break;
                default:
                    pinColor = 'bg-primary';
            }

            // --- NEW: navigation-aware styling ---
const isCentre = t.centerOnMap === true;
const isNavTarget = navigationTargetId && t.id === navigationTargetId;

if (isNavTarget) {
    navTargetXPercent = xPercent;
    navTargetYPercent = yPercent;
    navTargetLat = t.lat;
    navTargetLon = t.lon;
    navTargetAccuracy = typeof t.accuracy === 'number' ? t.accuracy : null;
}

            const extraRing = isNavTarget
                ? '<div class="absolute -inset-1 rounded-full border-2 border-blue-500 animate-ping"></div>'
                : (isCentre
                    ? '<div class="absolute -inset-1 rounded-full border-2 border-red-500 animate-pulse"></div>'
                    : '');

            // Dim everything except the active nav target (if one is set)
            const dimClass = navigationTargetId && !isNavTarget ? 'opacity-40' : '';

            // --- OPTIONAL: confidence circle per target (using its accuracy) ---
            let targetCircleHtml = '';
            if (!isNaN(t.accuracy) && t.accuracy > 0 && mapWidthMeters && mapHeightMeters) {
                const scaleFactor = Math.max(mapWidthMeters, mapHeightMeters) / 100;
                const tDiameterPercent = (t.accuracy * 2) / (scaleFactor || 1);

                const circleBorder = isNavTarget ? 'border-blue-500' : 'border-gray-500';
                const circleBg = isNavTarget ? 'bg-blue-500/10' : 'bg-gray-500/5';

                targetCircleHtml = `
                    <div class="absolute rounded-full ${circleBorder} ${circleBg} pointer-events-none"
                        style="
                            width: ${tDiameterPercent.toFixed(2)}%; 
                            height: ${tDiameterPercent.toFixed(2)}%;
                            left: ${xPercent.toFixed(2)}%; top: ${yPercent.toFixed(2)}%;
                            transform: translate(-50%, -50%);
                            z-index: 2;
                        ">
                    </div>
                `;
            }

            return `
                ${targetCircleHtml}
                <div
                    class="absolute map-pin ${dimClass}"
                    style="left: ${xPercent.toFixed(2)}%; top: ${yPercent.toFixed(2)}%; transform: translate(-50%, -50%); z-index: 10;"
                    title="${t.description} (Target ID: ${t.vdi}) - ${t.lat.toFixed(6)}, ${t.lon.toFixed(6)} (Acc: ${t.accuracy.toFixed(1)}m)"
                    onclick="handleMapTargetClick(event, '${t.id || ''}')"
                >
                    <div class="relative">
                        ${extraRing}
                        <div class="${pinSize} rounded-full ${pinColor} border-2 border-primary shadow-lg cursor-pointer"></div>
                    </div>
                    <span class="absolute whitespace-nowrap text-xs font-semibold text-gray-800 bg-white p-1 rounded-sm shadow border border-gray-300" 
                        style="left: 100%; top: 50%; transform: translateY(-50%) translateX(5px);">
                        ${t.vdi || 'N/A'}
                    </span>
                </div>
            `;
        }
    }).join('');
    
    // --- Confidence circle for user accuracy ---
    if (userCoord && userAccuracy > 0 && mapWidthMeters && mapHeightMeters) {
        const scaleFactor = Math.max(mapWidthMeters, mapHeightMeters) / 100;
        const diameterPercent = diameterInMeters / (scaleFactor || 1);

        userConfidenceCircleHtml = `
            <div class="absolute rounded-full border-2 border-red-500 bg-red-500/10 pointer-events-none"
                style="
                    width: ${diameterPercent.toFixed(2)}%; 
                    height: ${diameterPercent.toFixed(2)}%;
                    left: ${userXPercent.toFixed(2)}%; top: ${userYPercent.toFixed(2)}%;
                    transform: translate(-50%, -50%);
                    z-index: 5; 
                "
                title="Confidence Radius: ${userAccuracy.toFixed(1)}m">
            </div>
        `;
    }

     // --- NEW: line from user to navigation target (map-space, not true bearing) ---
     // --- Line from user to current navigation target (with arrow, label, and proximity logic) ---
    let navLineHtml = '';

    if (
        navigationTargetId &&
        userCoord &&
        navTargetXPercent !== null &&
        navTargetYPercent !== null &&
        typeof navTargetLat === 'number' &&
        typeof navTargetLon === 'number'
    ) {
        // Use smoothed coords if available, else raw userCoord
        const userLat = effectiveUserCoords ? effectiveUserCoords.lat : userCoord.lat;
        const userLon = effectiveUserCoords ? effectiveUserCoords.lon : userCoord.lon;

        // Real-world distance in metres
        const distanceToNavMeters = distanceMeters(userLat, userLon, navTargetLat, navTargetLon);

        // How big is the "inside the circle" threshold?
        const navAcc = (typeof navTargetAccuracy === 'number' && navTargetAccuracy > 0)
            ? navTargetAccuracy
            : null;

        // If we know the nav target accuracy, use that. Otherwise fall back to user accuracy or a small default.
        const insideCircleThreshold =
            navAcc || (userAccuracy && userAccuracy > 0 ? userAccuracy : 0);

        const isInsideCircle =
            insideCircleThreshold && distanceToNavMeters <= insideCircleThreshold;

        // If we're inside the target's confidence circle, hide the line entirely
        if (!isInsideCircle) {
            // --- Scale-dependent arrow size based on mapZoom ---
            const arrowScale = 1 + (mapZoom - 1) * 0.5; // grows as you zoom in
            const clampedArrowScale = Math.max(0.75, Math.min(arrowScale, 2.0));

            const baseMarkerSize = 6;
            const markerWidth = baseMarkerSize * clampedArrowScale;
            const markerHeight = baseMarkerSize * clampedArrowScale;
            const refX = 4 * clampedArrowScale;
            const refY = 3 * clampedArrowScale;

            // --- Distance label position (midpoint) ---
            const midX = (userXPercent + navTargetXPercent) / 2;
            const midY = (userYPercent + navTargetYPercent) / 2;

            // Human-friendly distance string
            const distLabel =
                distanceToNavMeters >= 1000
                    ? (distanceToNavMeters / 1000).toFixed(2) + ' km'
                    : distanceToNavMeters.toFixed(1) + ' m';

            // --- Pulse effect when "near" the circle but not inside it ---
            const pulseThreshold = insideCircleThreshold ? insideCircleThreshold * 1.5 : 0;
            const shouldPulse = pulseThreshold && distanceToNavMeters <= pulseThreshold;
            const lineClass = shouldPulse ? 'animate-pulse' : '';

            navLineHtml = `
                <svg
                    class="absolute inset-0 pointer-events-none"
                    viewBox="0 0 100 100"
                    preserveAspectRatio="none"
                    style="z-index: 8;"
                >
                    <defs>
                        <marker 
                            id="navArrow"
                            markerWidth="${markerWidth}"
                            markerHeight="${markerHeight}"
                            refX="${refX}"
                            refY="${refY}"
                            orient="auto"
                        >
                            <polygon points="0 0, ${markerWidth} ${markerHeight / 2}, 0 ${markerHeight}" fill="rgba(37,99,235,0.9)" />
                        </marker>
                    </defs>

                    <line
                        x1="${userXPercent.toFixed(2)}"
                        y1="${userYPercent.toFixed(2)}"
                        x2="${navTargetXPercent.toFixed(2)}"
                        y2="${navTargetYPercent.toFixed(2)}"
                        stroke="rgba(37,99,235,0.9)"
                        stroke-width="1.5"
                        stroke-dasharray="3 2"
                        marker-end="url(#navArrow)"
                        class="${lineClass}"
                    />
                    <text
                        x="${midX.toFixed(2)}"
                        y="${midY.toFixed(2)}"
                        text-anchor="middle"
                        dominant-baseline="central"
                        font-size="3"
                        fill="#1f2937"
                        stroke="white"
                        stroke-width="0.3"
                    >
                        ${distLabel}
                    </text>
                </svg>
            `;
        }
    }


    // Combine all elements for the map container
     // Combine all elements for the map container
    const finalMapContent = userConfidenceCircleHtml + trackSvgHtml + navLineHtml + pinsHtml + userPinAndLabelHtml;

    // --- Container with grid background & zoom/pan controls ---
    let containerClasses =
        "relative overflow-hidden border-4 border-gray-400 rounded-lg my-4 bg-gray-200 w-full aspect-square";

    const gridStyle = `
        background-image:
          linear-gradient(to right, rgba(0,0,0,0.06) 1px, transparent 1px),
          linear-gradient(to bottom, rgba(0,0,0,0.06) 1px, transparent 1px);
        background-size: 10% 10%;
    `;

    const transformStyle = `
        transform: translate(${mapOffsetX}%, ${mapOffsetY}%) scale(${mapZoom});
        transform-origin: center center;
    `;

    return `
        <div
            id="target-map-container"
            class="${containerClasses}"
            style="${gridStyle}"
            onmousedown="startMapDrag(event)"
            ontouchstart="startMapDrag(event)"
        >
            <div class="map-inner-layer absolute inset-0" style="${transformStyle}">
                ${finalMapContent}
            </div>

            <div class="absolute bottom-2 right-2 flex gap-1 bg-white/80 px-2 py-1 rounded text-xs text-gray-700 shadow pointer-events-auto map-zoom-controls">
                <button
                    type="button"
                    class="px-2 py-1 rounded bg-gray-200 hover:bg-gray-300 font-bold"
                    onclick="zoomMapOut(event)"
                >−</button>
                <button
                    type="button"
                    class="px-2 py-1 rounded bg-gray-200 hover:bg-gray-300 font-bold"
                    onclick="zoomMapIn(event)"
                >+</button>
                <button
                    type="button"
                    class="px-2 py-1 rounded bg-gray-200 hover:bg-gray-300"
                    onclick="resetMapView(event)"
                >Reset</button>
            </div>
        </div>
    `;
}
       /** Toggles the map state and re-renders immediately. */
function toggleMapFullscreen() {
    // Toggle the state variable
    isMapFullscreen = !isMapFullscreen;
    
    // Re-render the page immediately so the new class is applied
    // This also resets the auto-refresh timer, which is fine.
    render(); 
}  

function renderNavigationPanel(openSurvey) {
    // If no navigation target has been selected yet, show a hint.
    if (!navigationTargetId) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-dashed border-gray-300 mb-6">
                <h3 class="text-lg font-semibold text-gray-700 mb-1">
                    <i class="fas fa-location-arrow mr-2"></i> Navigation
                </h3>
                <p class="text-sm text-gray-600">
                    Tap a target pin on the plot to select it for navigation. 
                    Once selected, distance and bearing from your GPS position will appear here.
                </p>
            </div>
        `;
    }

    // Look up the selected target in the open survey
    const target = openSurvey.targets.find(t => t.id === navigationTargetId);

    if (!target) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-red-300 mb-6">
                <h3 class="text-lg font-semibold text-red-700 mb-1">
                    <i class="fas fa-exclamation-triangle mr-2"></i> Navigation Target Missing
                </h3>
                <p class="text-sm text-gray-600">
                    The selected navigation target could not be found. It may have been deleted.
                </p>
                <button 
                    class="mt-3 px-3 py-1 text-xs font-semibold rounded bg-gray-200 hover:bg-gray-300"
                    onclick="clearNavigationTarget()">
                    Clear navigation target
                </button>
            </div>
        `;
    }

    // Ensure the target has usable coordinates
    if (!target.coordinates || !target.coordinates.includes(',')) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-yellow-300 mb-6">
                <h3 class="text-lg font-semibold text-yellow-700 mb-1">
                    <i class="fas fa-map-marker-alt mr-2"></i> Navigation Target
                </h3>
                <p class="text-sm text-gray-600">
                    Target <strong>${target.description}</strong> is selected, but it has no valid GPS coordinates logged,
                    so distance and bearing cannot be calculated.
                </p>
                <button 
                    class="mt-3 px-3 py-1 text-xs font-semibold rounded bg-gray-200 hover:bg-gray-300"
                    onclick="clearNavigationTarget()">
                    Clear navigation target
                </button>
            </div>
        `;
    }

    // Parse target coordinates
    const parts = target.coordinates.split(',').map(c => parseFloat(c.trim()));
    const targetLat = parts[0];
    const targetLon = parts[1];

    if (isNaN(targetLat) || isNaN(targetLon)) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-yellow-300 mb-6">
                <h3 class="text-lg font-semibold text-yellow-700 mb-1">
                    <i class="fas fa-map-marker-alt mr-2"></i> Navigation Target
                </h3>
                <p class="text-sm text-gray-600">
                    Target <strong>${target.description}</strong> has invalid GPS data and cannot be used for navigation.
                </p>
                <button 
                    class="mt-3 px-3 py-1 text-xs font-semibold rounded bg-gray-200 hover:bg-gray-300"
                    onclick="clearNavigationTarget()">
                    Clear navigation target
                </button>
            </div>
        `;
    }

    // Decide which user coords to use (prefer smoothed if available)
    const effectiveUser = smoothedUserCoords || currentUserCoords;

    if (!effectiveUser) {
        return `
            <div class="bg-white p-4 rounded-xl shadow-md border border-blue-300 mb-6">
                <h3 class="text-lg font-semibold text-blue-700 mb-1">
                    <i class="fas fa-location-arrow mr-2"></i> Navigation to: ${target.description}
                </h3>
                <p class="text-sm text-gray-600">
                    Target is selected, but waiting for your GPS position…
                    Once your location is available, distance and bearing will appear here.
                </p>
                <button 
                    class="mt-3 px-3 py-1 text-xs font-semibold rounded bg-gray-200 hover:bg-gray-300"
                    onclick="clearNavigationTarget()">
                    Clear navigation target
                </button>
            </div>
        `;
    }

    // Compute distance and bearing using the global geo helpers
    const userLat = effectiveUser.lat;
    const userLon = effectiveUser.lon;

    const distMeters = distanceMeters(userLat, userLon, targetLat, targetLon);
    const bearingDeg = initialBearingDegrees(userLat, userLon, targetLat, targetLon);
    const bearingLabel = bearingToCompassPoint(bearingDeg, 16);

    const distStr =
        distMeters >= 1000
            ? (distMeters / 1000).toFixed(2) + ' km'
            : distMeters.toFixed(1) + ' m';

    const bearingStr = `${bearingDeg.toFixed(1)}° (${bearingLabel})`;
// --- Movement-based guidance (optional, only if we have enough movement) ---
let guidanceHtml = '';
const movementBearingDeg = computeMovementBearingDegrees();

if (movementBearingDeg !== null) {
    // Relative angle from movement direction to target direction
    let rel = bearingDeg - movementBearingDeg;
    // Normalise to -180..+180
    if (rel > 180) rel -= 360;
    if (rel <= -180) rel += 360;

    const absRel = Math.abs(rel);
    let guidanceText = '';
    let guidanceIcon = '';
    let guidanceClass = 'text-gray-700';

    if (absRel < 15) {
        guidanceText = 'On course – target roughly ahead of your walking direction.';
        guidanceIcon = '<i class="fas fa-arrow-up mr-1"></i>';
        guidanceClass = 'text-green-700';
    } else if (absRel < 45) {
        if (rel > 0) {
            guidanceText = 'Target slightly to your right – adjust a little right.';
            guidanceIcon = '<i class="fas fa-arrow-up-right mr-1"></i>';
        } else {
            guidanceText = 'Target slightly to your left – adjust a little left.';
            guidanceIcon = '<i class="fas fa-arrow-up-left mr-1"></i>';
        }
        guidanceClass = 'text-yellow-700';
    } else if (absRel < 135) {
        if (rel > 0) {
            guidanceText = 'Target to your right – turn more to the right.';
            guidanceIcon = '<i class="fas fa-arrow-right mr-1"></i>';
        } else {
            guidanceText = 'Target to your left – turn more to the left.';
            guidanceIcon = '<i class="fas fa-arrow-left mr-1"></i>';
        }
        guidanceClass = 'text-orange-700';
    } else {
        guidanceText = 'Target is roughly behind you – turn around.';
        guidanceIcon = '<i class="fas fa-arrow-down mr-1"></i>';
        guidanceClass = 'text-red-700';
    }

    guidanceHtml = `
        <p class="text-sm mt-2 ${guidanceClass}">
            <span class="font-semibold">Guidance:</span> ${guidanceIcon}${guidanceText}
        </p>
        <p class="text-xs text-gray-500 mt-1">
            Based on recent movement; walk a few metres to stabilise this guidance.
        </p>
    `;
} else {
    guidanceHtml = `
        <p class="text-sm text-gray-600 mt-2">
            <span class="font-semibold">Guidance:</span> Start walking a few metres so we can estimate your direction of travel.
        </p>
    `;
}
    return `
        <div class="bg-white p-4 rounded-xl shadow-md border border-green-300 mb-6">
            <div class="flex items-center justify-between mb-2">
                <h3 class="text-lg font-semibold text-green-700">
                    <i class="fas fa-location-arrow mr-2"></i> Navigation to: ${target.description}
                </h3>
                <button 
                    class="px-2 py-1 text-xs font-semibold rounded bg-gray-200 hover:bg-gray-300"
                    onclick="clearNavigationTarget()">
                    Clear
                </button>
            </div>
            <p class="text-sm text-gray-700 mb-1">
                <span class="font-semibold">Distance:</span> ${distStr}
            </p>
            <p class="text-sm text-gray-700 mb-1">
                <span class="font-semibold">Bearing from you:</span> ${bearingStr}
            </p>
            ${guidanceHtml}
        </div>
    `;

}

        // ======================================
// TRACK RECORDING HELPERS
// ======================================

function refreshActiveTrackFromSurveys() {
    activeTrackSurveyId = null;
    activeTrackId = null;

    if (!Array.isArray(surveys)) return;

    for (const survey of surveys) {
        if (!survey || !Array.isArray(survey.tracks)) continue;
        const active = survey.tracks.find(t => t && t.isRecording);
        if (active) {
            activeTrackSurveyId = survey.id;
            activeTrackId = active.id;
            break;
        }
    }
}

function ensureSurveyTracksArray(survey) {
    if (!survey) return;
    if (!Array.isArray(survey.tracks)) {
        survey.tracks = [];
    }
}

function findTrackById(trackId) {
    if (!trackId || !Array.isArray(surveys)) return null;
    for (const survey of surveys) {
        if (!survey || !Array.isArray(survey.tracks)) continue;
        const track = survey.tracks.find(t => t.id === trackId);
        if (track) {
            return { survey, track };
        }
    }
    return null;
}

function getActiveTrack() {
    if (!activeTrackId || !activeTrackSurveyId) return null;
    const survey = surveys.find(s => s.id === activeTrackSurveyId);
    if (!survey || !Array.isArray(survey.tracks)) return null;
    const track = survey.tracks.find(t => t.id === activeTrackId);
    if (!track) return null;
    return { survey, track };
}

/**
 * Log a point to the currently active track, if any.
 * Uses distanceMeters helper so we only record when you move a few metres.
 */
function logPointToActiveTrack(lat, lon, accuracy) {
    const active = getActiveTrack();
    if (!active) return;

    const { track } = active;
    if (!Array.isArray(track.points)) {
        track.points = [];
    }

    const now = Date.now();
    const last = track.points[track.points.length - 1];

    if (last) {
        const dist = distanceMeters(last.lat, last.lon, lat, lon);
        if (dist < TRACK_POINT_MIN_DISTANCE_METERS) {
            // Too small a move – don’t clutter the track
            return;
        }
    }

    track.points.push({
        time: now,
        lat,
        lon,
        accuracy: typeof accuracy === 'number' ? accuracy : null
    });

    saveSurveysToLocalStorage();
}

/**
 * Start recording a new track for the current open survey.
 */
function handleStartTrackClick() {
    const openSurvey = surveys.find(s => s.status === 'Open');

    if (!openSurvey) {
        showMessage('You must have an open survey to record a track.', 'error');
        return;
    }

    if (activeTrackId && activeTrackSurveyId) {
        showMessage('A track is already being recorded. Stop it before starting a new one.', 'warning');
        return;
    }

    ensureSurveyTracksArray(openSurvey);

    const nextIndex = openSurvey.tracks.length + 1;
    const name = `Track ${nextIndex}`;

    const newTrack = {
        id: generateId(),
        name,
        createdAt: Date.now(),
        isRecording: true,
        isVisible: true,   // shown on the map by default
        points: []
    };

    openSurvey.tracks.push(newTrack);

    activeTrackSurveyId = openSurvey.id;
    activeTrackId = newTrack.id;

    saveSurveysToLocalStorage();
    showMessage(`Started recording ${name}.`, 'success');
    render();
}

/**
 * Stop recording the active track (if any).
 */
function handleStopTrackClick() {
    const active = getActiveTrack();
    if (!active) {
        showMessage('No active track to stop.', 'warning');
        return;
    }

    active.track.isRecording = false;
    saveSurveysToLocalStorage();

    const name = active.track.name || 'track';

    activeTrackSurveyId = null;
    activeTrackId = null;

    showMessage(`Stopped recording ${name}.`, 'info');
    render();
}

/**
 * Toggle whether a track is drawn on the map.
 */
function toggleTrackVisibility(trackId, isVisible) {
    const found = findTrackById(trackId);
    if (!found) return;

    found.track.isVisible = !!isVisible;
    saveSurveysToLocalStorage();

    if (currentPage === 'Compass') {
        render();
    }
}

     
function renderTracksPanel(openSurvey) {
    if (!openSurvey) return '';

    const tracks = Array.isArray(openSurvey.tracks) ? openSurvey.tracks : [];
    const hasTracks = tracks.length > 0;
    const active = tracks.find(t => t.isRecording);

    const startButtonClass = active
        ? 'px-3 py-1 rounded-lg bg-gray-200 text-gray-500 text-xs font-semibold cursor-not-allowed opacity-60'
        : 'px-3 py-1 rounded-lg bg-primary text-white text-xs font-semibold hover:bg-primary/90';
    const stopButtonExtraClasses = active ? '' : ' hidden';

    const recordingStatusHtml = active
        ? `<span class="flex items-center text-[11px] text-red-600 font-semibold">
                <span class="inline-block w-2 h-2 rounded-full bg-red-500 mr-1 animate-pulse"></span>
                Recording: ${active.name || 'Track'}
           </span>`
        : `<span class="text-[11px] text-gray-500">Not currently recording</span>`;

    let tracksListHtml = '';

    if (hasTracks) {
        tracksListHtml = tracks.map(track => {
            const isVisible = track.isVisible !== false;
            const pointsCount = Array.isArray(track.points) ? track.points.length : 0;
            const created = track.createdAt
                ? new Date(track.createdAt).toLocaleTimeString([], {
                      hour: '2-digit',
                      minute: '2-digit'
                  })
                : '';
            const activeBadge = track.isRecording
                ? `<span class="ml-2 inline-flex items-center text-[10px] text-red-600 font-semibold">
                        <span class="inline-block w-2 h-2 rounded-full bg-red-500 mr-1 animate-pulse"></span>
                        recording
                   </span>`
                : '';

            return `
                <label class="flex items-center justify-between py-1 border-b border-gray-100 last:border-b-0">
                    <div class="flex items-center gap-2">
                        <input
                            type="checkbox"
                            class="track-visibility-toggle h-4 w-4 text-primary"
                            data-track-id="${track.id}"
                            ${isVisible ? 'checked' : ''}
                        >
                        <div class="flex flex-col">
                            <span class="text-sm font-medium text-gray-700">
                                ${track.name || 'Track'}
                            </span>
                            <span class="text-xs text-gray-500">
                                ${pointsCount} points${created ? ` · ${created}` : ''}
                            </span>
                        </div>
                    </div>
                    ${activeBadge}
                </label>
            `;
        }).join('');
    } else {
        tracksListHtml = `
            <p class="text-xs text-gray-500 italic">
                You don't have any tracks recorded yet for this survey.
                Use <strong>Start new track</strong> to begin logging your path.
            </p>
        `;
    }

    return `
        <div class="bg-white p-4 rounded-xl shadow-lg border border-gray-100 mb-4">
            <!-- Make this responsive: stack on small screens, side-by-side on larger -->
            <div class="flex flex-col gap-3 sm:flex-row sm:items-start sm:justify-between mb-3">
                <div>
                    <h3 class="text-xl font-semibold text-gray-700 flex items-center gap-2">
                        <i class="fas fa-route text-primary"></i>
                        Tracks for this survey
                    </h3>
                    <p class="text-xs text-gray-500 mt-1">
                        Select which tracks to overlay on the map. Tracks use your live GPS position.
                    </p>
                </div>
<div class="flex flex-col items-stretch sm:items-end gap-1">
    ${recordingStatusHtml}
    <div class="flex flex-col sm:flex-row items-stretch sm:items-center gap-2 mt-1 w-full sm:w-auto">
        <!-- CLEAR, BRIGHT GREEN START BUTTON -->
        <button
            id="start-track-btn"
            type="button"
            class="text-xs font-semibold rounded-lg shadow px-3 py-2 sm:w-auto w-full"
            style="background-color: rgb(var(--color-secondary)); color: white; border: 1px solid rgba(22, 101, 52, 0.8);"
        >
            <i class="fas fa-play mr-1"></i> Start new track
        </button>

        <!-- CLEAR, RED OUTLINED STOP BUTTON -->
        <button
            id="stop-track-btn"
            type="button"
            class="text-xs font-semibold rounded-lg shadow px-3 py-2 sm:w-auto w-full ${stopButtonExtraClasses}"
            style="
                background-color: rgba(220, 38, 38, 0.04);
                color: rgb(185, 28, 28);
                border: 1px solid rgb(248, 113, 113);
            "
        >
            <i class="fas fa-stop mr-1"></i> Stop
        </button>
    </div>
</div>
            </div>
            <div class="mt-2 space-y-1">
                ${tracksListHtml}
            </div>
        </div>
    `;
}
    function renderCompassPage(isAutoRefresh = false) {
    const openSurvey = surveys.find(s => s.status === 'Open');

    if (!openSurvey) {
        // First return path (handles no open survey)
        return `
            <div class="p-4">
                <h2 class="text-3xl font-bold text-primary mb-6">Targets Plot View</h2>
                <div class="bg-white p-6 rounded-xl shadow-lg border-l-4 border-red-500">
                    <h3 class="text-xl font-bold text-red-600 mb-3">No Open Survey</h3>
                    <p class="text-gray-700">Please open a survey on the **Home** page to view its targets on the plot.</p>
                </div>
            </div>
        `;
    }

    // Start the GPS watch and the 5-second rendering interval ONLY ONCE when navigating to the page manually
    // (This line must be inside the function body, which it is now)
    if (!isAutoRefresh) {
        startLiveMapLocationWatch();
    }
    
   // Filter for targets that actually have usable coordinates
const targets = getActiveTargets(openSurvey).filter(
    t => t.coordinates && t.coordinates.includes(',') && t.coordinates !== 'No GPS logged'
);

    // Second return path (renders the map view)
    // Second return path (renders the map view)
    return `
        <div class="p-4">
            <h2 class="text-3xl font-bold text-primary mb-6">Targets Plot View</h2>
            
            <!-- Survey info -->
            <div class="bg-card p-4 rounded-lg shadow-md mb-6 border-l-4 border-primary">
                <h3 class="text-xl font-semibold mb-1 text-gray-700">
                    Viewing Targets for: <span class="text-primary">${openSurvey.name}</span>
                </h3>
                <p class="text-sm text-gray-600">
                    Targets with valid GPS logged: <strong>${targets.length}</strong>
                </p>
                ${isAutoRefresh ? 
                    `<p class="text-sm text-green-600 mt-2">
                        <i class="fas fa-redo fa-spin mr-1"></i> Auto-refreshing map every 3 seconds...
                    </p>` : ''
                }
                       </div>

            <!-- Map first -->
            <div class="bg-white p-4 rounded-xl shadow-lg border border-gray-100 mb-4">
                <h3 class="text-xl font-semibold text-gray-700 flex items-center mb-3">
                    <i class="fas fa-map mr-2"></i> Survey Map
                </h3>
                ${renderTargetPlot(targets)}
            </div>

            <!-- Tracks below the map -->
            ${renderTracksPanel(openSurvey)}

            <!-- Then navigation panel -->
            ${renderNavigationPanel(openSurvey)}

            <!-- Explanatory text at the bottom -->
            <div class="bg-white p-3 rounded-lg shadow-sm border border-gray-200 text-xs text-gray-600 mt-4">
                <h4 class="font-semibold mb-1">Plot & navigation notes</h4>
                <ul class="list-disc list-inside space-y-1">
                    <li>The plot shows relative positions within the survey area. Targets are dots; your position is the blue circle.</li>
                    <li><span class="font-semibold">North</span> is towards the top of the box, and <span class="font-semibold">East</span> is towards the right.</li>
                    <li>Use the <span class="font-semibold">+</span> and <span class="font-semibold">−</span> buttons to zoom, and drag the map to keep targets in view.</li>
                    <li>Tap a target pin on the map to select it for navigation. The dashed line and arrow show direction from your GPS position to the target.</li>
                    <li>When you are inside the target’s confidence circle, the navigation line is hidden as you are already “on top” of the target.</li>
                </ul>
            </div>
        </div>
    `;
}
/** Renders the content for the Settings page. */
function renderSettingsPage() {
    const secondaryColor = 'rgb(var(--color-secondary))';
    return `
        <div class="p-4">
            <h2 class="text-3xl font-bold text-primary mb-6">Settings & Local Data Management</h2>

            <div class="bg-white p-4 rounded-xl shadow-lg mb-8 border border-gray-100">
                <h3 class="text-xl font-semibold text-gray-700 mb-3">Your Profile</h3>
                <p class="text-md text-gray-800 mb-1"><strong>Name:</strong> ${userProfile.name}</p>
                <p class="text-md text-gray-800 mb-4"><strong>Detector:</strong> ${userProfile.detector}</p>
                
                <div class="mt-4 pt-3 border-t border-gray-100">
                    <button onclick="showEditProfileModal()" 
                            class="px-3 py-2 text-white font-bold rounded-md text-sm hover:opacity-90 transition duration-150" 
                            style="background-color: ${secondaryColor};">
                        <i class="fas fa-user-edit mr-1"></i> Edit Profile
                    </button>
                </div>
            </div>

            <h3 class="text-2xl font-bold text-gray-700 mb-3">Survey Export &amp; Import </h3>

            <!-- EXPORT OPEN SURVEY (WITH PHOTOS) -->
            <div class="bg-white p-4 rounded-xl shadow-lg mb-6 border-l-4 border-emerald-500">
                <h4 class="text-lg font-semibold text-emerald-700 mb-2">Export Open Survey + Finds </h4>
                <p class="text-sm text-gray-600 mb-3">
                    This creates a <strong>.json file</strong> containing the currently open survey, all its targets,
                    any finds linked to that survey, and all associated photos. A log below shows export progress.
                </p>
                <button id="export-open-survey-with-photos-btn"
                        onclick="exportOpenSurveyWithPhotos()"
                        class="w-full bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-emerald-700 transition duration-150">
                    <i class="fas fa-download mr-1"></i> Export Open Survey 
                </button>
                <textarea id="export-open-survey-log" 
                          rows="6" 
                          readonly 
                          placeholder="Export log will appear here."
                          class="w-full p-2 border border-emerald-500 rounded-md font-mono text-xs mt-4"></textarea>
            </div>

            <!-- IMPORT SURVEY (WITH PHOTOS) -->
            <div class="bg-white p-4 rounded-xl shadow-lg mb-8 border-l-4 border-emerald-500">
                <h4 class="text-lg font-semibold text-emerald-700 mb-2">Import Survey </h4>
                <p class="text-sm text-gray-600 mb-3">
                    Import a survey export file (created by the button above). The survey and its finds will be
                    <strong>added</strong> to your existing local data. Progress is shown in the log below.
                </p>

                <div class="mb-3">
                   <div class="w-full mb-3 flex flex-col gap-2">
                    <label for="import-survey-with-photos-file"
                       class="w-full bg-sky-600 text-white font-bold py-2 px-4 rounded-lg shadow-md text-center hover:bg-sky-700 transition duration-150 cursor-pointer">
                        <i class="fas fa-file mr-1"></i>Select Survey File
                        </label>
                <input type="file"
                       id="import-survey-with-photos-file"
                       accept=".json,application/json"
                       class="hidden" />
                        <button type="button"
                        onclick="triggerImportSurvey()"
                        class="w-full bg-emerald-600 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-emerald-700 transition duration-150">
                    <i class="fas fa-upload mr-1"></i> Import Survey
                </button>
                </div>
                </div>
                
                <textarea id="import-survey-log" 
                          rows="8" 
                          readonly
                          placeholder="Import log will appear here."
                          class="w-full p-2 border border-emerald-500 rounded-md font-mono text-xs"></textarea>
            </div>
            <div class="bg-white p-4 rounded-xl shadow-lg mb-6 border border-gray-100">
                <h4 class="text-lg font-semibold text-gray-700 mb-2">
                    Import Target via QR
                </h4>
                <p class="text-sm text-gray-600 mb-3">
                    Use your camera to scan a GeoFind Target QR code from another device.
                    The target will be added to the <strong>currently open survey</strong>.
                </p>
                <button
                    type="button"
                    class="w-full px-4 py-2 rounded-lg text-sm font-semibold text-white shadow-md hover:opacity-90"
                    style="background-color: ${secondaryColor};"
                    onclick="openTargetQrScanModal()"
                >
                    <i class="fas fa-qrcode mr-2"></i>
                    Import Target via QR
                </button>
            </div>

            <!-- Danger Zone: Reset All Data -->
            <div class="mt-8 border-t border-gray-300 pt-6">
                <h3 class="text-lg font-semibold text-red-600 mb-3">Danger Zone</h3>
                <button id="reset-all-data-btn"
                        class="w-full bg-red-700 text-white font-bold py-2 px-4 rounded-lg shadow-md hover:bg-red-800 transition duration-150">
                    <i class="fas fa-trash-alt mr-1"></i> Reset ALL Local Data on This Device
                </button>
                <p class="text-xs text-gray-500 mt-2">
                    This will delete all saved surveys, targets, finds and photos stored locally on this device.
                    Use this only after exporting anything important.
                </p>
            </div>
        </div>
    `;
}
/**
 * Convert a Blob to a data URL (base64).
 * Used when exporting photos so they can travel inside JSON.
 */
function blobToDataUrl(blob) {
    return new Promise((resolve, reject) => {
        const reader = new FileReader();
        reader.onloadend = () => resolve(reader.result);
        reader.onerror = reject;
        reader.readAsDataURL(blob);
    });
}

        // --- DATA MANAGEMENT FUNCTIONS ---

        /** Exports all data (surveys and profile) to a JSON string and displays it. */
        function exportData() {
            const dataToExport = {
                surveys: surveys,
                profile: userProfile,
                userId: userId,
                exportDate: new Date().toISOString()
            };

            const jsonString = JSON.stringify(dataToExport, null, 2);
            const dataArea = document.getElementById('exported-data-area');
            
            dataArea.value = jsonString;
            dataArea.classList.remove('hidden');
            dataArea.select(); // Select the text for easy copying
            
            // Try to copy to clipboard
            navigator.clipboard.writeText(jsonString).then(() => {
                showMessage('Data copied to clipboard! Paste it safely.', 'success');
            }).catch(err => {
                showMessage('Exported data displayed. Please manually copy the text.', 'warning');
                console.error('Could not copy text: ', err);
            });
        }

        /** Imports data from a JSON string, overwriting existing local storage. */
        function importData() {
            const dataArea = document.getElementById('import-data-area');
            const jsonString = dataArea.value.trim();

            if (!jsonString) {
                return showMessage('Please paste the JSON data into the box.', 'error');
            }

            try {
                const importedData = JSON.parse(jsonString);

                if (!importedData.surveys || !importedData.profile) {
                    throw new Error("Invalid data structure. Missing 'surveys' or 'profile' key.");
                }

                showConfirmationModal(
                    "Confirm Data Import",
                    `Are you sure you want to import data? This will **permanently overwrite** your ${surveys.length} existing local surveys.`,
                    () => {
                        // Overwrite global state
                        // Overwrite global state
                        surveys = importedData.surveys;
                        userProfile = importedData.profile;
                        userId = importedData.userId || generateId(); // Use existing ID or generate a new one

                        // NEW: re-evaluate any active track
                        refreshActiveTrackFromSurveys();

                        saveSurveysToLocalStorage();
                        dataArea.value = ''; // Clear the input area
                        showMessage('Data successfully imported and saved!', 'success');
                        currentPage = 'Home'; // Navigate to home to show new data
                        render();
                    }
                );
            } catch (e) {
                console.error("Import Error:", e);
                showMessage(`Import failed: ${e.message || 'Invalid JSON format.'}`, 'error');
            }
        }

// ------------------------------------------------------
//  SURVEY-LEVEL EXPORT / IMPORT (WITH PHOTOS EMBEDDED)
// ------------------------------------------------------

/**
 * Build an array of data URLs for a given photo array on a target or find.
 * It understands IndexedDB refs ("idb:123") and legacy direct data URLs.
 */
async function buildPhotoDataUrlsFromRefs(refs, fallbackSingleDataUrl) {
    const result = [];

    if (Array.isArray(refs) && refs.length) {
        for (const ref of refs) {
            if (typeof ref !== 'string' || !ref) continue;

            // New world: IndexedDB reference, e.g. "idb:5"
            if (isIndexedDbPhotoRef(ref)) {
                const id = parsePhotoRef(ref);
                if (id != null) {
                    const blob = await loadPhotoBlob(id);
                    if (blob) {
                        const dataUrl = await blobToDataUrl(blob);
                        if (dataUrl) result.push(dataUrl);
                    }
                }
            } else if (ref.startsWith('data:image/')) {
                // Legacy: direct base64 data URL
                result.push(ref);
            }
        }
    }

    // If nothing came from refs, fall back to a single stored thumbnail
    if (!result.length && fallbackSingleDataUrl && typeof fallbackSingleDataUrl === 'string') {
        result.push(fallbackSingleDataUrl);
    }

    return result;
}

// ------------------------------------------------------
// Confirmation modals for Export + Import
// (reuse the generic showConfirmationModal)
// ------------------------------------------------------
function showExportConfirmModal(onConfirmCallback) {
    showConfirmationModal(
        "Export survey",
        "Export the open survey, its targets, finds and photos?",
        onConfirmCallback
    );
}

function showImportConfirmModal(filename, onConfirmCallback) {
    showConfirmationModal(
        "Import survey",
        `Import survey from file "<strong>${filename}</strong>"?<br><br>` +
        `This will add the survey and its finds (with photos) to your local data.`,
        onConfirmCallback
    );
}

/**
 * Entry point for the Export button.
 * Checks there is an open survey, then shows a confirmation modal.
 */
function exportOpenSurveyWithPhotos() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('No open survey to export.', 'error');
        return;
    }

    showExportConfirmModal(() => {
        actuallyExportOpenSurvey();
    });
}

/**
 * Worker that does the actual export once the user has confirmed.
 */
async function actuallyExportOpenSurvey() {
    const openSurvey = surveys.find(s => s.status === 'Open');
    if (!openSurvey) {
        showMessage('No open survey to export.', 'error');
        return;
    }

    const btn    = document.getElementById('export-open-survey-with-photos-btn');
    const logBox = document.getElementById('export-open-survey-log');

    const log = (msg) => {
        if (!logBox) return;
        logBox.value += msg + '\n';
        logBox.scrollTop = logBox.scrollHeight;
    };

    // Clear previous log
    if (logBox) {
        logBox.value = '';
    }

    let originalBtnText = '';
    if (btn) {
        originalBtnText = btn.innerText;
        btn.disabled = true;
        btn.innerText = 'Exporting...';
    }

    try {
        log(`Starting export for survey: ${openSurvey.name || 'Unnamed survey'}`);

        // 1) Deep copy the survey so we don't mutate live data
        const surveyCopy = JSON.parse(JSON.stringify(openSurvey));

        // 2) Survey-level photo (if present)
        log('Processing survey photo...');
        let surveyPhotoDataUrl = surveyCopy.surveyPhotoData || '';
        if (!surveyPhotoDataUrl && openSurvey.surveyPhotoRef && isIndexedDbPhotoRef(openSurvey.surveyPhotoRef)) {
            const id = parsePhotoRef(openSurvey.surveyPhotoRef);
            if (id != null) {
                const blob = await loadPhotoBlob(id);
                if (blob) {
                    surveyPhotoDataUrl = await blobToDataUrl(blob);
                }
            }
        }
        surveyCopy.exportSurveyPhotoDataUrl = surveyPhotoDataUrl || null;

        // 3) Targets (with photos)
        surveyCopy.targets = [];
        if (Array.isArray(openSurvey.targets)) {
            log(`Processing ${openSurvey.targets.length} targets...`);
            let index = 0;
            for (const t of openSurvey.targets) {
                index++;
                log(`  Target ${index}/${openSurvey.targets.length}: ${t.description || t.id || ''}`);

                const tCopy = JSON.parse(JSON.stringify(t));
                const targetThumb = t.targetPhotoData || t.photoDataUrl || '';
                const photoDataUrls = await buildPhotoDataUrlsFromRefs(t.photos || [], targetThumb);

                tCopy.exportPhotosDataUrls = photoDataUrls;
                surveyCopy.targets.push(tCopy);
            }
        }

        // 4) Finds linked to this survey
        const linkedFinds = finds.filter(f => f.surveyId === openSurvey.id);
        const findsCopy = [];
        log(`Processing ${linkedFinds.length} linked finds...`);

        let findIndex = 0;
        for (const f of linkedFinds) {
            findIndex++;
            log(`  Find ${findIndex}/${linkedFinds.length}: ${f.description || f.id || ''}`);

            const fCopy = JSON.parse(JSON.stringify(f));
            const findThumb = f.targetPhotoData || f.photoDataUrl || '';
            const photoDataUrls = await buildPhotoDataUrlsFromRefs(f.photos || [], findThumb);

            fCopy.exportPhotosDataUrls = photoDataUrls;
            findsCopy.push(fCopy);
        }

        // 5) Build the export payload
        log('Building final JSON payload...');
        const payload = {
            version: 'geoFind-open-survey-v1',
            exportedAt: new Date().toISOString(),
            profile: userProfile,
            survey: surveyCopy,
            finds: findsCopy
        };

        const jsonString = JSON.stringify(payload);
        const sizeKb = Math.round(jsonString.length / 1024);
        log(`Payload size: ~${sizeKb} KB`);

        // 6) Create the export file
        const safeName = (openSurvey.name || 'survey')
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, '-')
            .replace(/^-+|-+$/g, '')
            || 'survey';

        const timestamp = new Date()
            .toISOString()
            .replace(/[:.]/g, '')
            .replace('T', '_')
            .replace('Z', '');

        const filename = `geoFind_${safeName}_${timestamp}.json`;

        const blob = new Blob([jsonString], { type: 'application/json' });
        const url  = URL.createObjectURL(blob);

        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        log(`Export complete. "${filename}" has been saved in your Downloads folder.`);
        showMessage('Survey export completed.', 'success');
    } catch (e) {
        console.error('Error exporting open survey with photos:', e);
        if (logBox) {
            log(`ERROR: ${e.message || 'Unknown error'}`);
        }
        showMessage(`Could not export open survey: ${e.message || 'Unknown error'}`, 'error');
    } finally {
        if (btn) {
            btn.disabled = false;
            // No "(with photos)" anymore:
            btn.innerText = originalBtnText || 'Export Open Survey';
        }
    }
}
/**
 * Internal worker to import a survey JSON string (with photos) and add it
 * to existing data. Uses a log function to report progress.
 */
async function performSurveyImport(text, filename, log) {
    let payload;

    log(`Parsing "${filename}"...`);
    try {
        payload = JSON.parse(text);
    } catch (e) {
        console.error('Survey import JSON parse error:', e);
        log(`ERROR: Invalid JSON (${e.message})`);
        showMessage(`Import failed: invalid JSON (${e.message})`, 'error');
        return;
    }

    if (!payload || !payload.survey) {
        log('ERROR: This JSON does not look like a survey export.');
        showMessage('Import failed: this JSON does not look like a survey export.', 'error');
        return;
    }

    let importedSurvey = payload.survey;
    let importedFinds  = Array.isArray(payload.finds) ? payload.finds : [];

    try {
        // Ensure survey has an id
        if (!importedSurvey.id) {
            importedSurvey.id = generateId();
        }

        log('Restoring survey photo...');
        if (importedSurvey.exportSurveyPhotoDataUrl) {
            const refs = await saveDataUrlsAsPhotoRefs([importedSurvey.exportSurveyPhotoDataUrl]);
            importedSurvey.surveyPhotoRef  = refs[0] || '';
            importedSurvey.surveyPhotoData = refs.length > 0 ? '' : importedSurvey.exportSurveyPhotoDataUrl;
            delete importedSurvey.exportSurveyPhotoDataUrl;
        }

        // 2) Targets: convert exportPhotosDataUrls -> IndexedDB refs
        if (!Array.isArray(importedSurvey.targets)) {
            importedSurvey.targets = [];
        }

        log(`Restoring ${importedSurvey.targets.length} targets...`);
        let tIndex = 0;
        for (const t of importedSurvey.targets) {
            tIndex++;
            log(`  Target ${tIndex}/${importedSurvey.targets.length}: ${t.description || t.id || ''}`);

            const dataUrls = Array.isArray(t.exportPhotosDataUrls) ? t.exportPhotosDataUrls : [];
            let refs = [];

            if (dataUrls.length) {
                refs = await saveDataUrlsAsPhotoRefs(dataUrls);
            }

            t.photos         = refs;
            t.targetPhotoRef = refs[0] || '';
            t.targetPhotoData = refs.length > 0 ? '' : (dataUrls[0] || '');
            delete t.exportPhotosDataUrls;

            if (!t.id) {
                t.id = generateId();
            }
        }

        // 3) Finds: convert exportPhotosDataUrls -> IndexedDB refs
        log(`Restoring ${importedFinds.length} finds...`);
        let fIndex = 0;
        for (const f of importedFinds) {
            fIndex++;
            log(`  Find ${fIndex}/${importedFinds.length}: ${f.description || f.id || ''}`);

            const dataUrls = Array.isArray(f.exportPhotosDataUrls) ? f.exportPhotosDataUrls : [];
            let refs = [];

            if (dataUrls.length) {
                refs = await saveDataUrlsAsPhotoRefs(dataUrls);
            }

            f.photos          = refs;
            f.findPhotoRef    = refs[0] || '';
            f.targetPhotoData = refs.length > 0 ? '' : (dataUrls[0] || '');
            delete f.exportPhotosDataUrls;

            if (!f.id) {
                f.id = generateId();
            }
            if (!f.surveyId) {
                f.surveyId = importedSurvey.id;
            }
        }

              // 4) Merge into live data (ADD, do not overwrite existing)
        log('Merging imported survey into local data...');
        surveys.push(importedSurvey);
        finds = finds.concat(importedFinds);

        saveSurveysToLocalStorage();
        saveFindsToLocalStorage();

        log(`"${filename}" has been successfully imported.`);
        showMessage(
            `Imported survey "${importedSurvey.name || 'Unnamed survey'}" with ` +
            `${Array.isArray(importedSurvey.targets) ? importedSurvey.targets.length : 0} targets and ` +
            `${importedFinds.length} finds.`,
            'success'
        );

        // Stay on Settings so the user can read the log.
        // They can navigate manually when ready.
    } catch (e) {
        console.error('Error importing survey with photos:', e);
        log(`ERROR: ${e.message || 'Unknown error'}`);
        showMessage(`Survey import failed: ${e.message || 'Unknown error'}`, 'error');
    }
}


/**
 * Read a chosen .json file and import it as a survey (with photos),
 * updating the import log as the process runs.
 */
async function importSurveyWithPhotosFromFile() {
    const fileInput = document.getElementById('import-survey-with-photos-file');
    const logBox    = document.getElementById('import-survey-log');

    const log = (msg) => {
        if (!logBox) return;
        logBox.value += msg + '\n';
        logBox.scrollTop = logBox.scrollHeight;
    };

    if (!fileInput || !fileInput.files || !fileInput.files.length) {
        showMessage('Please choose a survey .json file to import.', 'error');
        return;
    }

    const file = fileInput.files[0];

    // Clear previous log
    if (logBox) {
        logBox.value = '';
    }

    log(`Reading file "${file.name}"...`);

    let text;
    try {
        text = await file.text();
        log('File read successfully. Ready to import.');
    } catch (e) {
        console.error('Error reading survey import file:', e);
        log(`ERROR: Could not read file (${e.message || 'Unknown error'})`);
        showMessage(`Could not read import file: ${e.message || 'Unknown error'}`, 'error');
        return;
    }

    // Now ask for confirmation using the existing modal
    showImportConfirmModal(file.name, async () => {
        log('Starting import...');
        await performSurveyImport(text, file.name, log);
        // We stay on Settings so the user can read the log
    });
}

        // --- INITIALIZATION & EVENT LISTENERS ---

        // Event listener for navigation buttons
        document.querySelectorAll('.nav-btn').forEach(button => {
            button.addEventListener('click', (e) => {
                const targetPage = e.currentTarget.dataset.page;
                if (targetPage && targetPage !== currentPage) {
                    currentPage = targetPage;
                    render();
                }
            });
        });
        
        // 1. Load data first
        loadDataFromLocalStorage();
  //      showMessage("Data loaded instantly from local storage.", 'success'); // Show initial load message

        // 2. Initial render call
        render();

    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/qrcodejs/1.0.0/qrcode.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/jsqr@1.4.0/dist/jsQR.js"></script>

</body>
</html>
